diff --git a/arch/arm/configs/msm8916_sec_gtelwifi_usa_defconfig b/arch/arm/configs/msm8916_sec_gtelwifi_usa_defconfig
index d424ab48f3ef..486643b4b584 100755
--- a/arch/arm/configs/msm8916_sec_gtelwifi_usa_defconfig
+++ b/arch/arm/configs/msm8916_sec_gtelwifi_usa_defconfig
@@ -21,6 +21,7 @@ CONFIG_MUIC_SM5703_SUPPORT_LANHUB_TA=y
 #Touch Screen
 #CONFIG_TOUCHSCREEN_MMS300_A=y
 CONFIG_TOUCHSCREEN_ZT7554_TS=y
+CONFIG_INPUT_BOOSTER=y
 
 # Vibrator
 CONFIG_SM5703_VIBRATOR=n
diff --git a/drivers/input/Kconfig b/drivers/input/Kconfig
index bb469e32c608..b7c395f9de17 100644
--- a/drivers/input/Kconfig
+++ b/drivers/input/Kconfig
@@ -200,6 +200,20 @@ config SENSORS_HALL
 	 Say y here if you want to use this hall sensor driver, it
 	 is like a switch. For example, lid.
 
+config COMMON_INPUT_BOOSTER
+	tristate "input booster"
+	depends on INPUT
+	help
+	  Say Y here if you want to boost shen some keys and touches are pressed. If unsure, say N.
+
+config INPUT_BOOSTER
+	tristate "input booster"
+	depends on INPUT
+	default n
+	help
+	  Say Y here if you want to boost when some keys and touches are pressed. If unsure, say N.
+
+
 comment "Input Device Drivers"
 
 source "drivers/input/keyboard/Kconfig"
diff --git a/drivers/input/Makefile b/drivers/input/Makefile
index 481ed9f0e5cc..f1884b85a8c8 100644
--- a/drivers/input/Makefile
+++ b/drivers/input/Makefile
@@ -7,6 +7,8 @@
 obj-$(CONFIG_INPUT)		+= input-core.o
 input-core-y := input.o input-compat.o input-mt.o ff-core.o
 
+obj-$(CONFIG_INPUT_BOOSTER)	+= input_booster.o
+
 obj-$(CONFIG_INPUT_FF_MEMLESS)	+= ff-memless.o
 obj-$(CONFIG_INPUT_POLLDEV)	+= input-polldev.o
 obj-$(CONFIG_INPUT_SPARSEKMAP)	+= sparse-keymap.o
@@ -30,3 +32,7 @@ obj-$(CONFIG_INPUT_KEYCOMBO)	+= keycombo.o
 obj-$(CONFIG_SENSORS_HALL)	+= hall_sensor.o
 
 obj-$(CONFIG_INPUT_TOUCHSCREEN)	+= sec_cmd.o
+
+# Input Booster
+obj-$(CONFIG_COMMON_INPUT_BOOSTER)	+= input_booster_common.o
+
diff --git a/drivers/input/input.c b/drivers/input/input.c
index f0a193671a29..cf8890744f9f 100644
--- a/drivers/input/input.c
+++ b/drivers/input/input.c
@@ -29,6 +29,10 @@
 #include <linux/rcupdate.h>
 #include "input-compat.h"
 
+#if !defined(CONFIG_INPUT_BOOSTER) // Input Booster +
+#include <linux/input/input.h>
+#endif // Input Booster -
+
 MODULE_AUTHOR("Vojtech Pavlik <vojtech@suse.cz>");
 MODULE_DESCRIPTION("Input core");
 MODULE_LICENSE("GPL");
@@ -403,6 +407,382 @@ static void input_handle_event(struct input_dev *dev,
 
 }
 
+
+#if !defined(CONFIG_INPUT_BOOSTER) // Input Booster +
+// ********** Define Timeout Functions ********** //
+DECLARE_TIMEOUT_FUNC(touch);
+DECLARE_TIMEOUT_FUNC(multitouch);
+DECLARE_TIMEOUT_FUNC(key);
+DECLARE_TIMEOUT_FUNC(touchkey);
+DECLARE_TIMEOUT_FUNC(keyboard);
+DECLARE_TIMEOUT_FUNC(mouse);
+DECLARE_TIMEOUT_FUNC(mouse_wheel);
+DECLARE_TIMEOUT_FUNC(pen);
+DECLARE_TIMEOUT_FUNC(hover);
+
+// ********** Define Set Booster Functions ********** //
+DECLARE_SET_BOOSTER_FUNC(touch);
+DECLARE_SET_BOOSTER_FUNC(multitouch);
+DECLARE_SET_BOOSTER_FUNC(key);
+DECLARE_SET_BOOSTER_FUNC(touchkey);
+DECLARE_SET_BOOSTER_FUNC(keyboard);
+DECLARE_SET_BOOSTER_FUNC(mouse);
+DECLARE_SET_BOOSTER_FUNC(mouse_wheel);
+DECLARE_SET_BOOSTER_FUNC(pen);
+DECLARE_SET_BOOSTER_FUNC(hover);
+
+// ********** Define State Functions ********** //
+DECLARE_STATE_FUNC(idle)
+{
+	struct t_input_booster *_this = (struct t_input_booster *)(__this);
+	glGage = HEADGAGE;
+	if(input_booster_event == BOOSTER_ON) {
+		int i;
+		pr_debug("[Input Booster] %s      State0 : Idle  index : %d, cpu : %d, time : %d, input_booster_event : %d\n", glGage, _this->index, _this->param[_this->index].cpu_freq, _this->param[_this->index].time, input_booster_event);
+		_this->index=0;
+		for(i=0;i<2;i++) {
+			if(delayed_work_pending(&_this->input_booster_timeout_work[i])) {
+				pr_debug("[Input Booster] ****             cancel the pending workqueue\n");
+				cancel_delayed_work(&_this->input_booster_timeout_work[i]);
+			}
+		}
+		SET_BOOSTER;
+		schedule_delayed_work(&_this->input_booster_timeout_work[_this->index], msecs_to_jiffies(_this->param[_this->index].time));
+		_this->index++;
+		CHANGE_STATE_TO(press);
+	} else if(input_booster_event == BOOSTER_OFF) {
+		pr_debug("[Input Booster] %s      Skipped  index : %d, cpu : %d, input_booster_event : %d\n", glGage, _this->index, _this->param[_this->index].cpu_freq, input_booster_event);
+		pr_debug("\n");
+	}
+}
+
+DECLARE_STATE_FUNC(press)
+{
+	struct t_input_booster *_this = (struct t_input_booster *)(__this);
+	glGage = TAILGAGE;
+
+	if(input_booster_event == BOOSTER_OFF) {
+		pr_debug("[Input Booster] %s      State : Press  index : %d, time : %d\n", glGage, _this->index, _this->param[_this->index].time);
+		if(_this->multi_events <= 0) {
+			if(delayed_work_pending(&_this->input_booster_timeout_work[(_this->index) ? _this->index-1 : 0]) || (_this->param[(_this->index) ? _this->index-1 : 0].time == 0)) {
+				if(_this->change_on_release || (_this->param[(_this->index) ? _this->index-1 : 0].time == 0)) {
+					pr_debug("[Input Booster] %s           cancel the pending workqueue\n", glGage);
+					cancel_delayed_work(&_this->input_booster_timeout_work[(_this->index) ? _this->index-1 : 0]);
+					SET_BOOSTER;
+				}
+				schedule_delayed_work(&_this->input_booster_timeout_work[_this->index], msecs_to_jiffies(_this->param[_this->index].time));
+				pr_debug("[Input Booster] %s           schedule_delayed_work again  time : %d\n", glGage, _this->param[_this->index].time);
+				if(!delayed_work_pending(&_this->input_booster_timeout_work[_this->index]) && _this->param[_this->index].time > 0) {
+					pr_debug("[Input Booster] %s           schedule_delayed_work Re-again time : %d\n", glGage, _this->param[(_this->index > 0) ? _this->index-1 : _this->index].time);
+					schedule_delayed_work(&_this->input_booster_timeout_work[(_this->index > 0) ? _this->index-1 : _this->index], msecs_to_jiffies(_this->param[(_this->index > 0) ? _this->index-1 : _this->index].time));
+				}
+			} else if(_this->param[_this->index].time > 0) {
+				schedule_delayed_work(&_this->input_booster_timeout_work[_this->index], msecs_to_jiffies(_this->param[_this->index].time));
+			} else {
+				schedule_delayed_work(&_this->input_booster_timeout_work[(_this->index) ? _this->index-1 : 0], msecs_to_jiffies(_this->param[(_this->index > 0) ? _this->index-1 : _this->index].time));
+			}
+			_this->index++;
+			_this->multi_events = (_this->multi_events > 0) ? 0 : _this->multi_events;
+			CHANGE_STATE_TO(idle);
+		}
+	} else if(input_booster_event == BOOSTER_ON) {
+		if(delayed_work_pending(&_this->input_booster_timeout_work[_this->index])) {
+			pr_debug("[Input Booster] %s           cancel the pending workqueue for multi events\n", glGage);
+			cancel_delayed_work(&_this->input_booster_timeout_work[_this->index]);
+			schedule_delayed_work(&_this->input_booster_timeout_work[(_this->index) ? _this->index-1 : 0], msecs_to_jiffies(_this->param[(_this->index > 0) ? _this->index-1 : _this->index].time));
+		} else {
+			pr_debug("[Input Booster] %s      State : Press  index : %d, time : %d\n", glGage, _this->index, _this->param[_this->index].time);
+		}
+	}
+}
+
+// ********** Detect Events ********** //
+void input_booster(struct input_dev *dev)
+{
+	int i, j, DetectedCategory = false, iTouchID = -1, iTouchSlot = -1/*,lcdoffcounter = 0*/;
+
+	for(i=0;i<input_count;i++) {
+		if (DetectedCategory) {
+			break;
+		} else if (input_events[i].type == EV_KEY) {
+			switch (input_events[i].code) {
+				case BTN_TOUCH :
+					if(input_events[i+1].type == EV_KEY && input_events[i+1].code == BTN_TOOL_PEN) {
+						if(input_events[i].value && !pen_booster.multi_events) {
+							pr_debug("[Input Booster] PEN EVENT - PRESS\n");
+							RUN_BOOSTER(pen, BOOSTER_ON);
+							DetectedCategory = true;
+						} else if(!input_events[i].value && pen_booster.multi_events) {
+							pr_debug("[Input Booster] PEN EVENT - RELEASE\n");
+							RUN_BOOSTER(pen, BOOSTER_OFF);
+							DetectedCategory = true;
+						}
+					} else if(iTouchID >= 0) { // ***************** Checking Touch Event's ID whethere it is same with previous ID.
+						if(!input_events[i].value && input_events[iTouchID].value < 0) {  // If this event is 'Release'
+							for(j=0;j<MAX_MULTI_TOUCH_EVENTS;j++) {
+								TouchIDs[j] = -1;
+							}
+						}
+					}
+					break;
+				case BTN_TOOL_PEN :
+					if(input_events[i].value && !hover_booster.multi_events) {
+						pr_debug("[Input Booster] PEN EVENT - HOVER ON\n");
+						RUN_BOOSTER(hover, BOOSTER_ON);
+						DetectedCategory = true;
+					} else if(!input_events[i].value && hover_booster.multi_events) {
+						pr_debug("[Input Booster] PEN EVENT - HOVER OFF\n");
+						RUN_BOOSTER(hover, BOOSTER_OFF);
+						DetectedCategory = true;
+					}
+					break;
+				case KEY_BACK : // ***************** Checking Key & Touch key Event
+					if(key_back != input_events[i].value) {
+						key_back = input_events[i].value;
+						pr_debug("[Input Booster] TOUCHKEY EVENT - %s\n", (input_events[i].value) ? "PRESS" : "RELEASE");
+						RUN_BOOSTER(touchkey, (input_events[i].value) ? BOOSTER_ON : BOOSTER_OFF );
+						DetectedCategory = true;
+					}
+					break;
+				case KEY_HOMEPAGE :
+					if(key_home != input_events[i].value) {
+						key_home = input_events[i].value;
+						pr_debug("[Input Booster] TOUCHKEY EVENT - %s\n", (input_events[i].value) ? "PRESS" : "RELEASE");
+						RUN_BOOSTER(touchkey, (input_events[i].value) ? BOOSTER_ON : BOOSTER_OFF );
+						DetectedCategory = true;
+					}
+					break;
+				case KEY_RECENT :
+					if(key_recent != input_events[i].value) {
+						key_recent = input_events[i].value;
+						pr_debug("[Input Booster] TOUCHKEY EVENT - %s\n", (input_events[i].value) ? "PRESS" : "RELEASE");
+						RUN_BOOSTER(touchkey, (input_events[i].value) ? BOOSTER_ON : BOOSTER_OFF );
+						DetectedCategory = true;
+					}
+					break;
+				case KEY_VOLUMEUP :
+				case KEY_VOLUMEDOWN :
+				case KEY_POWER :
+					pr_debug("[Input Booster] KEY EVENT - %s\n", (input_events[i].value) ? "PRESS" : "RELEASE");
+					RUN_BOOSTER(key, (input_events[i].value) ? BOOSTER_ON : BOOSTER_OFF );
+					DetectedCategory = true;
+					break;
+				default :
+					break;
+			}
+		} else if (input_events[i].type == EV_ABS) {
+			if (input_events[i].code == ABS_MT_TRACKING_ID) {
+				iTouchID = i;
+				if(input_events[iTouchSlot].value < MAX_MULTI_TOUCH_EVENTS && input_events[iTouchSlot].value >= 0 && iTouchID < MAX_EVENTS && iTouchSlot <= MAX_EVENTS) {
+					if(TouchIDs[input_events[iTouchSlot].value] < 0 && input_events[iTouchID].value >= 0) {
+						TouchIDs[input_events[iTouchSlot].value] = input_events[iTouchID].value;
+						if(touch_booster.multi_events <= 0 || input_events[iTouchSlot].value == 0) {
+							touch_booster.multi_events = 0;
+							pr_debug("[Input Booster] TOUCH EVENT - PRESS - ID: 0x%x, Slot: 0x%x, multi : %d\n", input_events[iTouchID].value, input_events[iTouchSlot].value, touch_booster.multi_events);
+							RUN_BOOSTER(touch, BOOSTER_ON );
+						} else {
+							pr_debug("[Input Booster] MULTI-TOUCH EVENT - PRESS - ID: 0x%x, Slot: 0x%x, multi : %d\n", input_events[iTouchID].value, input_events[iTouchSlot].value, touch_booster.multi_events);
+							touch_booster.multi_events++;
+							RUN_BOOSTER(multitouch, BOOSTER_ON );
+#if defined(CONFIG_ARCH_EXYNOS)
+							if(delayed_work_pending(&touch_booster.input_booster_timeout_work[0])) {
+								int temp_hmp_boost = touch_booster.param[0].hmp_boost, temp_index = touch_booster.index;
+								pr_debug("[Input Booster] ****             cancel the pending touch booster workqueue\n");
+								cancel_delayed_work(&touch_booster.input_booster_timeout_work[0]);
+								touch_booster.param[0].hmp_boost = multitouch_booster.param[0].hmp_boost;
+								touch_booster.index = 1;
+								TIMEOUT_FUNC(touch)(NULL);
+								touch_booster.param[0].hmp_boost = temp_hmp_boost;
+								touch_booster.index = temp_index;
+							}
+#endif
+						}
+					} else if(TouchIDs[input_events[iTouchSlot].value] >= 0 && input_events[iTouchID].value < 0) {
+						TouchIDs[input_events[iTouchSlot].value] = input_events[iTouchID].value;
+						if(touch_booster.multi_events <= 1) {
+							pr_debug("[Input Booster] TOUCH EVENT - RELEASE - ID: 0x%x, Slot: 0x%x, multi : %d\n", input_events[iTouchID].value, input_events[iTouchSlot].value, touch_booster.multi_events);
+							RUN_BOOSTER(touch, BOOSTER_OFF );
+						} else {
+							pr_debug("[Input Booster] MULTI-TOUCH EVENT - RELEASE - ID: 0x%x, Slot: 0x%x, multi : %d\n", input_events[iTouchID].value, input_events[iTouchSlot].value, touch_booster.multi_events);
+							touch_booster.multi_events--;
+							RUN_BOOSTER(multitouch, BOOSTER_OFF );
+						}
+					}
+				}
+			} else if (input_events[i].code == ABS_MT_SLOT) {
+				iTouchSlot = i;
+				/*
+				if(input_events[iTouchSlot + 1].value < 0) {
+					lcdoffcounter++;
+				}
+				if(lcdoffcounter >= 10) { 
+					touch_booster.multi_events = 0;
+					multitouch_booster.multi_events = 0;
+					keyboard_booster.multi_events = 0;
+					pr_debug("[Input Booster] Multi events are reset  %d\n", lcdoffcounter);
+				}
+				*/
+			}
+		} else if (input_events[i].type == EV_MSC && input_events[i].code == MSC_SCAN) {
+			if (input_events[i+1].type == EV_KEY) {
+				switch (input_events[i+1].code) {
+					case BTN_LEFT : // ***************** Checking Touch Button Event
+					case BTN_RIGHT :
+					case BTN_MIDDLE :
+						pr_debug("[Input Booster] MOUSE EVENT - %s\n", (input_events[i+1].value) ? "PRESS" : "RELEASE");
+						RUN_BOOSTER(mouse, (input_events[i+1].value) ? BOOSTER_ON : BOOSTER_OFF );
+						DetectedCategory = true;
+						break;
+					default : // ***************** Checking Keyboard Event
+						pr_debug("[Input Booster] KEYBOARD EVENT - %s (multi count %d )\n", (input_events[i+1].value) ? "PRESS" : "RELEASE", keyboard_booster.multi_events);
+						RUN_BOOSTER(keyboard, (input_events[i+1].value) ? BOOSTER_ON : BOOSTER_OFF );
+						//DetectedCategory = true; // keyboard event can be continue in a set.
+						break;
+				}
+			}
+		} else if (input_events[i].type == EV_REL && input_events[i].code == REL_WHEEL && input_events[i].value) { // ***************** Wheel Event for Mouse
+			if (input_events[0].type == EV_KEY && input_events[0].code == BTN_LEFT) {
+				pr_debug("[Input Booster] MOUSE EVENT - %s\n", "WHELL");
+				RUN_BOOSTER(mouse_wheel, BOOSTER_ON);
+				DetectedCategory = true;
+			}
+		}
+	}
+}
+
+// ********** Init Booster ********** //
+void input_booster_init()
+{
+	// ********** Load Frequncy data from DTSI **********
+	struct device_node *np;
+	int nlevels = 0, i;
+
+	if(device_tree_infor != NULL){
+		return;
+	}
+
+	np = of_find_compatible_node(NULL, NULL, "input_booster");
+
+	if(np == NULL) {
+		ndevice_in_dt = 0;
+		return;
+	}
+
+	// Geting the count of devices.
+	ndevice_in_dt = of_get_child_count(np);
+	pr_debug("[Input Booster] %s   ndevice_in_dt : %d\n", __FUNCTION__, ndevice_in_dt);
+
+	device_tree_infor = kcalloc(ABS_CNT, sizeof(struct t_input_booster_device_tree_infor) * ndevice_in_dt, GFP_KERNEL);
+	if(device_tree_infor > 0) {
+		struct device_node *cnp;
+		int device_count = 0;
+
+		for_each_child_of_node(np, cnp) {
+			struct t_input_booster_device_tree_infor *dt_infor = (device_tree_infor + device_count);
+			const u32 *plevels = NULL;
+
+			// Geting label.
+			dt_infor->label = of_get_property(cnp, "input_booster,label", NULL);
+			pr_debug("[Input Booster] %s   dt_infor->label : %s\n", __FUNCTION__, dt_infor->label);
+
+			if (of_property_read_u32(cnp, "input_booster,type", &dt_infor->type)) {
+				pr_debug("Failed to get type property\n");
+				break;
+			}
+
+			// Geting the count of levels.
+			plevels = of_get_property(cnp, "input_booster,levels", &nlevels);
+
+			if (plevels && nlevels) {
+				dt_infor->nlevels = nlevels / sizeof(u32);
+				pr_debug("[Input Booster] %s   dt_infor->nlevels : %d\n", __FUNCTION__, dt_infor->nlevels);
+			} else {
+				pr_debug("Failed to calculate number of frequency.\n");
+				break;
+			}
+
+			// Allocation the param table.
+			dt_infor->param_tables = kcalloc(ABS_CNT, sizeof(struct t_input_booster_device_tree_param) * dt_infor->nlevels, GFP_KERNEL);
+			if (!dt_infor->param_tables) {
+				pr_debug("Failed to allocate memory of freq_table\n");
+				break;
+			}
+
+			// fill the param table
+			pr_debug("[Input Booster] device_type:%d, label :%s, type: 0x%02x, num_level[%d]\n",
+				dt_infor->type, dt_infor->label, dt_infor->type, dt_infor->nlevels);
+
+			for (i = 0; i < dt_infor->nlevels; i++) {
+				u32 temp;
+				int err = 0;
+
+				err = of_property_read_u32_index(cnp, "input_booster,levels", i, &temp);  dt_infor->param_tables[i].ilevels = (u8)temp;
+				DTSI_TO;
+				if (err) {
+					pr_debug("Failed to get [%d] param table property\n", i);
+				}
+/*
+				pr_debug("[Input Booster] Level %d : frequency[%d,%d,%d,%d] hmp_boost[%d] times[%d,%d,%d]\n", i,
+					dt_infor->param_tables[i].cpu_freq,
+					dt_infor->param_tables[i].kfc_freq,
+					dt_infor->param_tables[i].mif_freq,
+					dt_infor->param_tables[i].int_freq,
+					dt_infor->param_tables[i].hmp_boost,
+					dt_infor->param_tables[i].head_time,
+					dt_infor->param_tables[i].tail_time,
+					dt_infor->param_tables[i].phase_time);
+*/
+			}
+
+			device_count++;
+		}
+	}
+
+	// ********** Initialize Buffer for Touch **********
+	for(i=0;i<MAX_MULTI_TOUCH_EVENTS;i++) {
+		TouchIDs[i] = -1;
+	}
+
+	// ********** Initialize Booster **********
+	INIT_BOOSTER(touch)
+	INIT_BOOSTER(multitouch)
+	INIT_BOOSTER(key)
+	INIT_BOOSTER(touchkey)
+	INIT_BOOSTER(keyboard)
+	INIT_BOOSTER(mouse)
+	INIT_BOOSTER(mouse_wheel)
+	INIT_BOOSTER(pen)
+	INIT_BOOSTER(hover)
+	multitouch_booster.change_on_release = 1;
+
+	// ********** Initialize Sysfs **********
+	{
+		struct class *sysfs_class;
+
+		sysfs_class = class_create(THIS_MODULE, "input_booster");
+		if (IS_ERR(sysfs_class)) {
+			pr_debug("[Input Booster] Failed to create class\n");
+			return;
+		}
+
+		INIT_SYSFS_CLASS(debug_level)
+		INIT_SYSFS_CLASS(head)
+		INIT_SYSFS_CLASS(tail)
+		INIT_SYSFS_CLASS(level)
+
+		INIT_SYSFS_DEVICE(touch)
+		INIT_SYSFS_DEVICE(multitouch)
+		INIT_SYSFS_DEVICE(key)
+		INIT_SYSFS_DEVICE(touchkey)
+		INIT_SYSFS_DEVICE(keyboard)
+		INIT_SYSFS_DEVICE(mouse)
+		INIT_SYSFS_DEVICE(mouse_wheel)
+		INIT_SYSFS_DEVICE(pen)
+		INIT_SYSFS_DEVICE(hover)
+	}
+}
+#endif  // Input Booster -
+
 /**
  * input_event() - report new input event
  * @dev: device that generated the event
@@ -430,6 +810,24 @@ void input_event(struct input_dev *dev,
 		spin_lock_irqsave(&dev->event_lock, flags);
 		input_handle_event(dev, type, code, value);
 		spin_unlock_irqrestore(&dev->event_lock, flags);
+
+#if !defined(CONFIG_INPUT_BOOSTER) // Input Booster +
+		if(device_tree_infor != NULL) {
+			if (type == EV_SYN && input_count > 0) {
+				pr_debug("[Input Booster1] ==============================================\n");
+				input_booster(dev);
+				input_count=0;
+			} else {
+				pr_debug("[Input Booster1] type = %x, code = %x, value =%x\n", type, code, value);
+				input_events[input_count].type = type;
+				input_events[input_count].code = code;
+				input_events[input_count].value = value;
+				if(input_count < MAX_EVENTS) {
+					input_count++;
+				}
+			}
+		}
+#endif  // Input Booster -
 	}
 }
 EXPORT_SYMBOL(input_event);
@@ -2468,6 +2866,10 @@ static int __init input_init(void)
 		goto fail2;
 	}
 
+#if !defined(CONFIG_INPUT_BOOSTER) // Input Booster +
+	input_booster_init();
+#endif  // Input Booster -
+
 	return 0;
 
  fail2:	input_proc_exit();
diff --git a/drivers/input/keyboard/abov_touchkey_a8.c b/drivers/input/keyboard/abov_touchkey_a8.c
index 5a657aed3e19..2939f7afbfe0 100644
--- a/drivers/input/keyboard/abov_touchkey_a8.c
+++ b/drivers/input/keyboard/abov_touchkey_a8.c
@@ -37,6 +37,9 @@
 #ifdef CONFIG_OF
 #include <linux/of_gpio.h>
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
 
 #define ABOV_TK_NAME "abov-touchkey"
 
@@ -138,6 +141,9 @@ struct abov_tk_info {
 	struct delayed_work led_twinkle_work;
 	bool led_twinkle_check;
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster *tkey_booster;
+#endif
 };
 
 struct abov_touchkey_devicetree_data {
@@ -259,6 +265,10 @@ static void release_all_fingers(struct abov_tk_info *info)
 	}
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->tkey_booster && info->tkey_booster->dvfs_set)
+		info->tkey_booster->dvfs_set(info->tkey_booster, 2);
+#endif
 }
 
 static int abov_tk_reset_for_bootmode(struct abov_tk_info *info)
@@ -391,9 +401,65 @@ static irqreturn_t abov_tk_interrupt(int irq, void *dev_id)
 #endif
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->tkey_booster && info->tkey_booster->dvfs_set)
+		info->tkey_booster->dvfs_set(info->tkey_booster, press);
+#endif
+
 	return IRQ_HANDLED;
 }
 
+#ifdef CONFIG_INPUT_BOOSTER
+static ssize_t boost_level_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct abov_tk_info *info = dev_get_drvdata(dev);
+	int val, stage;
+	struct dvfs value;
+
+	if (!info->tkey_booster) {
+		dev_err(&info->client->dev,
+			"%s: booster is NULL\n", __func__);
+		return count;
+	}
+
+	sscanf(buf, "%d", &val);
+
+	stage = 1 << val;
+
+	if (!(info->tkey_booster->dvfs_stage & stage)) {
+		dev_info(&info->client->dev,
+			"%s: wrong cmd %d\n", __func__, val);
+		return count;
+	}
+
+	info->tkey_booster->dvfs_boost_mode = stage;
+	dev_info(&info->client->dev,
+			"%s: dvfs_boost_mode = 0x%X\n",
+			__func__, info->tkey_booster->dvfs_boost_mode);
+
+	if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		if (info->tkey_booster->dvfs_set)
+			info->tkey_booster->dvfs_set(info->tkey_booster, 2);
+	} else if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_SINGLE) {
+		input_booster_get_default_setting("head", &value);
+		info->tkey_booster->dvfs_freq = value.cpu_freq;
+		dev_info(&info->client->dev,
+			"%s: boost_mode SINGLE, dvfs_freq = %d\n",
+			__func__, info->tkey_booster->dvfs_freq);
+	} else if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_DUAL) {
+		input_booster_get_default_setting("tail", &value);
+		info->tkey_booster->dvfs_freq = value.cpu_freq;
+		dev_info(&info->client->dev,
+			"%s: boost_mode DUAL, dvfs_freq = %d\n",
+			__func__, info->tkey_booster->dvfs_freq);
+	}
+
+	return count;
+}
+#endif
+
 static int touchkey_led_set(struct abov_tk_info *info, int data)
 {
 	u8 cmd;
@@ -1095,6 +1161,10 @@ static DEVICE_ATTR(touchkey_firm_update_status, S_IRUGO | S_IWUSR | S_IWGRP,
 static DEVICE_ATTR(glove_mode, S_IRUGO | S_IWUSR | S_IWGRP,
 			abov_glove_mode_show, abov_glove_mode);
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+static DEVICE_ATTR(boost_level,
+		   S_IWUSR | S_IWGRP, NULL, boost_level_store);
+#endif
 
 static struct attribute *sec_touchkey_attributes[] = {
 	&dev_attr_touchkey_threshold.attr,
@@ -1110,6 +1180,9 @@ static struct attribute *sec_touchkey_attributes[] = {
 #ifdef GLOVE_MODE
 	&dev_attr_glove_mode.attr,
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	&dev_attr_boost_level.attr,
+#endif
 	NULL,
 };
 
@@ -1466,6 +1539,15 @@ static int abov_tk_probe(struct i2c_client *client,
 		goto err_reg_input_dev;
 	}
 
+#ifdef CONFIG_INPUT_BOOSTER
+	info->tkey_booster = input_booster_allocate(INPUT_BOOSTER_ID_TKEY);
+	if (!info->tkey_booster) {
+		dev_err(&client->dev,
+			"%s [ERROR] failed to allocate input booster\n", __func__);
+		goto err_alloc_booster_failed;
+	}
+#endif
+
 	info->enabled = true;
 
 	if (!info->dtdata->irq_flag) {
@@ -1519,6 +1601,11 @@ static int abov_tk_probe(struct i2c_client *client,
 	return 0;
 
 err_req_irq:
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->tkey_booster);
+	info->tkey_booster = NULL;
+err_alloc_booster_failed:
+#endif
 	input_unregister_device(input_dev);
 err_reg_input_dev:
 	mutex_destroy(&info->lock);
@@ -1570,6 +1657,10 @@ static int abov_tk_remove(struct i2c_client *client)
 		free_irq(info->irq, info);
 	input_unregister_device(info->input_dev);
 	input_free_device(info->input_dev);
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->tkey_booster);
+	info->tkey_booster = NULL;
+#endif
 	kfree(info);
 
 	return 0;
diff --git a/drivers/input/keyboard/abov_touchkey_ft16xx.c b/drivers/input/keyboard/abov_touchkey_ft16xx.c
index 3f276f7756fe..20a30f8694af 100644
--- a/drivers/input/keyboard/abov_touchkey_ft16xx.c
+++ b/drivers/input/keyboard/abov_touchkey_ft16xx.c
@@ -37,6 +37,9 @@
 #ifdef CONFIG_OF
 #include <linux/of_gpio.h>
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
 
 #define ABOV_TK_NAME "abov-ft1604"
 
@@ -137,6 +140,9 @@ struct abov_ft1604_info {
 	struct delayed_work led_twinkle_work;
 	bool led_twinkle_check;
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster *tkey_booster;
+#endif
 };
 
 struct abov_ft1604_devicetree_data {
@@ -259,6 +265,10 @@ static void release_all_fingers(struct abov_ft1604_info *info)
 	}
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->tkey_booster && info->tkey_booster->dvfs_set)
+		info->tkey_booster->dvfs_set(info->tkey_booster, 2);
+#endif
 }
 
 static int abov_tk_reset_for_bootmode(struct abov_ft1604_info *info)
@@ -391,9 +401,65 @@ static irqreturn_t abov_tk_interrupt(int irq, void *dev_id)
 #endif
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->tkey_booster && info->tkey_booster->dvfs_set)
+		info->tkey_booster->dvfs_set(info->tkey_booster, press);
+#endif
+
 	return IRQ_HANDLED;
 }
 
+#ifdef CONFIG_INPUT_BOOSTER
+static ssize_t boost_level_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct abov_ft1604_info *info = dev_get_drvdata(dev);
+	int val, stage;
+	struct dvfs value;
+
+	if (!info->tkey_booster) {
+		dev_err(&info->client->dev,
+			"%s: booster is NULL\n", __func__);
+		return count;
+	}
+
+	sscanf(buf, "%d", &val);
+
+	stage = 1 << val;
+
+	if (!(info->tkey_booster->dvfs_stage & stage)) {
+		dev_info(&info->client->dev,
+			"%s: wrong cmd %d\n", __func__, val);
+		return count;
+	}
+
+	info->tkey_booster->dvfs_boost_mode = stage;
+	dev_info(&info->client->dev,
+			"%s: dvfs_boost_mode = 0x%X\n",
+			__func__, info->tkey_booster->dvfs_boost_mode);
+
+	if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		if (info->tkey_booster->dvfs_set)
+			info->tkey_booster->dvfs_set(info->tkey_booster, 2);
+	} else if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_SINGLE) {
+		input_booster_get_default_setting("head", &value);
+		info->tkey_booster->dvfs_freq = value.cpu_freq;
+		dev_info(&info->client->dev,
+			"%s: boost_mode SINGLE, dvfs_freq = %d\n",
+			__func__, info->tkey_booster->dvfs_freq);
+	} else if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_DUAL) {
+		input_booster_get_default_setting("tail", &value);
+		info->tkey_booster->dvfs_freq = value.cpu_freq;
+		dev_info(&info->client->dev,
+			"%s: boost_mode DUAL, dvfs_freq = %d\n",
+			__func__, info->tkey_booster->dvfs_freq);
+	}
+
+	return count;
+}
+#endif
+
 static int touchkey_led_set(struct abov_ft1604_info *info, int data)
 {
 	u8 cmd;
@@ -1122,6 +1188,10 @@ static DEVICE_ATTR(touchkey_firm_update_status, S_IRUGO | S_IWUSR | S_IWGRP,
 static DEVICE_ATTR(glove_mode, S_IRUGO | S_IWUSR | S_IWGRP,
 			abov_glove_mode_show, abov_glove_mode);
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+static DEVICE_ATTR(boost_level,
+		   S_IWUSR | S_IWGRP, NULL, boost_level_store);
+#endif
 
 static struct attribute *sec_touchkey_attributes[] = {
 	&dev_attr_touchkey_threshold.attr,
@@ -1137,6 +1207,9 @@ static struct attribute *sec_touchkey_attributes[] = {
 #ifdef GLOVE_MODE
 	&dev_attr_glove_mode.attr,
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	&dev_attr_boost_level.attr,
+#endif
 	NULL,
 };
 
@@ -1510,6 +1583,15 @@ static int abov_tk_probe(struct i2c_client *client,
 		goto err_reg_input_dev;
 	}
 
+#ifdef CONFIG_INPUT_BOOSTER
+	info->tkey_booster = input_booster_allocate(INPUT_BOOSTER_ID_TKEY);
+	if (!info->tkey_booster) {
+		dev_err(&client->dev,
+			"%s [ERROR] failed to allocate input booster\n", __func__);
+		goto err_alloc_booster_failed;
+	}
+#endif
+
 	info->enabled = true;
 
 	if (!info->dtdata->irq_flag) {
@@ -1563,6 +1645,11 @@ static int abov_tk_probe(struct i2c_client *client,
 	return 0;
 
 err_req_irq:
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->tkey_booster);
+	info->tkey_booster = NULL;
+err_alloc_booster_failed:
+#endif
 	input_unregister_device(input_dev);
 err_reg_input_dev:
 	mutex_destroy(&info->lock);
@@ -1614,6 +1701,10 @@ static int abov_tk_remove(struct i2c_client *client)
 		free_irq(info->irq, info);
 	input_unregister_device(info->input_dev);
 	input_free_device(info->input_dev);
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->tkey_booster);
+	info->tkey_booster = NULL;
+#endif
 	kfree(info);
 
 	return 0;
diff --git a/drivers/input/keyboard/abov_touchkey_ft18xx.c b/drivers/input/keyboard/abov_touchkey_ft18xx.c
index 970d84e329c4..612bfff4bf0f 100644
--- a/drivers/input/keyboard/abov_touchkey_ft18xx.c
+++ b/drivers/input/keyboard/abov_touchkey_ft18xx.c
@@ -37,6 +37,9 @@
 #ifdef CONFIG_OF
 #include <linux/of_gpio.h>
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
 
 #define ABOV_TK_NAME "abov-touchkey"
 
@@ -166,6 +169,9 @@ struct abov_tk_info {
 	struct delayed_work led_twinkle_work;
 	bool led_twinkle_check;
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster *tkey_booster;
+#endif
 };
 
 struct abov_touchkey_devicetree_data {
@@ -345,6 +351,10 @@ static void release_all_fingers(struct abov_tk_info *info)
 	}
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->tkey_booster && info->tkey_booster->dvfs_set)
+		info->tkey_booster->dvfs_set(info->tkey_booster, 2);
+#endif
 }
 
 static int abov_tk_reset_for_bootmode(struct abov_tk_info *info)
@@ -476,9 +486,65 @@ static irqreturn_t abov_tk_interrupt(int irq, void *dev_id)
 
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->tkey_booster && info->tkey_booster->dvfs_set)
+		info->tkey_booster->dvfs_set(info->tkey_booster, press);
+#endif
+
 	return IRQ_HANDLED;
 }
 
+#ifdef CONFIG_INPUT_BOOSTER
+static ssize_t boost_level_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct abov_tk_info *info = dev_get_drvdata(dev);
+	int val, stage;
+	struct dvfs value;
+
+	if (!info->tkey_booster) {
+		dev_err(&info->client->dev,
+			"%s: booster is NULL\n", __func__);
+		return count;
+	}
+
+	sscanf(buf, "%d", &val);
+
+	stage = 1 << val;
+
+	if (!(info->tkey_booster->dvfs_stage & stage)) {
+		dev_info(&info->client->dev,
+			"%s: wrong cmd %d\n", __func__, val);
+		return count;
+	}
+
+	info->tkey_booster->dvfs_boost_mode = stage;
+	dev_info(&info->client->dev,
+			"%s: dvfs_boost_mode = 0x%X\n",
+			__func__, info->tkey_booster->dvfs_boost_mode);
+
+	if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		if (info->tkey_booster->dvfs_set)
+			info->tkey_booster->dvfs_set(info->tkey_booster, 2);
+	} else if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_SINGLE) {
+		input_booster_get_default_setting("head", &value);
+		info->tkey_booster->dvfs_freq = value.cpu_freq;
+		dev_info(&info->client->dev,
+			"%s: boost_mode SINGLE, dvfs_freq = %d\n",
+			__func__, info->tkey_booster->dvfs_freq);
+	} else if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_DUAL) {
+		input_booster_get_default_setting("tail", &value);
+		info->tkey_booster->dvfs_freq = value.cpu_freq;
+		dev_info(&info->client->dev,
+			"%s: boost_mode DUAL, dvfs_freq = %d\n",
+			__func__, info->tkey_booster->dvfs_freq);
+	}
+
+	return count;
+}
+#endif
+
 static int touchkey_led_set(struct abov_tk_info *info, int data)
 {
 	u8 cmd;
@@ -1439,6 +1505,10 @@ static DEVICE_ATTR(touchkey_firm_update_status, S_IRUGO | S_IWUSR | S_IWGRP,
 static DEVICE_ATTR(glove_mode, S_IRUGO | S_IWUSR | S_IWGRP,
 			abov_glove_mode_show, abov_glove_mode);
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+static DEVICE_ATTR(boost_level,
+		   S_IWUSR | S_IWGRP, NULL, boost_level_store);
+#endif
 
 static struct attribute *sec_touchkey_attributes[] = {
 	&dev_attr_touchkey_threshold.attr,
@@ -1463,6 +1533,9 @@ static struct attribute *sec_touchkey_attributes[] = {
 #ifdef GLOVE_MODE
 	&dev_attr_glove_mode.attr,
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	&dev_attr_boost_level.attr,
+#endif
 	NULL,
 };
 
@@ -1836,6 +1909,15 @@ static int abov_tk_probe(struct i2c_client *client,
 		goto err_reg_input_dev;
 	}
 
+#ifdef CONFIG_INPUT_BOOSTER
+	info->tkey_booster = input_booster_allocate(INPUT_BOOSTER_ID_TKEY);
+	if (!info->tkey_booster) {
+		dev_err(&client->dev,
+			"%s [ERROR] failed to allocate input booster\n", __func__);
+		goto err_alloc_booster_failed;
+	}
+#endif
+
 	info->enabled = true;
 
 	if (!info->dtdata->irq_flag) {
@@ -1889,6 +1971,11 @@ static int abov_tk_probe(struct i2c_client *client,
 	return 0;
 
 err_req_irq:
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->tkey_booster);
+	info->tkey_booster = NULL;
+err_alloc_booster_failed:
+#endif
 	input_unregister_device(input_dev);
 err_reg_input_dev:
 	mutex_destroy(&info->lock);
@@ -1940,6 +2027,10 @@ static int abov_tk_remove(struct i2c_client *client)
 		free_irq(info->irq, info);
 	input_unregister_device(info->input_dev);
 	input_free_device(info->input_dev);
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->tkey_booster);
+	info->tkey_booster = NULL;
+#endif
 	kfree(info);
 
 	return 0;
diff --git a/drivers/input/keyboard/abov_touchkey_na7.c b/drivers/input/keyboard/abov_touchkey_na7.c
index f7afc441dea3..c7f412130686 100644
--- a/drivers/input/keyboard/abov_touchkey_na7.c
+++ b/drivers/input/keyboard/abov_touchkey_na7.c
@@ -37,6 +37,9 @@
 #ifdef CONFIG_OF
 #include <linux/of_gpio.h>
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
 
 #define ABOV_TK_NAME "abov-touchkey"
 
@@ -146,6 +149,9 @@ struct abov_tk_info {
 	struct delayed_work led_twinkle_work;
 	bool led_twinkle_check;
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster *tkey_booster;
+#endif
 };
 
 struct abov_touchkey_devicetree_data {
@@ -293,6 +299,10 @@ static void release_all_fingers(struct abov_tk_info *info)
 	}
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->tkey_booster && info->tkey_booster->dvfs_set)
+		info->tkey_booster->dvfs_set(info->tkey_booster, 2);
+#endif
 }
 
 static int abov_tk_reset_for_bootmode(struct abov_tk_info *info)
@@ -425,9 +435,65 @@ static irqreturn_t abov_tk_interrupt(int irq, void *dev_id)
 #endif
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->tkey_booster && info->tkey_booster->dvfs_set)
+		info->tkey_booster->dvfs_set(info->tkey_booster, press);
+#endif
+
 	return IRQ_HANDLED;
 }
 
+#ifdef CONFIG_INPUT_BOOSTER
+static ssize_t boost_level_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct abov_tk_info *info = dev_get_drvdata(dev);
+	int val, stage;
+	struct dvfs value;
+
+	if (!info->tkey_booster) {
+		dev_err(&info->client->dev,
+			"%s: booster is NULL\n", __func__);
+		return count;
+	}
+
+	sscanf(buf, "%d", &val);
+
+	stage = 1 << val;
+
+	if (!(info->tkey_booster->dvfs_stage & stage)) {
+		dev_info(&info->client->dev,
+			"%s: wrong cmd %d\n", __func__, val);
+		return count;
+	}
+
+	info->tkey_booster->dvfs_boost_mode = stage;
+	dev_info(&info->client->dev,
+			"%s: dvfs_boost_mode = 0x%X\n",
+			__func__, info->tkey_booster->dvfs_boost_mode);
+
+	if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		if (info->tkey_booster->dvfs_set)
+			info->tkey_booster->dvfs_set(info->tkey_booster, 2);
+	} else if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_SINGLE) {
+		input_booster_get_default_setting("head", &value);
+		info->tkey_booster->dvfs_freq = value.cpu_freq;
+		dev_info(&info->client->dev,
+			"%s: boost_mode SINGLE, dvfs_freq = %d\n",
+			__func__, info->tkey_booster->dvfs_freq);
+	} else if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_DUAL) {
+		input_booster_get_default_setting("tail", &value);
+		info->tkey_booster->dvfs_freq = value.cpu_freq;
+		dev_info(&info->client->dev,
+			"%s: boost_mode DUAL, dvfs_freq = %d\n",
+			__func__, info->tkey_booster->dvfs_freq);
+	}
+
+	return count;
+}
+#endif
+
 static int touchkey_led_set(struct abov_tk_info *info, int data)
 {
 	u8 cmd;
@@ -1231,6 +1297,10 @@ static DEVICE_ATTR(touchkey_firm_update_status, S_IRUGO | S_IWUSR | S_IWGRP,
 static DEVICE_ATTR(glove_mode, S_IRUGO | S_IWUSR | S_IWGRP,
 			abov_glove_mode_show, abov_glove_mode);
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+static DEVICE_ATTR(boost_level,
+		   S_IWUSR | S_IWGRP, NULL, boost_level_store);
+#endif
 
 static struct attribute *sec_touchkey_attributes[] = {
 	&dev_attr_touchkey_threshold.attr,
@@ -1246,6 +1316,9 @@ static struct attribute *sec_touchkey_attributes[] = {
 #ifdef GLOVE_MODE
 	&dev_attr_glove_mode.attr,
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	&dev_attr_boost_level.attr,
+#endif
 	NULL,
 };
 
@@ -1610,6 +1683,15 @@ static int abov_tk_probe(struct i2c_client *client,
 		goto err_reg_input_dev;
 	}
 
+#ifdef CONFIG_INPUT_BOOSTER
+	info->tkey_booster = input_booster_allocate(INPUT_BOOSTER_ID_TKEY);
+	if (!info->tkey_booster) {
+		dev_err(&client->dev,
+			"%s [ERROR] failed to allocate input booster\n", __func__);
+		goto err_alloc_booster_failed;
+	}
+#endif
+
 	info->enabled = true;
 
 	if (!info->dtdata->irq_flag) {
@@ -1663,6 +1745,11 @@ static int abov_tk_probe(struct i2c_client *client,
 	return 0;
 
 err_req_irq:
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->tkey_booster);
+	info->tkey_booster = NULL;
+err_alloc_booster_failed:
+#endif
 	input_unregister_device(input_dev);
 err_reg_input_dev:
 	mutex_destroy(&info->lock);
@@ -1714,6 +1801,10 @@ static int abov_tk_remove(struct i2c_client *client)
 		free_irq(info->irq, info);
 	input_unregister_device(info->input_dev);
 	input_free_device(info->input_dev);
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->tkey_booster);
+	info->tkey_booster = NULL;
+#endif
 	kfree(info);
 
 	return 0;
diff --git a/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_core.c b/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_core.c
index b8a6bff23fa8..252a3c1bf8ad 100755
--- a/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_core.c
+++ b/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_core.c
@@ -4984,6 +4984,9 @@ int cyttsp5_core_suspend(struct device *dev)
 		cyttsp5_core_sleep(cd, 1);
 	}
 
+#ifdef CONFIG_INPUT_BOOSTER
+	cd->md.finger_flag = false;
+#endif
 	if (gpio_is_valid(cd->pdata->core_pdata->ta_gpio))
 		gpio_set_value(cd->pdata->core_pdata->ta_gpio, 0);
 
diff --git a/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_mt_common.c b/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_mt_common.c
index 04ea759d907e..04fe96afae81 100755
--- a/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_mt_common.c
+++ b/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_mt_common.c
@@ -182,6 +182,11 @@ static void cyttsp5_report_slot_liftoff(struct cyttsp5_mt_data *md,
 		input_mt_report_slot_state(md->input,
 			MT_TOOL_FINGER, false);
 	}
+#ifdef CONFIG_INPUT_BOOSTER
+	if(md->finger_flag)
+		input_booster_send_event(BOOSTER_DEVICE_TOUCH, BOOSTER_MODE_FORCE_OFF);
+	md->finger_flag = false;
+#endif
 }
 
 static int cyttsp5_input_register_device(struct input_dev *input,
@@ -485,6 +490,14 @@ static void cyttsp5_get_mt_touches(struct cyttsp5_mt_data *md,
 				(tch->abs[CY_TCH_E] == CY_EV_TOUCHDOWN))
 				booster_status = true;
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+			if ((tch->abs[CY_TCH_O] != CY_OBJ_HOVER) &&
+				(tch->abs[CY_TCH_E] == CY_EV_TOUCHDOWN)) {
+				if(!md->finger_flag)
+					input_booster_send_event(BOOSTER_DEVICE_TOUCH, BOOSTER_MODE_ON);
+				md->finger_flag = true;
+			}
+#endif
 			if (tch->abs[CY_TCH_E] == CY_EV_LIFTOFF)
 				goto cyttsp5_get_mt_touches_pr_tch;
 
diff --git a/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_regs.h b/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_regs.h
index 65d4a80b17fc..3b57e3202565 100755
--- a/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_regs.h
+++ b/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_regs.h
@@ -48,6 +48,10 @@
 #include <linux/workqueue.h>
 #include <linux/cyttsp5_core.h>
 
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
+
 #define TTHE_TUNER_SUPPORT				1
 #define RTD_TUNER_SUPPORT				1
 #define SAMSUNG_FACTORY_TEST				1
@@ -741,6 +745,10 @@ struct cyttsp5_mt_data {
 		unsigned char boost_level;
 		int dvfs_freq;
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+		u8 finger_flag;
+#endif
+
 	bool input_device_registered;
 	char phys[NAME_MAX];
 	int num_prv_tch;
diff --git a/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_samsung_factory.c b/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_samsung_factory.c
index 691867cf1d31..b96018b78013 100755
--- a/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_samsung_factory.c
+++ b/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_samsung_factory.c
@@ -90,6 +90,9 @@ static void report_rate(void *device_data);
 static void glove_mode(void *device_data);
 static void clear_cover_mode(void *device_data);
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data);
+#endif
 static void not_support_cmd(void *device_data);
 
 /************************************************************************
@@ -124,6 +127,9 @@ struct factory_cmd factory_cmds[] = {
 	{FACTORY_CMD("glove_mode", glove_mode),},
 	{FACTORY_CMD("clear_cover_mode", clear_cover_mode),},
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	{FACTORY_CMD("boost_level", boost_level),},
+#endif
 	{FACTORY_CMD("not_support_cmd", not_support_cmd),},
 };
 
@@ -1326,6 +1332,27 @@ static void not_support_cmd(void *device_data)
 	return;
 }
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data)
+{
+	struct cyttsp5_samsung_factory_data *sfd =
+		(struct cyttsp5_samsung_factory_data *) device_data;
+	int level;
+	char strbuff[FACTORY_CMD_RESULT_STR_LEN];
+	set_default_result(sfd);
+
+	level = sfd->factory_cmd_param[0];
+
+	change_booster_level_for_tsp(level);
+
+	snprintf(strbuff, sizeof(strbuff), "%s", "OK");
+	set_cmd_result(sfd, strbuff, (int)strnlen(strbuff, sizeof(strbuff)));
+	sfd->factory_cmd_state = FACTORYCMD_OK;
+	dev_info(sfd->dev, "%s: %s(%d)\n", __func__,
+			strbuff, (int)strnlen(strbuff, sizeof(strbuff)));
+	return;
+}
+#endif
 static ssize_t store_cmd(struct device *dev, struct device_attribute
 		*devattr, const char *buf, size_t count)
 {
diff --git a/drivers/input/touchscreen/imagis_30xxc/ist30xxc.c b/drivers/input/touchscreen/imagis_30xxc/ist30xxc.c
index a330efdfde46..c6bc1134793f 100755
--- a/drivers/input/touchscreen/imagis_30xxc/ist30xxc.c
+++ b/drivers/input/touchscreen/imagis_30xxc/ist30xxc.c
@@ -544,6 +544,12 @@ static void clear_input_data(struct ist30xx_data *data)
 	}
 #endif
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (data->tsp_booster && data->tsp_booster->dvfs_set)
+		data->tsp_booster->dvfs_set(data->tsp_booster, -1);
+	data->touch_pressed_num = 0;
+#endif
+
 	data->t_status = 0;
 }
 
@@ -867,6 +873,11 @@ static irqreturn_t ist30xx_irq_thread(int irq, void *ptr)
 	data->t_status = t_status;
 	report_input_data(data, finger_cnt, key_cnt);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (data->tsp_booster && data->tsp_booster->dvfs_set)
+		data->tsp_booster->dvfs_set(data->tsp_booster, !!data->touch_pressed_num);
+#endif
+
 	if (data->track_enable) {
 		if (intr_debug3_addr >= 0 && intr_debug3_size > 0) {
 			tsp_noti("Intr_debug3 (addr: 0x%08x)\n", intr_debug3_addr);
@@ -1723,6 +1734,15 @@ static int ist30xx_probe(struct i2c_client *client,
 	if (ret < 0)
 		goto err_irq;
 
+#ifdef CONFIG_INPUT_BOOSTER
+	tsp_info("input Booster\n");
+	data->tsp_booster = input_booster_allocate(INPUT_BOOSTER_ID_TSP);
+	if (!data->tsp_booster) {
+		tsp_err("%s booster allocation is failed\n", __func__);
+		goto err_irq;
+	}
+#endif
+
 	ret = ist30xx_init_update_sysfs(data);
 	if (unlikely(ret))
 		goto err_sysfs;
@@ -1814,6 +1834,10 @@ err_sec_sysfs:
 err_sysfs:
 	class_destroy(ist30xx_class);
 	input_unregister_device(input_dev);
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(data->tsp_booster);
+	data->tsp_booster = NULL;
+#endif
 err_irq:
 	tsp_info("ChipID: %x\n", data->chip_id);
 	ist30xx_disable_irq(data);
@@ -1863,6 +1887,10 @@ static int ist30xx_remove(struct i2c_client *client)
 		ist30xx_free_gpio(data);
 
 	input_unregister_device(data->input_dev);
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(data->tsp_booster);
+	data->tsp_booster = NULL;
+#endif
 	kfree(data);
 
 	return 0;
@@ -1890,6 +1918,10 @@ static void ist30xx_shutdown(struct i2c_client *client)
 	ist30xx_internal_suspend(data);
 	clear_input_data(data);
 	mutex_unlock(&ist30xx_mutex);
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(data->tsp_booster);
+	data->tsp_booster = NULL;
+#endif
 }
 
 static struct i2c_device_id ist30xx_idtable[] = {
diff --git a/drivers/input/touchscreen/imagis_30xxc/ist30xxc.h b/drivers/input/touchscreen/imagis_30xxc/ist30xxc.h
index 7dbd7a962b35..afb2ec9a8804 100755
--- a/drivers/input/touchscreen/imagis_30xxc/ist30xxc.h
+++ b/drivers/input/touchscreen/imagis_30xxc/ist30xxc.h
@@ -17,6 +17,9 @@
 #define __IST30XXC_H__
 
 #include <linux/input/tsp_ta_callback.h>
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
 
 /*
  * Support F/W ver : IST30xxC v1.0.0.0
@@ -505,6 +508,9 @@ struct ist30xx_data {
 	bool gesture;
 #endif
 	int touch_pressed_num;
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster *tsp_booster;
+#endif
 	int scan_count;
 	int scan_retry;
 	int max_scan_retry;
diff --git a/drivers/input/touchscreen/imagis_30xxc_cmcs/ist30xxc.c b/drivers/input/touchscreen/imagis_30xxc_cmcs/ist30xxc.c
index 74b85f8ebcac..cb96d5f80c7c 100644
--- a/drivers/input/touchscreen/imagis_30xxc_cmcs/ist30xxc.c
+++ b/drivers/input/touchscreen/imagis_30xxc_cmcs/ist30xxc.c
@@ -563,6 +563,12 @@ static void clear_input_data(struct ist30xx_data *data)
 	}
 #endif
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (data->tsp_booster && data->tsp_booster->dvfs_set)
+		data->tsp_booster->dvfs_set(data->tsp_booster, -1);
+	data->touch_pressed_num = 0;
+#endif
+
 	data->t_status = 0;
 }
 
@@ -971,6 +977,11 @@ static irqreturn_t ist30xx_irq_thread(int irq, void *ptr)
 	data->t_status = t_status;
 	report_input_data(data, finger_cnt, key_cnt);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (data->tsp_booster && data->tsp_booster->dvfs_set)
+		data->tsp_booster->dvfs_set(data->tsp_booster, !!data->touch_pressed_num);
+#endif
+
 	if (data->track_enable) {
 		if (intr_debug3_addr >= 0 && intr_debug3_size > 0) {
 			tsp_noti("Intr_debug3 (addr: 0x%08x)\n", intr_debug3_addr);
@@ -1827,6 +1838,15 @@ static int ist30xx_probe(struct i2c_client *client,
 	if (ret < 0)
 		goto err_irq;
 
+#ifdef CONFIG_INPUT_BOOSTER
+	tsp_info("input Booster\n");
+	data->tsp_booster = input_booster_allocate(INPUT_BOOSTER_ID_TSP);
+	if (!data->tsp_booster) {
+		tsp_err("%s booster allocation is failed\n", __func__);
+		goto err_irq;
+	}
+#endif
+
 	ret = ist30xx_init_update_sysfs(data);
 	if (unlikely(ret))
 		goto err_sysfs;
@@ -1909,6 +1929,10 @@ err_sec_sysfs:
 err_sysfs:
 	class_destroy(ist30xx_class);
 	input_unregister_device(input_dev);
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(data->tsp_booster);
+	data->tsp_booster = NULL;
+#endif
 err_irq:
 	tsp_info("ChipID: %x\n", data->chip_id);
 	ist30xx_disable_irq(data);
@@ -1958,6 +1982,10 @@ static int ist30xx_remove(struct i2c_client *client)
 		ist30xx_free_gpio(data);
 
 	input_unregister_device(data->input_dev);
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(data->tsp_booster);
+	data->tsp_booster = NULL;
+#endif
 	kfree(data);
 
 	return 0;
@@ -1985,6 +2013,10 @@ static void ist30xx_shutdown(struct i2c_client *client)
 	ist30xx_internal_suspend(data);
 	clear_input_data(data);
 	mutex_unlock(&ist30xx_mutex);
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(data->tsp_booster);
+	data->tsp_booster = NULL;
+#endif
 }
 
 static struct i2c_device_id ist30xx_idtable[] = {
diff --git a/drivers/input/touchscreen/imagis_30xxc_cmcs/ist30xxc.h b/drivers/input/touchscreen/imagis_30xxc_cmcs/ist30xxc.h
index c3c00de8ef47..88e965450d0e 100644
--- a/drivers/input/touchscreen/imagis_30xxc_cmcs/ist30xxc.h
+++ b/drivers/input/touchscreen/imagis_30xxc_cmcs/ist30xxc.h
@@ -17,6 +17,9 @@
 #define __IST30XXC_H__
 
 #include <linux/input/tsp_ta_callback.h>
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
 
 /*
  * Support F/W ver : IST30xxC v1.0.0.0
@@ -512,6 +515,9 @@ struct ist30xx_data {
 	bool gesture;
 #endif
 	int touch_pressed_num;
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster *tsp_booster;
+#endif
 	int scan_count;
 	int scan_retry;
 	int max_scan_retry;
diff --git a/drivers/input/touchscreen/melfas_mms400/melfas_mms400.c b/drivers/input/touchscreen/melfas_mms400/melfas_mms400.c
index a5c04cd57440..6b99429a6f16 100755
--- a/drivers/input/touchscreen/melfas_mms400/melfas_mms400.c
+++ b/drivers/input/touchscreen/melfas_mms400/melfas_mms400.c
@@ -234,6 +234,11 @@ int mms_disable(struct mms_ts_info *info)
 
 	mutex_unlock(&info->lock);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_off(info->booster);
+#endif
+
 	dev_err(&info->client->dev, "%s [DONE]\n", __func__);
 	return 0;
 }
@@ -954,6 +959,15 @@ static int mms_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		goto err_input_register_device;
 	}
 
+#ifdef CONFIG_INPUT_BOOSTER
+	info->booster = input_booster_allocate(INPUT_BOOSTER_ID_TSP);
+	if (!info->booster) {
+		dev_err(&client->dev,
+				"%s [ERROR] failed to allocate input booster\n", __func__);
+		goto error_alloc_booster_failed;
+	}
+#endif
+
 	mms_power_control(info, 1);
 
 #if MMS_USE_AUTO_FW_UPDATE
@@ -1063,6 +1077,11 @@ err_test_dev_create:
 	free_irq(info->irq, info);
 err_request_irq:
 error_fw_update:
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->booster);
+	info->booster = NULL;
+error_alloc_booster_failed:
+#endif
 	input_unregister_device(info->input_dev);
 	info->input_dev = NULL;
 err_input_register_device:
diff --git a/drivers/input/touchscreen/melfas_mms400/melfas_mms400.h b/drivers/input/touchscreen/melfas_mms400/melfas_mms400.h
index be580bc42bfc..241a3c175021 100755
--- a/drivers/input/touchscreen/melfas_mms400/melfas_mms400.h
+++ b/drivers/input/touchscreen/melfas_mms400/melfas_mms400.h
@@ -39,6 +39,10 @@
 #include "melfas_mms400_reg.h"
 #include <linux/input/tsp_ta_callback.h>
 
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
+
 #ifdef CONFIG_OF
 #define MMS_USE_DEVICETREE		1
 #else
@@ -208,6 +212,9 @@ struct mms_ts_info {
 	struct tsp_callbacks callbacks;
 #endif
 
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster *booster;
+#endif
 #ifdef CONFIG_TOUCHSCREEN_DUMP_MODE
 	struct delayed_work ghost_check;
 	u8 tsp_dump_lock;
diff --git a/drivers/input/touchscreen/melfas_mms400/melfas_mms400_cmd.c b/drivers/input/touchscreen/melfas_mms400/melfas_mms400_cmd.c
index 4d4235cf9395..c2073e6ed241 100755
--- a/drivers/input/touchscreen/melfas_mms400/melfas_mms400_cmd.c
+++ b/drivers/input/touchscreen/melfas_mms400/melfas_mms400_cmd.c
@@ -772,6 +772,57 @@ EXIT:
 
 
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void cmd_boost_level(void *device_data)
+{
+	struct mms_ts_info *info = (struct mms_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	int stage;
+	char buf[64] = { 0 };
+
+	cmd_clear_result(info);
+
+	stage = 1 << info->cmd_param[0];
+
+	dev_err(&client->dev, "%s,%d(%x)\n", __func__, info->cmd_param[0], stage);
+
+	if (!(info->booster)) {
+		sprintf(buf, "%s", "NG");
+		info->cmd_state = CMD_STATUS_FAIL;
+		dev_err(&info->client->dev," %s, booster is null \n", __func__);
+		goto out;
+	}
+
+	if (!(info->booster->dvfs_stage & stage)) {
+		sprintf(buf, "%s", "NG");
+		info->cmd_state = CMD_STATUS_FAIL;
+		dev_err(&info->client->dev,
+				"%s: %d is not in supported stage[%x].\n",
+				__func__, info->cmd_param[0], info->booster->dvfs_stage);
+		goto out;
+	}
+
+	info->booster->dvfs_boost_mode = stage;
+	input_booster_set_level_change(info->cmd_param[0]);
+	sprintf(buf, "%s", "OK");
+	info->cmd_state = CMD_STATUS_OK;
+
+	if (info->booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		if (info->booster->dvfs_set)
+			info->booster->dvfs_set(info->booster, -1);
+	}
+
+out:
+	cmd_set_result(info, buf, strnlen(buf, sizeof(buf)));
+
+	mutex_lock(&info->lock);
+	info->cmd_busy = false;
+	mutex_unlock(&info->lock);
+
+	info->cmd_state = CMD_STATUS_WAITING;
+}
+#endif
+
 static void get_intensity_all_data(void *device_data)
 {
 	struct mms_ts_info *info = (struct mms_ts_info *)device_data;
@@ -1000,6 +1051,9 @@ static struct mms_cmd mms_commands[] = {
 	{MMS_CMD("get_cm_abs", cmd_get_cm_abs),},
 	{MMS_CMD("get_config_ver", cmd_get_config_ver),},
 	{MMS_CMD("get_threshold", cmd_get_threshold),},
+#ifdef CONFIG_INPUT_BOOSTER
+	{MMS_CMD("boost_level", cmd_boost_level),},
+#endif
 	{MMS_CMD("get_intensity_all_data", get_intensity_all_data),},
 	{MMS_CMD("get_rawdata_all_data", get_rawdata_all_data),},
 	{MMS_CMD("get_cm_delta_all_data", get_cm_delta_all_data),},
diff --git a/drivers/input/touchscreen/melfas_mms400/melfas_mms400_mod.c b/drivers/input/touchscreen/melfas_mms400/melfas_mms400_mod.c
index 16de4df5dea0..aa1b089720fa 100755
--- a/drivers/input/touchscreen/melfas_mms400/melfas_mms400_mod.c
+++ b/drivers/input/touchscreen/melfas_mms400/melfas_mms400_mod.c
@@ -83,6 +83,10 @@ void mms_clear_input(struct mms_ts_info *info)
 
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, -1);
+#endif
 }
 
 /**
@@ -221,6 +225,12 @@ void mms_input_event_handler(struct mms_ts_info *info, u8 sz, u8 *buf)
 		}
 	}
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, info->touch_count);
+#endif
+
+
 	dev_dbg(&client->dev, "%s [DONE]\n", __func__);
 	return;
 }
diff --git a/drivers/input/touchscreen/mms300.c b/drivers/input/touchscreen/mms300.c
index 8896af78fd66..4776b26dc622 100644
--- a/drivers/input/touchscreen/mms300.c
+++ b/drivers/input/touchscreen/mms300.c
@@ -57,6 +57,9 @@
 
 #include <asm/unaligned.h>
 
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
 #define TSP_GLOVE_MODE
 #define TSP_SVIEW_COVER_MODE
 #define COVER_OPEN 0
@@ -395,6 +398,11 @@ struct mms_ts_info {
 	void (*input_event)(void *data);
 	const char* fw_path;
 
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster	*booster;
+#endif
+
+
 #ifdef TSP_GESTURE_MODE
 	bool lowpower_mode;
 	int lowpower_flag;
@@ -551,6 +559,10 @@ static void direct_indicator_enable(void *device_data);
 static void set_lowpower_mode(void *device_data);
 #endif
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data);
+#endif
+
 #ifdef TSP_GLOVE_MODE
 static void glove_mode(void *device_data);
 #endif
@@ -591,6 +603,9 @@ struct tsp_cmd tsp_cmds[] = {
 	{TSP_CMD("set_lowpower_mode", set_lowpower_mode),},
 #endif
 	{TSP_CMD("not_support_cmd", not_support_cmd),},
+#ifdef CONFIG_INPUT_BOOSTER
+        {TSP_CMD("boost_level", boost_level),},
+#endif
 #ifdef TSP_GLOVE_MODE
 	 {TSP_CMD("glove_mode", glove_mode),},
 #endif
@@ -638,6 +653,10 @@ static void release_all_fingers(struct mms_ts_info *info)
 	}
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, 0);
+#endif
 }
 
 static void mms_set_noise_mode(struct mms_ts_info *info)
@@ -1111,6 +1130,11 @@ static irqreturn_t mms_ts_interrupt(int irq, void *dev_id)
 	}
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, touch_is_pressed);
+#endif
+
 out:
 	mutex_unlock(&info->lock);
 	return IRQ_HANDLED;
@@ -1917,6 +1941,53 @@ static void clear_cover_mode(void *device_data)
 }
 #endif
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data)
+{
+	struct mms_ts_info *info = (struct mms_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	char buff[16] = {0};
+	int stage;
+
+	dev_info(&client->dev, "%s\n", __func__);
+
+	set_default_result(info);
+
+
+	stage = 1 << info->cmd_param[0];
+	if (!(info->booster->dvfs_stage & stage)) {
+		snprintf(buff, sizeof(buff), "NG");
+		info->cmd_state = FAIL;
+		dev_err(&info->client->dev,"%s: %d is not supported(%04x != %04x).\n",__func__,
+			info->cmd_param[0], stage, info->booster->dvfs_stage);
+
+		goto boost_out;
+	}
+
+	info->booster->dvfs_boost_mode = stage;
+	snprintf(buff, sizeof(buff), "OK");
+	info->cmd_state = OK;
+
+	if (info->booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		if (info->booster && info->booster->dvfs_set)
+			info->booster->dvfs_set(info->booster, -1);
+	}
+
+	boost_out:
+
+	set_cmd_result(info, buff,
+			strnlen(buff, sizeof(buff)));
+
+	mutex_lock(&info->cmd_lock);
+	info->cmd_is_running = false;
+	mutex_unlock(&info->cmd_lock);
+
+	info->cmd_state = WAITING;
+
+	return;
+}
+#endif
+
 #ifdef MMS300_DOWNLOAD
 static int get_fw_ver(struct i2c_client *client, u8 *buf)
 {
@@ -5306,6 +5377,12 @@ static void mms_ts_input_close(struct input_dev *dev)
 	// mms_pinctrl_configure(info, false, false);
 	}
 
+#ifdef CONFIG_INPUT_BOOSTER
+	dev_info(&info->client->dev, "%s force dvfs off\n", __func__);
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, -1);
+#endif
+
 	return;
 //TEST
 //	mms_ts_suspend(&info->client->dev);
@@ -5559,6 +5636,13 @@ static int mms_ts_probe(struct i2c_client *client,
 		goto err_reg_input_dev;
 	}
 
+#ifdef CONFIG_INPUT_BOOSTER
+	info->booster = input_booster_allocate(INPUT_BOOSTER_ID_TSP);
+	if (!info->booster) {
+		dev_err(&client->dev, "%s: Error, failed to allocate input booster\n",__func__);
+		goto error_alloc_booster_failed;
+	}
+#endif
 	info->enabled = true;
 
 	client->irq = gpio_to_irq(pdata->gpio_int);
@@ -5688,6 +5772,12 @@ static int mms_ts_probe(struct i2c_client *client,
 err_req_irq:
 	input_unregister_device(input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->booster);
+	info->booster = NULL;
+error_alloc_booster_failed:
+#endif
+
 err_reg_input_dev:
 	info->power(info,0);
 #ifdef TOUCHKEY
diff --git a/drivers/input/touchscreen/mxt1188s/mxts_1188s.c b/drivers/input/touchscreen/mxt1188s/mxts_1188s.c
index a7a3bce81d72..818c9166faf5 100644
--- a/drivers/input/touchscreen/mxt1188s/mxts_1188s.c
+++ b/drivers/input/touchscreen/mxt1188s/mxts_1188s.c
@@ -997,6 +997,17 @@ static void mxt_report_input_data(struct mxt_data *data)
 			input_sync(data->input_dev);
 	}
 
+#ifdef CONFIG_INPUT_BOOSTER
+		if (count){
+			if (data->tsp_booster && data->tsp_booster->dvfs_set)
+				data->tsp_booster->dvfs_set(data->tsp_booster,count);
+		}
+		else{
+			if (data->tsp_booster && data->tsp_booster->dvfs_set)
+				data->tsp_booster->dvfs_set(data->tsp_booster,0);
+		}
+#endif
+
 	data->finger_mask = 0;
 }
 
@@ -2223,6 +2234,11 @@ static int mxt_stop(struct mxt_data *data)
 #if ENABLE_TOUCH_KEY
 	mxt_release_all_keys(data);
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+if (data->tsp_booster && data->tsp_booster->dvfs_set)
+	data->tsp_booster->dvfs_set(data->tsp_booster, -1);
+#endif
+
 	data->mxt_enabled = false;
 
 	return 0;
@@ -2881,6 +2897,15 @@ static int  mxt_probe(struct i2c_client *client,
 	data->mxt_enabled = true;
 */
 
+#ifdef CONFIG_INPUT_BOOSTER
+	printk("TSP COMMON_INPUT_BOOSTER init\n");
+	data->tsp_booster =   input_booster_allocate(INPUT_BOOSTER_ID_TSP);
+	if (!data->tsp_booster) {
+		dev_err(&client->dev, "%s: Error, failed to allocate input booster\n",__func__);
+		goto err_get_tsp_booster;
+	}
+#endif
+
 	error = mxt_touch_init(data, MXT_FIRMWARE_UPDATE_TYPE);
 	if (error) {
 		dev_err(&client->dev, "Failed to init driver\n");
@@ -2922,6 +2947,11 @@ err_touch_init:
 /*
 err_power_on:
 */
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(data->tsp_booster);
+	data->tsp_booster = NULL;
+err_get_tsp_booster:
+#endif
 	mxt_sysfs_remove(data);
 err_sysfs_init:
 	input_unregister_device(input_dev);
diff --git a/drivers/input/touchscreen/mxt1188s/mxts_sec_1188s.c b/drivers/input/touchscreen/mxt1188s/mxts_sec_1188s.c
index e551435f0a8d..0686bacacb32 100644
--- a/drivers/input/touchscreen/mxt1188s/mxts_sec_1188s.c
+++ b/drivers/input/touchscreen/mxt1188s/mxts_sec_1188s.c
@@ -1560,6 +1560,59 @@ struct tsp_cmd {
 	void			(*cmd_func)(void *device_data);
 };
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data)
+{
+	struct mxt_data *data = (struct mxt_data *)device_data;
+	struct i2c_client *client = data->client;
+	struct mxt_fac_data *fdata = data->fdata;
+	char buff[16] = {0};
+
+	int stage;
+	dev_info(&client->dev, "%s\n", __func__);
+
+	set_default_result(fdata);
+
+	stage = 1 << fdata->cmd_param[0];
+
+	if(!(data->tsp_booster)){
+		sprintf(buff, "%s", "NG");
+		fdata->cmd_state = CMD_STATUS_FAIL;
+		dev_err(&data->client->dev," %s, booster is null \n", __func__);
+		goto out;
+	}
+	if (!(data->tsp_booster->dvfs_stage & data->tsp_booster->dvfs_boost_mode)) {
+		sprintf(buff, "%s", "NG");
+		fdata->cmd_state = CMD_STATUS_FAIL;
+		dev_err(&data->client->dev,
+			"%s: %d is not in supported stage[%x].\n",
+			__func__, fdata->cmd_param[0], data->tsp_booster->dvfs_stage);
+		goto out;
+	}
+	data->tsp_booster->dvfs_boost_mode = stage;
+	dev_info(&client->dev, "%s: dvfs_boost_mode = %d(%x)\n",
+			__func__, data->tsp_booster->dvfs_boost_mode,stage);
+	input_booster_set_level_change(fdata->cmd_param[0]);
+	snprintf(buff, sizeof(buff), "OK");
+	fdata->cmd_state = CMD_STATUS_OK;
+
+	if (data->tsp_booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		if (data->tsp_booster->dvfs_set)
+			data->tsp_booster->dvfs_set(data->tsp_booster, -1);	
+	}
+out:
+	set_cmd_result(fdata, buff, strnlen(buff, sizeof(buff)));
+
+	mutex_lock(&fdata->cmd_lock);
+	fdata->cmd_is_running = false;
+	mutex_unlock(&fdata->cmd_lock);
+
+	fdata->cmd_state = CMD_STATUS_WAITING;
+
+	return;
+}
+#endif
+
 static struct tsp_cmd tsp_cmds[] = {
 	{TSP_CMD("fw_update", fw_update),},
 	{TSP_CMD("get_fw_ver_bin", get_fw_ver_bin),},
@@ -1589,6 +1642,9 @@ static struct tsp_cmd tsp_cmds[] = {
 	{TSP_CMD("set_tk_threshold", set_tk_threshold),},
 #endif
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	{TSP_CMD("boost_level", boost_level),},
+#endif
 #if TSP_PATCH
 	{TSP_CMD("patch_update", patch_update),},
 #endif
diff --git a/drivers/input/touchscreen/mxt_t/mxtt.c b/drivers/input/touchscreen/mxt_t/mxtt.c
index ebba48fa4cf1..ff70439aed68 100644
--- a/drivers/input/touchscreen/mxt_t/mxtt.c
+++ b/drivers/input/touchscreen/mxt_t/mxtt.c
@@ -776,6 +776,15 @@ static void mxt_report_input_data(struct mxt_data *data)
 #endif
 			input_sync(data->input_dev);
 	}
+#ifdef COMMON_INPUT_BOOSTER
+		if (count){
+			data->tsp_booster->dvfs_set(data->tsp_booster,count);
+		}
+		else{
+			data->tsp_booster->dvfs_set(data->tsp_booster, -1);
+		}
+#endif
+
 
 	data->finger_mask = 0;
 }
@@ -2240,6 +2249,10 @@ static int mxt_stop(struct mxt_data *data)
 #if ENABLE_TOUCH_KEY
 	mxt_release_all_keys(data);
 #endif
+#ifdef COMMON_INPUT_BOOSTER
+	if(data->tsp_booster)
+		data->tsp_booster->dvfs_set(data->tsp_booster, -1);
+#endif
 	return 0;
 
 err_power_off:
@@ -3095,6 +3108,23 @@ static int  mxt_probe(struct i2c_client *client,
 	else
 		printk("TSP interrupt registered successfully\n");
 
+#ifdef COMMON_INPUT_BOOSTER
+	printk("TSP COMMON_INPUT_BOOSTER init\n");
+
+	data->touch_pressed_num = 0;
+	data->tsp_booster = kzalloc(sizeof(struct input_booster), GFP_KERNEL);
+	if (!data->tsp_booster) {
+		dev_err(&client->dev,
+			"%s: Failed to alloc mem for tsp_booster\n", __func__);
+		error = -ENOMEM;
+		goto err_get_tsp_booster;
+	} else {
+		input_booster_init_dvfs(data->tsp_booster, INPUT_BOOSTER_ID_TSP);
+	}
+#endif
+
+
+
 #ifdef CONFIG_HAS_EARLYSUSPEND
 	data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
 	data->early_suspend.suspend = mxt_early_suspend;
@@ -3104,6 +3134,10 @@ static int  mxt_probe(struct i2c_client *client,
 
 	return 0;
 	
+#ifdef COMMON_INPUT_BOOSTER
+	kfree(data->tsp_booster);
+err_get_tsp_booster:
+#endif
 	free_irq(client->irq,data);
 err_req_irq:
 err_touch_init:
diff --git a/drivers/input/touchscreen/mxt_t/mxtt_sec.c b/drivers/input/touchscreen/mxt_t/mxtt_sec.c
index 63348ae65289..0aa8ae6a9fa9 100644
--- a/drivers/input/touchscreen/mxt_t/mxtt_sec.c
+++ b/drivers/input/touchscreen/mxt_t/mxtt_sec.c
@@ -1565,6 +1565,33 @@ static void set_tk_threshold(void *device_data)
 #endif
 #endif
 
+#if defined(COMMON_INPUT_BOOSTER)
+static void boost_level(void *device_data)
+{
+	struct mxt_data *data = (struct mxt_data *)device_data;
+	struct i2c_client *client = data->client;
+	struct mxt_fac_data *fdata = data->fdata;
+	char buff[16] = {0};
+	set_default_result(fdata);
+
+	if (fdata->cmd_param[0] < 0 && fdata->cmd_param[0]!= DVFS_STAGE_NONE && fdata->cmd_param[0]!= DVFS_STAGE_SINGLE &&
+		fdata->cmd_param[0]!= DVFS_STAGE_DUAL && fdata->cmd_param[0]&& DVFS_STAGE_TRIPLE && fdata->cmd_param[0]!= DVFS_STAGE_PENTA &&
+		fdata->cmd_param[0]!= DVFS_STAGE_NINTH) {
+		snprintf(buff, sizeof(buff), "%s", "NG");
+		fdata->cmd_state = CMD_STATUS_FAIL;
+	} else {
+		data->tsp_booster->dvfs_boost_mode= fdata->cmd_param[0];
+		tsp_debug_dbg(false, &client->dev, "%s %d\n", __func__, fdata->cmd_param[0]);
+		snprintf(buff, sizeof(buff), "%s", "OK");
+		fdata->cmd_state = CMD_STATUS_OK;
+	}
+
+	tsp_debug_info(true, &client->dev, "%s: %s(%d)\n",
+		__func__, buff, strnlen(buff, sizeof(buff)));
+
+	return;
+}
+#endif
 /* - function realted samsung factory test */
 
 #define TSP_CMD(name, func) .cmd_name = name, .cmd_func = func
@@ -1607,6 +1634,9 @@ static struct tsp_cmd tsp_cmds[] = {
 #if TSP_PATCH
 	{TSP_CMD("patch_update", patch_update),},
 #endif
+#if defined(COMMON_INPUT_BOOSTER)
+	{TSP_CMD("boost_level", boost_level),},
+#endif
 	{TSP_CMD("get_checksum_data", get_checksum_data),},
 
 	{TSP_CMD("not_support_cmd", not_support_cmd),},
diff --git a/drivers/input/touchscreen/sec_ts/sec_ts.h b/drivers/input/touchscreen/sec_ts/sec_ts.h
index 39dd81f8d1ed..bbff70ad93e8 100644
--- a/drivers/input/touchscreen/sec_ts/sec_ts.h
+++ b/drivers/input/touchscreen/sec_ts/sec_ts.h
@@ -16,6 +16,9 @@
 #ifdef CONFIG_SEC_DEBUG_TSP_LOG
 #include <linux/sec_debug.h>
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
 #include <linux/completion.h>
 #include <linux/wakelock.h>
 #include <linux/input/sec_cmd.h>
diff --git a/drivers/input/touchscreen/zinitix_bt532/zinitix_bt532_ts.c b/drivers/input/touchscreen/zinitix_bt532/zinitix_bt532_ts.c
index f81c71aa277b..bea6d47d3b4d 100755
--- a/drivers/input/touchscreen/zinitix_bt532/zinitix_bt532_ts.c
+++ b/drivers/input/touchscreen/zinitix_bt532/zinitix_bt532_ts.c
@@ -46,6 +46,10 @@
 #include <linux/of_device.h>
 #include <linux/of_gpio.h>
 
+#ifdef CONFIG_COMMON_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
+
 #include <linux/of_irq.h>
 #include <asm/io.h>
 #include <linux/power_supply.h>
@@ -377,6 +381,9 @@ static void get_delta(void *device_data);
 static void clear_cover_mode(void *device_data);
 static void get_module_vendor(void *device_data);
 static void get_config_ver(void *device_data);
+#if defined(COMMON_INPUT_BOOSTER)
+static void boost_level(void *device_data);
+#endif
 #if defined(USE_ACTIVE_REPORT_RATE)
 static void report_rate(void *device_data);
 #endif
@@ -421,6 +428,9 @@ static struct tsp_cmd tsp_cmds[] = {
 	{TSP_CMD("get_delta", get_delta),},
 	{TSP_CMD("get_config_ver", get_config_ver),},
 	{TSP_CMD("clear_cover_mode", clear_cover_mode),},
+#if defined(COMMON_INPUT_BOOSTER)
+	{TSP_CMD("boost_level", boost_level),},
+#endif
 #if defined(USE_ACTIVE_REPORT_RATE)
 	{TSP_CMD("report_rate", report_rate),},
 #endif
@@ -634,6 +644,9 @@ struct bt532_ts_info {
 	void (*register_cb)(struct tsp_callbacks *);
 	struct tsp_callbacks callbacks;
 #endif
+#ifdef COMMON_INPUT_BOOSTER
+	struct input_booster *tsp_booster;
+#endif
 };
 /* Dummy touchkey code */
 #define KEY_DUMMY_HOME1		249
@@ -2290,6 +2303,35 @@ static inline void set_cmd_result(struct bt532_ts_info *info, char *buff, int le
 static inline void set_default_result(struct bt532_ts_info *info);
 #endif
 
+#if defined(COMMON_INPUT_BOOSTER)
+static void boost_level(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+
+	char buff[16] = {0};
+	set_default_result(info);
+
+	if (finfo->cmd_param[0] < 0 && finfo->cmd_param[0]!= DVFS_STAGE_NONE && finfo->cmd_param[0]!= DVFS_STAGE_SINGLE &&
+		finfo->cmd_param[0]!= DVFS_STAGE_DUAL && finfo->cmd_param[0]&& DVFS_STAGE_TRIPLE && finfo->cmd_param[0]!= DVFS_STAGE_PENTA &&
+		finfo->cmd_param[0]!= DVFS_STAGE_NINTH) {
+		snprintf(buff, sizeof(buff), "%s", "NG");
+		finfo->cmd_state = FAIL;
+	} else {
+		info->tsp_booster->dvfs_boost_mode= finfo->cmd_param[0];
+		dev_info(&client->dev, "%s %d\n", __func__, finfo->cmd_param[0]);
+		snprintf(buff, sizeof(buff), "%s", "OK");
+		finfo->cmd_state = OK;
+	}
+
+	dev_info(&client->dev, "%s: %s(%d)\n",
+		__func__, buff, strnlen(buff, sizeof(buff)));
+
+	return;
+}
+#endif
+
 static void clear_report_data(struct bt532_ts_info *info)
 {
 	int i;
@@ -2327,6 +2369,9 @@ static void clear_report_data(struct bt532_ts_info *info)
 		input_sync(info->input_dev);
 
 	info->finger_cnt1=0;
+#ifdef COMMON_INPUT_BOOSTER
+	info->tsp_booster->dvfs_set(info->tsp_booster,-1);
+#endif
 }
 #if 0
 static bool bt532_touch_key_force_release(struct bt532_ts_info *info)
@@ -2594,6 +2639,13 @@ static irqreturn_t bt532_touch_work(int irq, void *data)
 	input_sync(info->input_dev);
 
 out:
+#ifdef COMMON_INPUT_BOOSTER
+	if (info->finger_cnt1){
+		info->tsp_booster->dvfs_set(info->tsp_booster, info->finger_cnt1);
+	} else {
+		info->tsp_booster->dvfs_set(info->tsp_booster, -1);
+	}
+#endif
 
 	if (info->work_state == NORMAL) {
 #if ESD_TIMER_INTERVAL
@@ -5983,6 +6035,17 @@ static int bt532_ts_probe(struct i2c_client *client,
 	}
 #endif
 
+#ifdef COMMON_INPUT_BOOSTER
+	printk("TSP COMMON_INPUT_BOOSTER init\n");
+	info->tsp_booster = kzalloc(sizeof(struct input_booster), GFP_KERNEL);
+	if (!info->tsp_booster) {
+		dev_err(&client->dev,
+			"%s: Failed to alloc mem for tsp_booster\n", __func__);
+		goto err_get_tsp_booster;
+	} else {
+		input_booster_init_dvfs(info->tsp_booster, INPUT_BOOSTER_ID_TSP);
+	}
+#endif
 	/* configure irq */
 	info->irq = gpio_to_irq(pdata->gpio_int);
 	if (info->irq < 0){
@@ -6043,6 +6106,10 @@ err_kthread_create_failed:
 err_misc_register:
 	free_irq(info->irq, info);
 err_irq_of_parse:
+#ifdef COMMON_INPUT_BOOSTER
+	kfree(info->tsp_booster);
+err_get_tsp_booster:
+#endif
 err_request_irq:
 	input_unregister_device(info->input_dev);
 err_input_register_device:
diff --git a/drivers/input/touchscreen/zinitix_j1/bt432.c b/drivers/input/touchscreen/zinitix_j1/bt432.c
index ef38b5055d11..6d43bdaec12c 100755
--- a/drivers/input/touchscreen/zinitix_j1/bt432.c
+++ b/drivers/input/touchscreen/zinitix_j1/bt432.c
@@ -80,6 +80,10 @@ struct cpufreq_limit_handle *min_handle = NULL;
 static const unsigned long touch_cpufreq_lock = 1200000;
 #endif
 
+#ifdef CONFIG_COMMON_INPUT_BOOSTER
+//to enabled common touch booster. This must be included.
+#include <linux/input/input_booster.h>
+#endif
 #ifdef SUPPORTED_PALM_TOUCH
 #define TOUCH_POINT_MODE			2
 #else
@@ -679,6 +683,10 @@ struct bt432_ts_info {
 #if TOUCH_BOOSTER
 	u8							finger_cnt;
 #endif
+#ifdef COMMON_INPUT_BOOSTER	
+	u8 touch_pressed_num;
+	struct input_booster *tsp_booster;
+#endif
 };
 /* Dummy touchkey code */
 #define KEY_DUMMY_HOME1	249
@@ -2588,6 +2596,9 @@ static irqreturn_t bt432_touch_work(int irq, void *data)
 				}
 				info->finger_cnt++;
 #endif
+#ifdef COMMON_INPUT_BOOSTER		
+			info->touch_pressed_num++;			
+#endif 
 #if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
 				dev_info(&client->dev, "Finger [%02d] x = %d, y = %d,"
 								" w = %d\n", i, x, y, w);
@@ -2649,6 +2660,9 @@ static irqreturn_t bt432_touch_work(int irq, void *data)
 				dev_info(&client->dev, "cpu freq off\n");
 			}
 #endif
+#ifdef COMMON_INPUT_BOOSTER		
+			info->touch_pressed_num--;				
+#endif 
 #if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
 			dev_info(&client->dev, "Finger [%02d] up\n", i);
 #else
@@ -2666,6 +2680,14 @@ static irqreturn_t bt432_touch_work(int irq, void *data)
 	memcpy((char *)&info->reported_touch_info, (char *)&info->touch_info,
 			sizeof(struct point_info));
 	input_sync(info->input_dev);
+#ifdef COMMON_INPUT_BOOSTER	
+	if (info->touch_pressed_num){
+		info->tsp_booster->dvfs_set(info->tsp_booster,info->touch_pressed_num);
+		} else {
+		info->tsp_booster->dvfs_set(info->tsp_booster,-1);		
+	}
+	
+#endif
 out:
 	if (info->work_state == NORMAL) {
 #if ESD_TIMER_INTERVAL
@@ -2861,6 +2883,10 @@ static void bt432_ts_close(struct input_dev *dev)
 	info->work_state = EALRY_SUSPEND;
 
 	clear_report_data(info);
+#ifdef COMMON_INPUT_BOOSTER	
+	info->tsp_booster->dvfs_set(info->tsp_booster,-1);
+	info->touch_pressed_num = 0;
+#endif
 
 #if ESD_TIMER_INTERVAL
 	/*write_reg(info->client, BT432_PERIODICAL_INTERRUPT_INTERVAL, 0);*/
@@ -6185,6 +6211,18 @@ static int bt432_ts_probe(struct i2c_client *client,
 #if TOUCH_BOOSTER
 	info->finger_cnt = 0;
 #endif
+#ifdef COMMON_INPUT_BOOSTER
+	printk("TSP COMMON_INPUT_BOOSTER init\n");
+	info->touch_pressed_num = 0;
+	info->tsp_booster = kzalloc(sizeof(struct input_booster), GFP_KERNEL);
+	if (!info->tsp_booster) {
+		dev_err(&client->dev,
+			"%s: Failed to alloc mem for tsp_booster\n", __func__);
+		goto err_get_tsp_booster;
+	} else {
+		input_booster_init_dvfs(info->tsp_booster, INPUT_BOOSTER_ID_TSP);
+	}
+#endif
 	sema_init(&info->work_lock, 1);
 
 #if ESD_TIMER_INTERVAL
@@ -6263,6 +6301,10 @@ err_request_irq:
 #if ESD_TIMER_INTERVAL
 err_esd_input_unregister_device:
 #endif
+#ifdef COMMON_INPUT_BOOSTER
+err_get_tsp_booster:
+   kfree(info->tsp_booster);
+#endif
 err_input_unregister_device:
 	input_unregister_device(info->input_dev);
 err_input_register_device:
diff --git a/drivers/input/touchscreen/zinitix_zt7538/zt7538.c b/drivers/input/touchscreen/zinitix_zt7538/zt7538.c
index 24c47127bf0e..99cae7a42c7d 100644
--- a/drivers/input/touchscreen/zinitix_zt7538/zt7538.c
+++ b/drivers/input/touchscreen/zinitix_zt7538/zt7538.c
@@ -1484,6 +1484,10 @@ static void clear_report_data(struct zt7538_ts_info *info)
 	input_mt_slot(info->input_dev, 0);
 	input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 0);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, -1);
+#endif
 }
 
 static irqreturn_t zt7538_touch_work(int irq, void *data)
@@ -1693,6 +1697,10 @@ out:
 		dev_info(&client->dev, "debug_register = [0x%04x]\n", m_debug_register);
 	}
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, info->finger_cnt > 0 ? 1 : 0);
+#endif
 
 	if (info->work_state == NORMAL) {
 #if ESD_TIMER_INTERVAL
@@ -2020,6 +2028,10 @@ static int ts_upgrade_sequence(const u8 *firmware_data)
 #ifdef SEC_FACTORY_TEST
 #define TSP_CMD(name, func) .cmd_name = name, .cmd_func = func
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data);
+#endif
+
 static struct tsp_cmd tsp_cmds[] = {
 	{TSP_CMD("fw_update", fw_update),},
 	{TSP_CMD("get_fw_ver_bin", get_fw_ver_bin),},
@@ -2053,6 +2065,9 @@ static struct tsp_cmd tsp_cmds[] = {
 	{TSP_CMD("clear_cover_mode", clear_cover_mode),},
 	{TSP_CMD("clear_reference_data", clear_reference_data),},
 	{TSP_CMD("run_ref_calibration", run_ref_calibration),},
+#ifdef CONFIG_INPUT_BOOSTER
+	{TSP_CMD("boost_level", boost_level),},
+#endif
 	{TSP_CMD("hfdnd_spec_adjust", hfdnd_spec_adjust),},
 };
 
@@ -2069,6 +2084,52 @@ static inline void set_default_result(struct tsp_factory_info *finfo)
 	strncat(finfo->cmd_result, &delim, 1);
 }
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data)
+{
+	struct zt7538_ts_info *info = (struct zt7538_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+	int stage;
+
+	dev_info(&client->dev, "%s\n", __func__);
+
+	set_default_result(finfo);
+
+	stage = 1 << finfo->cmd_param[0];
+	if (!(info->booster->dvfs_stage & stage)) {
+		snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "NG");
+		finfo->cmd_state = FAIL;
+		dev_err(&info->client->dev,"%s: %d is not supported(%04x != %04x).\n",__func__,
+			finfo->cmd_param[0], stage, info->booster->dvfs_stage);
+
+		goto boost_out;
+	}
+
+	info->booster->dvfs_boost_mode = stage;
+	input_booster_set_level_change(finfo->cmd_param[0]);
+	snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "OK");
+	finfo->cmd_state = OK;
+
+	if (info->booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		if (info->booster && info->booster->dvfs_set)
+			info->booster->dvfs_set(info->booster, -1);
+	}
+
+boost_out:
+	set_cmd_result(finfo, finfo->cmd_buff,
+			strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+
+	mutex_lock(&finfo->cmd_lock);
+	finfo->cmd_is_running = false;
+	mutex_unlock(&finfo->cmd_lock);
+
+	finfo->cmd_state = WAITING;
+
+	return;
+}
+#endif
+
 static void fw_update(void *device_data)
 {
 	struct zt7538_ts_info *info = (struct zt7538_ts_info *)device_data;
@@ -4542,6 +4603,15 @@ static int zt7538_ts_probe(struct i2c_client *client, const struct i2c_device_id
 	esd_timer_start(CHECK_ESD_TIMER, info);
 #endif
 
+#ifdef CONFIG_INPUT_BOOSTER
+	info->booster = input_booster_allocate(INPUT_BOOSTER_ID_TSP);
+	if (!info->booster) {
+		dev_err(&client->dev, "%s: Error, failed to allocate input booster\n",__func__);
+		ret = -ENODEV;
+		goto error_alloc_booster_failed;
+	}
+#endif
+
 	info->irq = gpio_to_irq(pdata->gpio_int);
 	if (info->irq < 0) {
 		dev_err(&client->dev, "failed to get gpio_to_irq\n");
@@ -4601,6 +4671,11 @@ err_misc_register:
 	free_irq(info->irq, info);
 err_request_irq:
 err_gpio_irq:
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->booster);
+	info->booster = NULL;
+error_alloc_booster_failed:
+#endif
 #if ESD_TIMER_INTERVAL
 err_esd_input_unregister_device:
 #endif
diff --git a/drivers/input/touchscreen/zinitix_zt7538/zt7538.h b/drivers/input/touchscreen/zinitix_zt7538/zt7538.h
index 5b7c9bc40d87..0b12e3d6bc04 100644
--- a/drivers/input/touchscreen/zinitix_zt7538/zt7538.h
+++ b/drivers/input/touchscreen/zinitix_zt7538/zt7538.h
@@ -45,6 +45,10 @@
 #include <linux/muic/muic.h>
 #include <linux/muic/muic_notifier.h>
 
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
+
 #define ZT7548_IC_CHIP_CODE	0xE548
 #define ZT7538_IC_CHIP_CODE	0xE538
 
@@ -486,6 +490,9 @@ struct zt7538_ts_info {
 	s16					ref_scale_factor;
 	s16					ref_btn_option;
 	struct pinctrl				*pinctrl;
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster			*booster;
+#endif
 #ifdef SUPPORTED_KEY_LED
 	struct regulator			*led_ldo;
 #endif
diff --git a/drivers/input/touchscreen/zt7548_ts.c b/drivers/input/touchscreen/zt7548_ts.c
index 175f83e62794..72c3d32e3bd5 100755
--- a/drivers/input/touchscreen/zt7548_ts.c
+++ b/drivers/input/touchscreen/zt7548_ts.c
@@ -1591,6 +1591,10 @@ static void clear_report_data(struct zt7548_ts_info *info)
 	input_mt_slot(info->input_dev, 0);
 	input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 0);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, -1);
+#endif
 }
 
 static irqreturn_t zt7548_touch_work(int irq, void *data)
@@ -1824,6 +1828,10 @@ static irqreturn_t zt7548_touch_work(int irq, void *data)
 	input_sync(info->input_dev);
 
 out:
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, info->finger_cnt > 0 ? 1 : 0);
+#endif
 
 	if (info->work_state == NORMAL) {
 #if ESD_TIMER_INTERVAL
@@ -2297,6 +2305,10 @@ static int ts_upgrade_sequence(const u8 *firmware_data)
 #ifdef SEC_FACTORY_TEST
 #define TSP_CMD(name, func) .cmd_name = name, .cmd_func = func
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data);
+#endif
+
 static struct tsp_cmd tsp_cmds[] = {
 	{TSP_CMD("fw_update", fw_update),},
 	{TSP_CMD("get_fw_ver_bin", get_fw_ver_bin),},
@@ -2338,6 +2350,9 @@ static struct tsp_cmd tsp_cmds[] = {
 	{TSP_CMD("get_reference", get_reference),},
 #endif
 	{TSP_CMD("run_ref_calibration", run_ref_calibration),},
+#ifdef CONFIG_INPUT_BOOSTER
+	{TSP_CMD("boost_level", boost_level),},
+#endif
 #if defined(CONFIG_TOUCHSCREEN_ZT7538_TS)
 	{TSP_CMD("hfdnd_spec_adjust", hfdnd_spec_adjust),},
 #endif
@@ -2356,6 +2371,52 @@ static inline void set_default_result(struct tsp_factory_info *finfo)
 	strncat(finfo->cmd_result, &delim, 1);
 }
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data)
+{
+	struct zt7548_ts_info *info = (struct zt7548_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+	int stage;
+
+	dev_info(&client->dev, "%s\n", __func__);
+
+	set_default_result(finfo);
+
+	stage = 1 << finfo->cmd_param[0];
+	if (!(info->booster->dvfs_stage & stage)) {
+		snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "NG");
+		finfo->cmd_state = FAIL;
+		dev_err(&info->client->dev,"%s: %d is not supported(%04x != %04x).\n",__func__,
+			finfo->cmd_param[0], stage, info->booster->dvfs_stage);
+
+		goto boost_out;
+	}
+
+	info->booster->dvfs_boost_mode = stage;
+	input_booster_set_level_change(finfo->cmd_param[0]);
+	snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "OK");
+	finfo->cmd_state = OK;
+
+	if (info->booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		if (info->booster && info->booster->dvfs_set)
+			info->booster->dvfs_set(info->booster, -1);
+	}
+
+boost_out:
+	set_cmd_result(finfo, finfo->cmd_buff,
+			strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+
+	mutex_lock(&finfo->cmd_lock);
+	finfo->cmd_is_running = false;
+	mutex_unlock(&finfo->cmd_lock);
+
+	finfo->cmd_state = WAITING;
+
+	return;
+}
+#endif
+
 static void fw_update(void *device_data)
 {
 	struct zt7548_ts_info *info = (struct zt7548_ts_info *)device_data;
@@ -5191,6 +5252,15 @@ static int zt7548_ts_probe(struct i2c_client *client, const struct i2c_device_id
 	esd_timer_start(CHECK_ESD_TIMER, info);
 #endif
 
+#ifdef CONFIG_INPUT_BOOSTER
+	info->booster = input_booster_allocate(INPUT_BOOSTER_ID_TSP);
+	if (!info->booster) {
+		dev_err(&client->dev, "%s: Error, failed to allocate input booster\n",__func__);
+		ret = -ENODEV;
+		goto error_alloc_booster_failed;
+	}
+#endif
+
 	info->irq = gpio_to_irq(pdata->gpio_int);
 	if (info->irq < 0) {
 		dev_err(&client->dev, "failed to get gpio_to_irq\n");
@@ -5256,6 +5326,11 @@ err_misc_register:
 	free_irq(info->irq, info);
 err_request_irq:
 err_gpio_irq:
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->booster);
+	info->booster = NULL;
+error_alloc_booster_failed:
+#endif
 #if ESD_TIMER_INTERVAL
 err_esd_input_unregister_device:
 #endif
diff --git a/drivers/input/touchscreen/zt7548_ts.h b/drivers/input/touchscreen/zt7548_ts.h
index 1fcc0c74f687..829e771ee4df 100755
--- a/drivers/input/touchscreen/zt7548_ts.h
+++ b/drivers/input/touchscreen/zt7548_ts.h
@@ -46,6 +46,10 @@
 
 #include <linux/input/tsp_ta_callback.h>
 
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
+
 #define ZT7548_IC_CHIP_CODE	0xE548
 #define ZT7538_IC_CHIP_CODE	0xE538
 
@@ -510,6 +514,9 @@ struct zt7548_ts_info {
 	s16					ref_scale_factor;
 	s16					ref_btn_option;
 	struct pinctrl				*pinctrl;
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster			*booster;
+#endif
 #ifdef SUPPORTED_KEY_LED
 	struct regulator			*led_ldo;
 #endif
diff --git a/drivers/input/touchscreen/zt7554_ts.c b/drivers/input/touchscreen/zt7554_ts.c
index 6985f407d448..fa3c32a49e79 100755
--- a/drivers/input/touchscreen/zt7554_ts.c
+++ b/drivers/input/touchscreen/zt7554_ts.c
@@ -1319,6 +1319,10 @@ static void clear_report_data(struct zt7554_ts_info *info)
 	if (reported)
 		input_sync(info->input_dev);
 	
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, -1);
+#endif
 }
 
 static irqreturn_t zt7554_touch_work(int irq, void *data)
@@ -1538,6 +1542,10 @@ static irqreturn_t zt7554_touch_work(int irq, void *data)
 	input_sync(info->input_dev);
 
 out:
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, info->finger_cnt > 0 ? 1 : 0);
+#endif
 
 	if (info->work_state == NORMAL) {
 #if ESD_TIMER_INTERVAL
@@ -1880,6 +1888,10 @@ int ts_upgrade_sequence(const u8 *firmware_data)
 #ifdef SEC_FACTORY_TEST
 #define TSP_CMD(name, func) .cmd_name = name, .cmd_func = func
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data);
+#endif
+
 static struct tsp_cmd tsp_cmds[] = {
 	{TSP_CMD("fw_update", fw_update),},
 	{TSP_CMD("get_fw_ver_bin", get_fw_ver_bin),},
@@ -1903,6 +1915,9 @@ static struct tsp_cmd tsp_cmds[] = {
 	{TSP_CMD("run_delta_read", run_delta_read),},
 	{TSP_CMD("get_delta", get_delta),},
 	{TSP_CMD("run_ref_calibration", run_ref_calibration),},
+#ifdef CONFIG_INPUT_BOOSTER
+	{TSP_CMD("boost_level", boost_level),},
+#endif
 };
 
 static inline void set_cmd_result(struct zt7554_ts_info *info, char *buff, int len)
@@ -1918,6 +1933,52 @@ static inline void set_default_result(struct zt7554_ts_info *info)
 	strncat(info->factory_info->cmd_result, &delim, 1);
 }
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data)
+{
+	struct zt7554_ts_info *info = (struct zt7554_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	char buff[16] = {0};
+	int stage;
+
+	dev_info(&client->dev, "%s\n", __func__);
+
+	set_default_result(info);
+
+	stage = 1 << info->factory_info->cmd_param[0];
+	if (!(info->booster->dvfs_stage & stage)) {
+		snprintf(buff, sizeof(buff), "NG");
+		info->factory_info->cmd_state = FAIL;
+		dev_err(&info->client->dev,"%s: %d is not supported(%04x != %04x).\n",__func__,
+			info->factory_info->cmd_param[0], stage, info->booster->dvfs_stage);
+
+		goto boost_out;
+	}
+
+	info->booster->dvfs_boost_mode = stage;
+	input_booster_set_level_change(info->factory_info->cmd_param[0]);
+	snprintf(buff, sizeof(buff), "OK");
+	info->factory_info->cmd_state = OK;
+
+	if (info->booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		if (info->booster && info->booster->dvfs_set)
+			info->booster->dvfs_set(info->booster, -1);
+	}
+
+boost_out:
+	set_cmd_result(info, buff,
+			strnlen(buff, sizeof(buff)));
+
+	mutex_lock(&info->factory_info->cmd_lock);
+	info->factory_info->cmd_is_running = false;
+	mutex_unlock(&info->factory_info->cmd_lock);
+
+	info->factory_info->cmd_state = WAITING;
+
+	return;
+}
+#endif
+
 static void fw_update(void *device_data)
 {
 	struct zt7554_ts_info *info = (struct zt7554_ts_info *)device_data;
@@ -3638,6 +3699,14 @@ static int zt7554_ts_probe(struct i2c_client *client, const struct i2c_device_id
 	esd_timer_start(CHECK_ESD_TIMER, info);
 #endif
 
+#ifdef CONFIG_INPUT_BOOSTER
+	info->booster = input_booster_allocate(INPUT_BOOSTER_ID_TSP);
+	if (!info->booster) {
+		dev_err(&client->dev, "%s: Error, failed to allocate input booster\n",__func__);
+		goto error_alloc_booster_failed;
+	}
+#endif
+
 	info->irq = gpio_to_irq(pdata->gpio_int);
 	if (info->irq < 0) {
 		dev_err(&client->dev, "failed to get gpio_to_irq\n");
@@ -3701,6 +3770,11 @@ err_misc_register:
 #endif
 err_request_irq:
 err_gpio_irq:
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->booster);
+	info->booster = NULL;
+error_alloc_booster_failed:
+#endif
 #if ESD_TIMER_INTERVAL
 err_esd_input_unregister_device:
 #endif
diff --git a/drivers/input/touchscreen/zt7554_ts.h b/drivers/input/touchscreen/zt7554_ts.h
index 82c130a56022..f2a468212863 100755
--- a/drivers/input/touchscreen/zt7554_ts.h
+++ b/drivers/input/touchscreen/zt7554_ts.h
@@ -43,6 +43,10 @@
 #include <linux/async.h>
 #include <linux/input/tsp_ta_callback.h>
 
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
+
 #define TOUCH_BOOSTER 0	// blocked SPRD booster, use QC CONFIG_COMMON_INPUT_BOOSTER
 
 #if TOUCH_BOOSTER
@@ -462,6 +466,9 @@ struct zt7554_ts_info {
 	s16					vdiff_min_val;
 	u8					finger_cnt;
 	struct pinctrl 			*pinctrl;
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster	*booster;
+#endif
 #ifdef SUPPORTED_KEY_LED
 	struct regulator	*led_ldo;
 #endif
diff --git a/include/linux/i2c/mxts_1188s.h b/include/linux/i2c/mxts_1188s.h
index 0832dffaa1d9..a3f2934aa5e6 100644
--- a/include/linux/i2c/mxts_1188s.h
+++ b/include/linux/i2c/mxts_1188s.h
@@ -20,6 +20,9 @@
 #include <linux/earlysuspend.h>
 #endif
 #include <linux/input/tsp_ta_callback.h>
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
 #if defined(CONFIG_TOUCHSCREEN_ATMEL_MXT224S)
 #define MXT_DEV_NAME	"Atmel MXT224S"
 #elif defined(CONFIG_TOUCHSCREEN_ATMEL_MXT540S)
@@ -596,6 +599,9 @@ struct mxt_data {
 	int tkey_dvfs_boost_mode;
 	int tkey_dvfs_freq;
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+        struct input_booster *tsp_booster;
+#endif
 #if TSP_USE_ATMELDBG
 	struct atmel_dbg atmeldbg;
 #endif
diff --git a/include/linux/i2c/mxtt.h b/include/linux/i2c/mxtt.h
index 0dacb9a74c6b..1deb321bb69a 100644
--- a/include/linux/i2c/mxtt.h
+++ b/include/linux/i2c/mxtt.h
@@ -33,6 +33,11 @@
 #endif
 #include <asm/system_info.h>
 
+#ifdef CONFIG_COMMON_INPUT_BOOSTER
+//to enabled common touch booster. This must be included.
+#include <linux/input/input_booster.h>
+#endif
+
 #include <linux/input/tsp_ta_callback.h>
 
 #ifdef CONFIG_SEC_DEBUG_TSP_LOG
@@ -740,6 +745,10 @@ struct mxt_data {
 #if TSP_PATCH
 	struct mxt_patch patch;
 #endif
+#ifdef COMMON_INPUT_BOOSTER
+	u8 touch_pressed_num;
+        struct input_booster *tsp_booster;
+#endif
 
 #if TSP_CHANGE_CONFIG_FOR_INPUT
 	bool is_inputmethod;
diff --git a/include/linux/wacom_i2c.h b/include/linux/wacom_i2c.h
index 5ded4f9f0444..faa39f58e246 100755
--- a/include/linux/wacom_i2c.h
+++ b/include/linux/wacom_i2c.h
@@ -20,6 +20,11 @@
 #endif
 #include <linux/pinctrl/consumer.h>
 
+#ifdef CONFIG_COMMON_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#define WACOM_BOOSTER
+#endif
+
 /* WACOM NOISE from LCD OSC.
  * read Vsync frequency value at wacom firmware.
  */
diff --git a/arch/arm/configs/msm8916_sec_gtelwifi_usa_defconfig b/arch/arm/configs/msm8916_sec_gtelwifi_usa_defconfig
index d424ab48f3ef..486643b4b584 100755
--- a/arch/arm/configs/msm8916_sec_gtelwifi_usa_defconfig
+++ b/arch/arm/configs/msm8916_sec_gtelwifi_usa_defconfig
@@ -21,6 +21,7 @@ CONFIG_MUIC_SM5703_SUPPORT_LANHUB_TA=y
 #Touch Screen
 #CONFIG_TOUCHSCREEN_MMS300_A=y
 CONFIG_TOUCHSCREEN_ZT7554_TS=y
+CONFIG_INPUT_BOOSTER=y
 
 # Vibrator
 CONFIG_SM5703_VIBRATOR=n
diff --git a/drivers/input/Kconfig b/drivers/input/Kconfig
index bb469e32c608..b7c395f9de17 100644
--- a/drivers/input/Kconfig
+++ b/drivers/input/Kconfig
@@ -200,6 +200,20 @@ config SENSORS_HALL
 	 Say y here if you want to use this hall sensor driver, it
 	 is like a switch. For example, lid.
 
+config COMMON_INPUT_BOOSTER
+	tristate "input booster"
+	depends on INPUT
+	help
+	  Say Y here if you want to boost shen some keys and touches are pressed. If unsure, say N.
+
+config INPUT_BOOSTER
+	tristate "input booster"
+	depends on INPUT
+	default n
+	help
+	  Say Y here if you want to boost when some keys and touches are pressed. If unsure, say N.
+
+
 comment "Input Device Drivers"
 
 source "drivers/input/keyboard/Kconfig"
diff --git a/drivers/input/Makefile b/drivers/input/Makefile
index 481ed9f0e5cc..f1884b85a8c8 100644
--- a/drivers/input/Makefile
+++ b/drivers/input/Makefile
@@ -7,6 +7,8 @@
 obj-$(CONFIG_INPUT)		+= input-core.o
 input-core-y := input.o input-compat.o input-mt.o ff-core.o
 
+obj-$(CONFIG_INPUT_BOOSTER)	+= input_booster.o
+
 obj-$(CONFIG_INPUT_FF_MEMLESS)	+= ff-memless.o
 obj-$(CONFIG_INPUT_POLLDEV)	+= input-polldev.o
 obj-$(CONFIG_INPUT_SPARSEKMAP)	+= sparse-keymap.o
@@ -30,3 +32,7 @@ obj-$(CONFIG_INPUT_KEYCOMBO)	+= keycombo.o
 obj-$(CONFIG_SENSORS_HALL)	+= hall_sensor.o
 
 obj-$(CONFIG_INPUT_TOUCHSCREEN)	+= sec_cmd.o
+
+# Input Booster
+obj-$(CONFIG_COMMON_INPUT_BOOSTER)	+= input_booster_common.o
+
diff --git a/drivers/input/input.c b/drivers/input/input.c
index f0a193671a29..cf8890744f9f 100644
--- a/drivers/input/input.c
+++ b/drivers/input/input.c
@@ -29,6 +29,10 @@
 #include <linux/rcupdate.h>
 #include "input-compat.h"
 
+#if !defined(CONFIG_INPUT_BOOSTER) // Input Booster +
+#include <linux/input/input.h>
+#endif // Input Booster -
+
 MODULE_AUTHOR("Vojtech Pavlik <vojtech@suse.cz>");
 MODULE_DESCRIPTION("Input core");
 MODULE_LICENSE("GPL");
@@ -403,6 +407,382 @@ static void input_handle_event(struct input_dev *dev,
 
 }
 
+
+#if !defined(CONFIG_INPUT_BOOSTER) // Input Booster +
+// ********** Define Timeout Functions ********** //
+DECLARE_TIMEOUT_FUNC(touch);
+DECLARE_TIMEOUT_FUNC(multitouch);
+DECLARE_TIMEOUT_FUNC(key);
+DECLARE_TIMEOUT_FUNC(touchkey);
+DECLARE_TIMEOUT_FUNC(keyboard);
+DECLARE_TIMEOUT_FUNC(mouse);
+DECLARE_TIMEOUT_FUNC(mouse_wheel);
+DECLARE_TIMEOUT_FUNC(pen);
+DECLARE_TIMEOUT_FUNC(hover);
+
+// ********** Define Set Booster Functions ********** //
+DECLARE_SET_BOOSTER_FUNC(touch);
+DECLARE_SET_BOOSTER_FUNC(multitouch);
+DECLARE_SET_BOOSTER_FUNC(key);
+DECLARE_SET_BOOSTER_FUNC(touchkey);
+DECLARE_SET_BOOSTER_FUNC(keyboard);
+DECLARE_SET_BOOSTER_FUNC(mouse);
+DECLARE_SET_BOOSTER_FUNC(mouse_wheel);
+DECLARE_SET_BOOSTER_FUNC(pen);
+DECLARE_SET_BOOSTER_FUNC(hover);
+
+// ********** Define State Functions ********** //
+DECLARE_STATE_FUNC(idle)
+{
+	struct t_input_booster *_this = (struct t_input_booster *)(__this);
+	glGage = HEADGAGE;
+	if(input_booster_event == BOOSTER_ON) {
+		int i;
+		pr_debug("[Input Booster] %s      State0 : Idle  index : %d, cpu : %d, time : %d, input_booster_event : %d\n", glGage, _this->index, _this->param[_this->index].cpu_freq, _this->param[_this->index].time, input_booster_event);
+		_this->index=0;
+		for(i=0;i<2;i++) {
+			if(delayed_work_pending(&_this->input_booster_timeout_work[i])) {
+				pr_debug("[Input Booster] ****             cancel the pending workqueue\n");
+				cancel_delayed_work(&_this->input_booster_timeout_work[i]);
+			}
+		}
+		SET_BOOSTER;
+		schedule_delayed_work(&_this->input_booster_timeout_work[_this->index], msecs_to_jiffies(_this->param[_this->index].time));
+		_this->index++;
+		CHANGE_STATE_TO(press);
+	} else if(input_booster_event == BOOSTER_OFF) {
+		pr_debug("[Input Booster] %s      Skipped  index : %d, cpu : %d, input_booster_event : %d\n", glGage, _this->index, _this->param[_this->index].cpu_freq, input_booster_event);
+		pr_debug("\n");
+	}
+}
+
+DECLARE_STATE_FUNC(press)
+{
+	struct t_input_booster *_this = (struct t_input_booster *)(__this);
+	glGage = TAILGAGE;
+
+	if(input_booster_event == BOOSTER_OFF) {
+		pr_debug("[Input Booster] %s      State : Press  index : %d, time : %d\n", glGage, _this->index, _this->param[_this->index].time);
+		if(_this->multi_events <= 0) {
+			if(delayed_work_pending(&_this->input_booster_timeout_work[(_this->index) ? _this->index-1 : 0]) || (_this->param[(_this->index) ? _this->index-1 : 0].time == 0)) {
+				if(_this->change_on_release || (_this->param[(_this->index) ? _this->index-1 : 0].time == 0)) {
+					pr_debug("[Input Booster] %s           cancel the pending workqueue\n", glGage);
+					cancel_delayed_work(&_this->input_booster_timeout_work[(_this->index) ? _this->index-1 : 0]);
+					SET_BOOSTER;
+				}
+				schedule_delayed_work(&_this->input_booster_timeout_work[_this->index], msecs_to_jiffies(_this->param[_this->index].time));
+				pr_debug("[Input Booster] %s           schedule_delayed_work again  time : %d\n", glGage, _this->param[_this->index].time);
+				if(!delayed_work_pending(&_this->input_booster_timeout_work[_this->index]) && _this->param[_this->index].time > 0) {
+					pr_debug("[Input Booster] %s           schedule_delayed_work Re-again time : %d\n", glGage, _this->param[(_this->index > 0) ? _this->index-1 : _this->index].time);
+					schedule_delayed_work(&_this->input_booster_timeout_work[(_this->index > 0) ? _this->index-1 : _this->index], msecs_to_jiffies(_this->param[(_this->index > 0) ? _this->index-1 : _this->index].time));
+				}
+			} else if(_this->param[_this->index].time > 0) {
+				schedule_delayed_work(&_this->input_booster_timeout_work[_this->index], msecs_to_jiffies(_this->param[_this->index].time));
+			} else {
+				schedule_delayed_work(&_this->input_booster_timeout_work[(_this->index) ? _this->index-1 : 0], msecs_to_jiffies(_this->param[(_this->index > 0) ? _this->index-1 : _this->index].time));
+			}
+			_this->index++;
+			_this->multi_events = (_this->multi_events > 0) ? 0 : _this->multi_events;
+			CHANGE_STATE_TO(idle);
+		}
+	} else if(input_booster_event == BOOSTER_ON) {
+		if(delayed_work_pending(&_this->input_booster_timeout_work[_this->index])) {
+			pr_debug("[Input Booster] %s           cancel the pending workqueue for multi events\n", glGage);
+			cancel_delayed_work(&_this->input_booster_timeout_work[_this->index]);
+			schedule_delayed_work(&_this->input_booster_timeout_work[(_this->index) ? _this->index-1 : 0], msecs_to_jiffies(_this->param[(_this->index > 0) ? _this->index-1 : _this->index].time));
+		} else {
+			pr_debug("[Input Booster] %s      State : Press  index : %d, time : %d\n", glGage, _this->index, _this->param[_this->index].time);
+		}
+	}
+}
+
+// ********** Detect Events ********** //
+void input_booster(struct input_dev *dev)
+{
+	int i, j, DetectedCategory = false, iTouchID = -1, iTouchSlot = -1/*,lcdoffcounter = 0*/;
+
+	for(i=0;i<input_count;i++) {
+		if (DetectedCategory) {
+			break;
+		} else if (input_events[i].type == EV_KEY) {
+			switch (input_events[i].code) {
+				case BTN_TOUCH :
+					if(input_events[i+1].type == EV_KEY && input_events[i+1].code == BTN_TOOL_PEN) {
+						if(input_events[i].value && !pen_booster.multi_events) {
+							pr_debug("[Input Booster] PEN EVENT - PRESS\n");
+							RUN_BOOSTER(pen, BOOSTER_ON);
+							DetectedCategory = true;
+						} else if(!input_events[i].value && pen_booster.multi_events) {
+							pr_debug("[Input Booster] PEN EVENT - RELEASE\n");
+							RUN_BOOSTER(pen, BOOSTER_OFF);
+							DetectedCategory = true;
+						}
+					} else if(iTouchID >= 0) { // ***************** Checking Touch Event's ID whethere it is same with previous ID.
+						if(!input_events[i].value && input_events[iTouchID].value < 0) {  // If this event is 'Release'
+							for(j=0;j<MAX_MULTI_TOUCH_EVENTS;j++) {
+								TouchIDs[j] = -1;
+							}
+						}
+					}
+					break;
+				case BTN_TOOL_PEN :
+					if(input_events[i].value && !hover_booster.multi_events) {
+						pr_debug("[Input Booster] PEN EVENT - HOVER ON\n");
+						RUN_BOOSTER(hover, BOOSTER_ON);
+						DetectedCategory = true;
+					} else if(!input_events[i].value && hover_booster.multi_events) {
+						pr_debug("[Input Booster] PEN EVENT - HOVER OFF\n");
+						RUN_BOOSTER(hover, BOOSTER_OFF);
+						DetectedCategory = true;
+					}
+					break;
+				case KEY_BACK : // ***************** Checking Key & Touch key Event
+					if(key_back != input_events[i].value) {
+						key_back = input_events[i].value;
+						pr_debug("[Input Booster] TOUCHKEY EVENT - %s\n", (input_events[i].value) ? "PRESS" : "RELEASE");
+						RUN_BOOSTER(touchkey, (input_events[i].value) ? BOOSTER_ON : BOOSTER_OFF );
+						DetectedCategory = true;
+					}
+					break;
+				case KEY_HOMEPAGE :
+					if(key_home != input_events[i].value) {
+						key_home = input_events[i].value;
+						pr_debug("[Input Booster] TOUCHKEY EVENT - %s\n", (input_events[i].value) ? "PRESS" : "RELEASE");
+						RUN_BOOSTER(touchkey, (input_events[i].value) ? BOOSTER_ON : BOOSTER_OFF );
+						DetectedCategory = true;
+					}
+					break;
+				case KEY_RECENT :
+					if(key_recent != input_events[i].value) {
+						key_recent = input_events[i].value;
+						pr_debug("[Input Booster] TOUCHKEY EVENT - %s\n", (input_events[i].value) ? "PRESS" : "RELEASE");
+						RUN_BOOSTER(touchkey, (input_events[i].value) ? BOOSTER_ON : BOOSTER_OFF );
+						DetectedCategory = true;
+					}
+					break;
+				case KEY_VOLUMEUP :
+				case KEY_VOLUMEDOWN :
+				case KEY_POWER :
+					pr_debug("[Input Booster] KEY EVENT - %s\n", (input_events[i].value) ? "PRESS" : "RELEASE");
+					RUN_BOOSTER(key, (input_events[i].value) ? BOOSTER_ON : BOOSTER_OFF );
+					DetectedCategory = true;
+					break;
+				default :
+					break;
+			}
+		} else if (input_events[i].type == EV_ABS) {
+			if (input_events[i].code == ABS_MT_TRACKING_ID) {
+				iTouchID = i;
+				if(input_events[iTouchSlot].value < MAX_MULTI_TOUCH_EVENTS && input_events[iTouchSlot].value >= 0 && iTouchID < MAX_EVENTS && iTouchSlot <= MAX_EVENTS) {
+					if(TouchIDs[input_events[iTouchSlot].value] < 0 && input_events[iTouchID].value >= 0) {
+						TouchIDs[input_events[iTouchSlot].value] = input_events[iTouchID].value;
+						if(touch_booster.multi_events <= 0 || input_events[iTouchSlot].value == 0) {
+							touch_booster.multi_events = 0;
+							pr_debug("[Input Booster] TOUCH EVENT - PRESS - ID: 0x%x, Slot: 0x%x, multi : %d\n", input_events[iTouchID].value, input_events[iTouchSlot].value, touch_booster.multi_events);
+							RUN_BOOSTER(touch, BOOSTER_ON );
+						} else {
+							pr_debug("[Input Booster] MULTI-TOUCH EVENT - PRESS - ID: 0x%x, Slot: 0x%x, multi : %d\n", input_events[iTouchID].value, input_events[iTouchSlot].value, touch_booster.multi_events);
+							touch_booster.multi_events++;
+							RUN_BOOSTER(multitouch, BOOSTER_ON );
+#if defined(CONFIG_ARCH_EXYNOS)
+							if(delayed_work_pending(&touch_booster.input_booster_timeout_work[0])) {
+								int temp_hmp_boost = touch_booster.param[0].hmp_boost, temp_index = touch_booster.index;
+								pr_debug("[Input Booster] ****             cancel the pending touch booster workqueue\n");
+								cancel_delayed_work(&touch_booster.input_booster_timeout_work[0]);
+								touch_booster.param[0].hmp_boost = multitouch_booster.param[0].hmp_boost;
+								touch_booster.index = 1;
+								TIMEOUT_FUNC(touch)(NULL);
+								touch_booster.param[0].hmp_boost = temp_hmp_boost;
+								touch_booster.index = temp_index;
+							}
+#endif
+						}
+					} else if(TouchIDs[input_events[iTouchSlot].value] >= 0 && input_events[iTouchID].value < 0) {
+						TouchIDs[input_events[iTouchSlot].value] = input_events[iTouchID].value;
+						if(touch_booster.multi_events <= 1) {
+							pr_debug("[Input Booster] TOUCH EVENT - RELEASE - ID: 0x%x, Slot: 0x%x, multi : %d\n", input_events[iTouchID].value, input_events[iTouchSlot].value, touch_booster.multi_events);
+							RUN_BOOSTER(touch, BOOSTER_OFF );
+						} else {
+							pr_debug("[Input Booster] MULTI-TOUCH EVENT - RELEASE - ID: 0x%x, Slot: 0x%x, multi : %d\n", input_events[iTouchID].value, input_events[iTouchSlot].value, touch_booster.multi_events);
+							touch_booster.multi_events--;
+							RUN_BOOSTER(multitouch, BOOSTER_OFF );
+						}
+					}
+				}
+			} else if (input_events[i].code == ABS_MT_SLOT) {
+				iTouchSlot = i;
+				/*
+				if(input_events[iTouchSlot + 1].value < 0) {
+					lcdoffcounter++;
+				}
+				if(lcdoffcounter >= 10) { 
+					touch_booster.multi_events = 0;
+					multitouch_booster.multi_events = 0;
+					keyboard_booster.multi_events = 0;
+					pr_debug("[Input Booster] Multi events are reset  %d\n", lcdoffcounter);
+				}
+				*/
+			}
+		} else if (input_events[i].type == EV_MSC && input_events[i].code == MSC_SCAN) {
+			if (input_events[i+1].type == EV_KEY) {
+				switch (input_events[i+1].code) {
+					case BTN_LEFT : // ***************** Checking Touch Button Event
+					case BTN_RIGHT :
+					case BTN_MIDDLE :
+						pr_debug("[Input Booster] MOUSE EVENT - %s\n", (input_events[i+1].value) ? "PRESS" : "RELEASE");
+						RUN_BOOSTER(mouse, (input_events[i+1].value) ? BOOSTER_ON : BOOSTER_OFF );
+						DetectedCategory = true;
+						break;
+					default : // ***************** Checking Keyboard Event
+						pr_debug("[Input Booster] KEYBOARD EVENT - %s (multi count %d )\n", (input_events[i+1].value) ? "PRESS" : "RELEASE", keyboard_booster.multi_events);
+						RUN_BOOSTER(keyboard, (input_events[i+1].value) ? BOOSTER_ON : BOOSTER_OFF );
+						//DetectedCategory = true; // keyboard event can be continue in a set.
+						break;
+				}
+			}
+		} else if (input_events[i].type == EV_REL && input_events[i].code == REL_WHEEL && input_events[i].value) { // ***************** Wheel Event for Mouse
+			if (input_events[0].type == EV_KEY && input_events[0].code == BTN_LEFT) {
+				pr_debug("[Input Booster] MOUSE EVENT - %s\n", "WHELL");
+				RUN_BOOSTER(mouse_wheel, BOOSTER_ON);
+				DetectedCategory = true;
+			}
+		}
+	}
+}
+
+// ********** Init Booster ********** //
+void input_booster_init()
+{
+	// ********** Load Frequncy data from DTSI **********
+	struct device_node *np;
+	int nlevels = 0, i;
+
+	if(device_tree_infor != NULL){
+		return;
+	}
+
+	np = of_find_compatible_node(NULL, NULL, "input_booster");
+
+	if(np == NULL) {
+		ndevice_in_dt = 0;
+		return;
+	}
+
+	// Geting the count of devices.
+	ndevice_in_dt = of_get_child_count(np);
+	pr_debug("[Input Booster] %s   ndevice_in_dt : %d\n", __FUNCTION__, ndevice_in_dt);
+
+	device_tree_infor = kcalloc(ABS_CNT, sizeof(struct t_input_booster_device_tree_infor) * ndevice_in_dt, GFP_KERNEL);
+	if(device_tree_infor > 0) {
+		struct device_node *cnp;
+		int device_count = 0;
+
+		for_each_child_of_node(np, cnp) {
+			struct t_input_booster_device_tree_infor *dt_infor = (device_tree_infor + device_count);
+			const u32 *plevels = NULL;
+
+			// Geting label.
+			dt_infor->label = of_get_property(cnp, "input_booster,label", NULL);
+			pr_debug("[Input Booster] %s   dt_infor->label : %s\n", __FUNCTION__, dt_infor->label);
+
+			if (of_property_read_u32(cnp, "input_booster,type", &dt_infor->type)) {
+				pr_debug("Failed to get type property\n");
+				break;
+			}
+
+			// Geting the count of levels.
+			plevels = of_get_property(cnp, "input_booster,levels", &nlevels);
+
+			if (plevels && nlevels) {
+				dt_infor->nlevels = nlevels / sizeof(u32);
+				pr_debug("[Input Booster] %s   dt_infor->nlevels : %d\n", __FUNCTION__, dt_infor->nlevels);
+			} else {
+				pr_debug("Failed to calculate number of frequency.\n");
+				break;
+			}
+
+			// Allocation the param table.
+			dt_infor->param_tables = kcalloc(ABS_CNT, sizeof(struct t_input_booster_device_tree_param) * dt_infor->nlevels, GFP_KERNEL);
+			if (!dt_infor->param_tables) {
+				pr_debug("Failed to allocate memory of freq_table\n");
+				break;
+			}
+
+			// fill the param table
+			pr_debug("[Input Booster] device_type:%d, label :%s, type: 0x%02x, num_level[%d]\n",
+				dt_infor->type, dt_infor->label, dt_infor->type, dt_infor->nlevels);
+
+			for (i = 0; i < dt_infor->nlevels; i++) {
+				u32 temp;
+				int err = 0;
+
+				err = of_property_read_u32_index(cnp, "input_booster,levels", i, &temp);  dt_infor->param_tables[i].ilevels = (u8)temp;
+				DTSI_TO;
+				if (err) {
+					pr_debug("Failed to get [%d] param table property\n", i);
+				}
+/*
+				pr_debug("[Input Booster] Level %d : frequency[%d,%d,%d,%d] hmp_boost[%d] times[%d,%d,%d]\n", i,
+					dt_infor->param_tables[i].cpu_freq,
+					dt_infor->param_tables[i].kfc_freq,
+					dt_infor->param_tables[i].mif_freq,
+					dt_infor->param_tables[i].int_freq,
+					dt_infor->param_tables[i].hmp_boost,
+					dt_infor->param_tables[i].head_time,
+					dt_infor->param_tables[i].tail_time,
+					dt_infor->param_tables[i].phase_time);
+*/
+			}
+
+			device_count++;
+		}
+	}
+
+	// ********** Initialize Buffer for Touch **********
+	for(i=0;i<MAX_MULTI_TOUCH_EVENTS;i++) {
+		TouchIDs[i] = -1;
+	}
+
+	// ********** Initialize Booster **********
+	INIT_BOOSTER(touch)
+	INIT_BOOSTER(multitouch)
+	INIT_BOOSTER(key)
+	INIT_BOOSTER(touchkey)
+	INIT_BOOSTER(keyboard)
+	INIT_BOOSTER(mouse)
+	INIT_BOOSTER(mouse_wheel)
+	INIT_BOOSTER(pen)
+	INIT_BOOSTER(hover)
+	multitouch_booster.change_on_release = 1;
+
+	// ********** Initialize Sysfs **********
+	{
+		struct class *sysfs_class;
+
+		sysfs_class = class_create(THIS_MODULE, "input_booster");
+		if (IS_ERR(sysfs_class)) {
+			pr_debug("[Input Booster] Failed to create class\n");
+			return;
+		}
+
+		INIT_SYSFS_CLASS(debug_level)
+		INIT_SYSFS_CLASS(head)
+		INIT_SYSFS_CLASS(tail)
+		INIT_SYSFS_CLASS(level)
+
+		INIT_SYSFS_DEVICE(touch)
+		INIT_SYSFS_DEVICE(multitouch)
+		INIT_SYSFS_DEVICE(key)
+		INIT_SYSFS_DEVICE(touchkey)
+		INIT_SYSFS_DEVICE(keyboard)
+		INIT_SYSFS_DEVICE(mouse)
+		INIT_SYSFS_DEVICE(mouse_wheel)
+		INIT_SYSFS_DEVICE(pen)
+		INIT_SYSFS_DEVICE(hover)
+	}
+}
+#endif  // Input Booster -
+
 /**
  * input_event() - report new input event
  * @dev: device that generated the event
@@ -430,6 +810,24 @@ void input_event(struct input_dev *dev,
 		spin_lock_irqsave(&dev->event_lock, flags);
 		input_handle_event(dev, type, code, value);
 		spin_unlock_irqrestore(&dev->event_lock, flags);
+
+#if !defined(CONFIG_INPUT_BOOSTER) // Input Booster +
+		if(device_tree_infor != NULL) {
+			if (type == EV_SYN && input_count > 0) {
+				pr_debug("[Input Booster1] ==============================================\n");
+				input_booster(dev);
+				input_count=0;
+			} else {
+				pr_debug("[Input Booster1] type = %x, code = %x, value =%x\n", type, code, value);
+				input_events[input_count].type = type;
+				input_events[input_count].code = code;
+				input_events[input_count].value = value;
+				if(input_count < MAX_EVENTS) {
+					input_count++;
+				}
+			}
+		}
+#endif  // Input Booster -
 	}
 }
 EXPORT_SYMBOL(input_event);
@@ -2468,6 +2866,10 @@ static int __init input_init(void)
 		goto fail2;
 	}
 
+#if !defined(CONFIG_INPUT_BOOSTER) // Input Booster +
+	input_booster_init();
+#endif  // Input Booster -
+
 	return 0;
 
  fail2:	input_proc_exit();
diff --git a/drivers/input/input_booster.c b/drivers/input/input_booster.c
new file mode 100644
index 000000000000..e3668fb1ef85
--- /dev/null
+++ b/drivers/input/input_booster.c
@@ -0,0 +1,887 @@
+/*
+ * input_booster.c - touch booster driver
+ *
+ * Copyright (C) 2014 Samsung Electronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+
+#include <linux/input/input_booster.h>
+
+#define DVFS_TOUCH_ID	0
+int set_freq_limit(unsigned long id, unsigned int freq)
+{
+	pr_err("%s is not yet implemented\n", __func__);
+	return 0;
+}
+
+static struct input_booster_data *g_data;
+
+/* TSP and Wacom use this */
+static void input_booster_change_dvfs_work(struct work_struct *work)
+{
+	int retval = 0;
+	struct input_booster_data *data = g_data;
+	struct input_booster *booster =
+		container_of(work,
+				struct input_booster, work_dvfs_chg.work);
+
+	if (!data) {
+		pr_err("%s: data is NULL, return", __func__);
+		return;
+	}
+
+	mutex_lock(&booster->dvfs_lock);
+
+	switch (booster->dvfs_boost_mode) {
+	case DVFS_STAGE_SINGLE:
+		if (booster->dvfs_freq != -1) {
+			if (data->dbg_level)
+				pr_info("%s: cpu clk set: -1\n", __func__);
+			retval = set_freq_limit(DVFS_TOUCH_ID, -1);
+			if (retval < 0)
+				pr_err("%s: booster stop failed(%d).\n",
+							__func__, retval);
+			booster->dvfs_freq = -1;
+		}
+#ifdef CONFIG_DEBUG_BUS_VOTER
+		if (booster->bimc_freq != 0) {
+			if (data->dbg_level)
+				pr_info("%s: bimc clk set: 0\n", __func__);
+			retval = msm_bus_floor_vote("bimc", 0);
+			if (retval < 0)
+				pr_err("%s: bimc release failed(%d).\n",
+							__func__, retval);
+			booster->bimc_freq = 0;
+		}
+#endif
+		break;
+	case DVFS_STAGE_DUAL:
+#ifdef CONFIG_ARCH_MSM8939
+	case DVFS_STAGE_TRIPLE:
+#endif
+		if (booster->dvfs_freq != data->tail.cpu_freq) {
+			if (data->dbg_level)
+				pr_info("%s: cpu clk set: %d\n", __func__, data->tail.cpu_freq);
+			retval = set_freq_limit(DVFS_TOUCH_ID,
+					data->tail.cpu_freq);
+			if (retval < 0)
+				pr_err("%s: cpu clk %d set failed(%d).\n",
+					__func__, data->tail.cpu_freq, retval);
+			booster->dvfs_freq = data->tail.cpu_freq;
+		}
+#ifdef CONFIG_DEBUG_BUS_VOTER
+		if (booster->bimc_freq != data->tail.bimc_freq) {
+			if (data->dbg_level)
+				pr_info("%s: bimc clk set: %d\n", __func__, data->tail.bimc_freq);
+			retval = msm_bus_floor_vote("bimc", data->tail.bimc_freq * 1000);
+			booster->bimc_freq = data->tail.bimc_freq;
+		}
+#endif
+		break;
+	}
+
+	if (retval < 0)
+		pr_err("%s: booster change failed(%d).\n",
+				__func__, retval);
+	mutex_unlock(&booster->dvfs_lock);
+}
+
+/* TSP and Wacom use this */
+static void input_booster_set_dvfs_lock(struct input_booster *booster, int on)
+{
+	struct input_booster_data *data = g_data;
+	int retval = 0;
+
+	if (!data) {
+		pr_err("%s: data is NULL, return", __func__);
+		return;
+	}
+
+	booster->dvfs_boost_mode = 1 << data->level;
+
+	if (booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		pr_debug("%s: DVFS stage is none(%d)\n",
+				__func__, booster->dvfs_boost_mode);
+		return;
+	}
+
+	mutex_lock(&booster->dvfs_lock);
+
+	if (on == 0) {
+		if (booster->dvfs_lock_status) {
+			switch (booster->dvfs_boost_mode) {
+			case DVFS_STAGE_SINGLE:
+			case DVFS_STAGE_DUAL:
+#ifdef CONFIG_ARCH_MSM8939
+			case DVFS_STAGE_TRIPLE:
+#endif
+				schedule_delayed_work(&booster->work_dvfs_off,
+					msecs_to_jiffies(data->tail.time));
+				break;
+			}
+		}
+	} else if (on > 0) {
+		cancel_delayed_work(&booster->work_dvfs_off);
+
+		if ((!booster->dvfs_lock_status) || (booster->dvfs_old_stauts < on)) {
+			cancel_delayed_work(&booster->work_dvfs_chg);
+
+			switch (booster->dvfs_boost_mode) {
+			case DVFS_STAGE_SINGLE:
+#ifdef CONFIG_ARCH_MSM8939
+			case DVFS_STAGE_TRIPLE:
+				if (booster->dvfs_freq != data->tail.cpu_freq) {
+					if (data->dbg_level)
+						pr_info("%s: cpu clk set: %d\n", __func__, data->tail.cpu_freq);
+					retval = set_freq_limit(DVFS_TOUCH_ID,
+							data->tail.cpu_freq);
+					booster->dvfs_freq = data->tail.cpu_freq;
+				}
+#ifdef CONFIG_DEBUG_BUS_VOTER
+				if (booster->bimc_freq != data->tail.bimc_freq) {
+					if (data->dbg_level)
+						pr_info("%s: bimc clk set: %d\n", __func__, data->tail.bimc_freq);
+					msm_bus_floor_vote("bimc", data->tail.bimc_freq * 1000);
+					booster->bimc_freq = data->tail.bimc_freq;
+				}
+#endif
+				schedule_delayed_work(&booster->work_dvfs_chg,
+					msecs_to_jiffies(data->head.time));
+				break;
+#endif
+			case DVFS_STAGE_DUAL:
+				if (booster->dvfs_freq != data->head.cpu_freq) {
+					if (data->dbg_level)
+						pr_info("%s: cpu clk set: %d\n", __func__, data->head.cpu_freq);
+					retval = set_freq_limit(DVFS_TOUCH_ID,
+							data->head.cpu_freq);
+					booster->dvfs_freq = data->head.cpu_freq;
+				}
+#ifdef CONFIG_DEBUG_BUS_VOTER
+				if (booster->bimc_freq != data->head.bimc_freq) {
+					if (data->dbg_level)
+						pr_info("%s: bimc clk set: %d\n", __func__, data->head.bimc_freq);
+					msm_bus_floor_vote("bimc", data->head.bimc_freq * 1000);
+					booster->bimc_freq = data->head.bimc_freq;
+				}
+#endif
+				schedule_delayed_work(&booster->work_dvfs_chg,
+					msecs_to_jiffies(data->head.time));
+				break;
+			}
+
+			if (retval < 0)
+				pr_err("%s: cpu first lock failed(%d)\n",
+						__func__, retval);
+
+			booster->dvfs_lock_status = true;
+		}
+
+	} else if (on < 0) {
+		if (booster->dvfs_lock_status) {
+			cancel_delayed_work(&booster->work_dvfs_off);
+			cancel_delayed_work(&booster->work_dvfs_chg);
+			schedule_work(&booster->work_dvfs_off.work);
+		}
+	}
+
+	booster->dvfs_old_stauts = on;
+	mutex_unlock(&booster->dvfs_lock);
+}
+
+/* Tkey use this */
+static void input_booster_change_dvfs_tkey_work(struct work_struct *work)
+{
+	struct input_booster_data *data = g_data;
+	int retval = 0;
+	struct input_booster *booster =
+		container_of(work,
+				struct input_booster, work_dvfs_chg.work);
+
+	if (!data) {
+		pr_err("%s: data is NULL, return", __func__);
+		return;
+	}
+
+	mutex_lock(&booster->dvfs_lock);
+
+	if (data->dbg_level)
+		pr_info("%s: cpu clk set: %d\n", __func__, booster->dvfs_freq);
+	retval = set_freq_limit(DVFS_TOUCH_ID, booster->dvfs_freq);
+	if (retval < 0)
+		pr_info("%s: booster change failed(%d).\n",
+			__func__, retval);
+
+	booster->dvfs_lock_status = false;
+	mutex_unlock(&booster->dvfs_lock);
+}
+
+/* Tkey use this */
+static void input_booster_set_dvfs_tkey_lock(struct input_booster *booster, int on)
+{
+	struct input_booster_data *data = g_data;
+	int retval = 0;
+
+	if (!data) {
+		pr_err("%s: data is NULL, return", __func__);
+		return;
+	}
+
+	if (booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		pr_debug("%s: DVFS stage is none(%d)\n",
+				__func__, booster->dvfs_boost_mode);
+		return;
+	}
+
+	mutex_lock(&booster->dvfs_lock);
+	if (on == 0) {
+		cancel_delayed_work(&booster->work_dvfs_chg);
+
+		if (booster->dvfs_lock_status) {
+			if (data->dbg_level)
+				pr_info("%s: cpu clk set: %d\n", __func__, booster->dvfs_freq);
+			retval = set_freq_limit(DVFS_TOUCH_ID, booster->dvfs_freq);
+
+			if (retval < 0)
+				pr_info("%s: cpu first lock failed(%d)\n", __func__, retval);
+			booster->dvfs_lock_status = false;
+		}
+
+		schedule_delayed_work(&booster->work_dvfs_off,
+			msecs_to_jiffies(INPUT_BOOSTER_OFF_TIME_TKEY));
+
+	} else if (on == 1) {
+		cancel_delayed_work(&booster->work_dvfs_off);
+		schedule_delayed_work(&booster->work_dvfs_chg,
+			msecs_to_jiffies(INPUT_BOOSTER_CHG_TIME_TKEY));
+
+	} else if (on == 2) {
+		if (booster->dvfs_lock_status) {
+			cancel_delayed_work(&booster->work_dvfs_off);
+			cancel_delayed_work(&booster->work_dvfs_chg);
+			schedule_work(&booster->work_dvfs_off.work);
+		}
+	}
+	mutex_unlock(&booster->dvfs_lock);
+}
+
+static int input_booster_set_dvfs_off(struct input_booster *booster)
+{
+	struct input_booster_data *data = g_data;
+	int retval = 0;
+
+	if (!data) {
+		pr_err("%s: data is NULL, return", __func__);
+		return 0;
+	}
+
+	mutex_lock(&booster->dvfs_lock);
+
+	if (booster->dvfs_freq != -1) {
+		if (data->dbg_level)
+			pr_info("%s: cpu clk set: -1\n", __func__);
+		retval = set_freq_limit(DVFS_TOUCH_ID, -1);
+		if (retval < 0)
+			pr_err("%s: booster stop failed(%d).\n",
+						__func__, retval);
+	}
+#ifdef CONFIG_DEBUG_BUS_VOTER
+	if (booster->bimc_freq != 0) {
+		if (data->dbg_level)
+			pr_info("%s: bimc clk set: 0\n", __func__);
+		retval = msm_bus_floor_vote("bimc", 0);
+		if (retval < 0)
+			pr_err("%s: bimc release failed(%d).\n",
+						__func__, retval);
+	}
+#endif
+
+	if (booster->dvfs_id == INPUT_BOOSTER_ID_TKEY) {
+		if (retval < 0)
+			booster->dvfs_lock_status = false;
+		else
+			booster->dvfs_lock_status = true;
+	} else {
+		booster->dvfs_freq = -1;
+		booster->bimc_freq = 0;
+		booster->dvfs_lock_status = false;
+	}
+
+	mutex_unlock(&booster->dvfs_lock);
+
+	return retval;
+}
+
+static void input_booster_off_dvfs_work(struct work_struct *work)
+{
+	struct input_booster *booster =
+		container_of(work,
+				struct input_booster, work_dvfs_off.work);
+
+	input_booster_set_dvfs_off(booster);
+}
+
+static void input_booster_init_dvfs(struct input_booster *booster, int id)
+{
+	struct input_booster_data *data = g_data;
+
+	if (!data) {
+		booster->dvfs_off = NULL;
+		booster->dvfs_set = NULL;
+		pr_err("%s: data is NULL, return", __func__);
+		return;
+	}
+
+	booster->dvfs_id = id;
+
+	switch (booster->dvfs_id) {
+	case INPUT_BOOSTER_ID_TSP:
+		if (!data->dt_data->tsp_stage
+			|| data->dt_data->tsp_stage == DVFS_STAGE_NONE) {
+			booster->dvfs_off = NULL;
+			booster->dvfs_set = NULL;
+			pr_err("%s: TSP Booster is not enabled\n", __func__);
+			return;
+		}
+
+		booster->dvfs_set = input_booster_set_dvfs_lock;
+		INIT_DELAYED_WORK(&booster->work_dvfs_chg,
+				input_booster_change_dvfs_work);
+		booster->dvfs_stage = data->dt_data->tsp_stage;
+		break;
+	case INPUT_BOOSTER_ID_TKEY:
+		if (!data->dt_data->tkey_stage
+			|| data->dt_data->tkey_stage == DVFS_STAGE_NONE) {
+			booster->dvfs_off = NULL;
+			booster->dvfs_set = NULL;
+			pr_err("%s: Tkey Booster is not enabled\n", __func__);
+			return;
+		}
+
+		booster->dvfs_set = input_booster_set_dvfs_tkey_lock;
+		INIT_DELAYED_WORK(&booster->work_dvfs_chg,
+				input_booster_change_dvfs_tkey_work);
+		booster->dvfs_stage = data->dt_data->tkey_stage;
+		break;
+	case INPUT_BOOSTER_ID_WACOM:
+		if (!data->dt_data->wacom_stage
+			|| data->dt_data->wacom_stage == DVFS_STAGE_NONE) {
+			booster->dvfs_off = NULL;
+			booster->dvfs_set = NULL;
+			pr_err("%s: Wacom Booster is not enabled\n", __func__);
+			return;
+		}
+
+		booster->dvfs_set = input_booster_set_dvfs_lock;
+		INIT_DELAYED_WORK(&booster->work_dvfs_chg,
+				input_booster_change_dvfs_work);
+		booster->dvfs_stage = data->dt_data->wacom_stage;
+		break;
+	default:
+		booster->dvfs_off = NULL;
+		booster->dvfs_set = NULL;
+		pr_err("%s: Booster ID is not defined\n", __func__);
+		return;
+	}
+
+	mutex_init(&booster->dvfs_lock);
+	booster->dvfs_off = input_booster_set_dvfs_off;
+	INIT_DELAYED_WORK(&booster->work_dvfs_off, input_booster_off_dvfs_work);
+
+	booster->dvfs_boost_mode = 1 << data->level;
+
+	if (booster->dvfs_id == INPUT_BOOSTER_ID_TKEY) {
+		booster->dvfs_freq = data->tail.cpu_freq;
+		booster->dvfs_lock_status = true;
+	} else {
+		booster->dvfs_lock_status = false;
+	}
+
+	pr_err("%s: [%d] booster stage: 0x%04x, init: 0x%04x\n", __func__,
+		booster->dvfs_id, booster->dvfs_stage, booster->dvfs_boost_mode);
+}
+
+struct input_booster *input_booster_allocate(int id)
+{
+	struct input_booster *booster;
+
+	booster = kzalloc(sizeof(struct input_booster), GFP_KERNEL);
+	if (!booster) {
+		pr_err("%s: Failed to alloc mem for booster\n", __func__);
+		return NULL;
+	}
+
+	input_booster_init_dvfs(booster, id);
+
+	return booster;
+}
+
+void input_booster_free(struct input_booster *booster)
+{
+	if (!booster)
+		return;
+
+	cancel_delayed_work(&booster->work_dvfs_off);
+	cancel_delayed_work(&booster->work_dvfs_chg);
+
+	kfree(booster);
+}
+
+void input_booster_get_default_setting(const char *flag, struct dvfs *value)
+{
+	struct input_booster_data *data = g_data;
+
+	if (!data) {
+		pr_err("%s: data is NULL, return", __func__);
+		return;
+	}
+
+	if (strncmp(flag, "head", 4) == 0) {
+		memcpy(value, &data->dt_data->head, sizeof(struct dvfs));
+	} else if (strncmp(flag, "tail", 4) == 0) {
+		memcpy(value, &data->dt_data->tail, sizeof(struct dvfs));
+	} else {
+		memset(value, 0x0, sizeof(struct dvfs));
+	}
+	dev_info(data->dev, "%s: %s %d %d %d\n", __func__, flag,
+		value->time, value->cpu_freq, value->bimc_freq);
+}
+
+static ssize_t input_booster_get_debug_level(struct class *dev,
+		struct class_attribute *attr, char *buf)
+{
+	struct input_booster_data *data = g_data;
+
+	if (!data) {
+		pr_err("%s: data is NULL, return", __func__);
+		return -ENODEV;
+	}
+
+	dev_info(data->dev, "%s: %d\n", __func__, data->dbg_level);
+
+	return sprintf(buf, "%u\n", data->dbg_level);
+}
+
+static ssize_t input_booster_set_debug_level(struct class *dev,
+		struct class_attribute *attr, const char *buf, size_t count)
+{
+	struct input_booster_data *data = g_data;
+	unsigned long val;
+
+	if (!data) {
+		pr_err("%s: data is NULL, return", __func__);
+		return -ENODEV;
+	}
+
+	if (kstrtoul(buf, 0, &val) < 0)
+		return -EINVAL;
+
+	data->dbg_level = (unsigned int)val;
+	dev_info(data->dev, "%s: %d\n", __func__, data->dbg_level);
+
+	return count;
+}
+
+static ssize_t input_booster_get_head(struct class *dev,
+		struct class_attribute *attr, char *buf)
+{
+	struct input_booster_data *data = g_data;
+
+	if (!data) {
+		pr_err("%s: data is NULL, return", __func__);
+		return -ENODEV;
+	}
+
+	dev_info(data->dev, "%s: %d %d %d\n", __func__,
+		data->head.time, data->head.cpu_freq, data->head.bimc_freq);
+
+	return sprintf(buf, "%d %d %d\n",\
+		data->head.time, data->head.cpu_freq, data->head.bimc_freq);
+}
+
+static ssize_t input_booster_set_head(struct class *dev,
+		struct class_attribute *attr, const char *buf, size_t count)
+{
+	struct input_booster_data *data = g_data;
+	int time, cpu_freq, bimc_freq;
+
+	if (!data) {
+		pr_err("%s: data is NULL, return", __func__);
+		return -ENODEV;
+	}
+
+	if (sscanf(buf, "%d%d%d", &time,&cpu_freq, &bimc_freq) != 3) {
+		dev_err(data->dev,
+			"%s: format [time cpu_freq bimc_freq] (Ex: 130 1600000 1500000)\n",
+			__func__);
+		goto out;
+	}
+
+	data->head.time = time;
+	data->head.cpu_freq = cpu_freq;
+	data->head.bimc_freq = bimc_freq;
+
+	dev_info(data->dev, "%s: %d %d %d\n", __func__,
+		data->head.time, data->head.cpu_freq, data->head.bimc_freq);
+
+out:
+	return count;
+}
+
+static ssize_t input_booster_get_tail(struct class *dev,
+		struct class_attribute *attr, char *buf)
+{
+	struct input_booster_data *data = g_data;
+
+	if (!data) {
+		pr_err("%s: data is NULL, return", __func__);
+		return -ENODEV;
+	}
+
+	dev_info(data->dev, "%s: %d %d %d\n", __func__,
+		data->tail.time, data->tail.cpu_freq, data->tail.bimc_freq);
+
+	return sprintf(buf, "%d %d %d\n",\
+		data->tail.time, data->tail.cpu_freq, data->tail.bimc_freq);
+}
+
+static ssize_t input_booster_set_tail(struct class *dev,
+		struct class_attribute *attr, const char *buf, size_t count)
+{
+	struct input_booster_data *data = g_data;
+	int time, cpu_freq, bimc_freq;
+
+	if (!data) {
+		pr_err("%s: data is NULL, return", __func__);
+		return -ENODEV;
+	}
+
+	if (sscanf(buf, "%d%d%d", &time,&cpu_freq, &bimc_freq) != 3) {
+		dev_err(data->dev,
+			"%s: format [time cpu_freq bimc_freq] (Ex: 130 1600000 1500000)\n",
+			__func__);
+		goto out;
+	}
+
+	data->tail.time = time;
+	data->tail.cpu_freq = cpu_freq;
+	data->tail.bimc_freq = bimc_freq;
+
+	dev_info(data->dev, "%s: %d %d %d\n", __func__,
+		data->tail.time, data->tail.cpu_freq, data->tail.bimc_freq);
+
+out:
+	return count;
+}
+
+static ssize_t input_booster_get_level(struct class *dev,
+		struct class_attribute *attr, char *buf)
+{
+	struct input_booster_data *data = g_data;
+
+	if (!data) {
+		pr_err("%s: data is NULL, return", __func__);
+		return -ENODEV;
+	}
+
+	dev_info(data->dev, "%s: %d\n", __func__, data->level);
+
+	return sprintf(buf, "%d\n", data->level);
+}
+
+static ssize_t input_booster_set_level(struct class *dev,
+		struct class_attribute *attr, const char *buf, size_t count)
+{
+	struct input_booster_data *data = g_data;
+	unsigned int val;
+	int stage;
+
+	if (!data) {
+		pr_err("%s: data is NULL, return", __func__);
+		return -ENODEV;
+	}
+
+	if (kstrtoint(buf, 0, &val) < 0)
+		return -EINVAL;
+
+	stage = 1 << val;
+	if (!(data->dt_data->tsp_stage & stage)) {
+		dev_err(data->dev,
+				"%s: %d is not supported(%04x != %04x).\n",
+				__func__, val, stage, data->dt_data->tsp_stage);
+		return count;
+	}
+
+	data->level = (unsigned int)val;
+	dev_info(data->dev, "%s: %d\n", __func__, data->level);
+
+	return count;
+}
+
+/* Only use tsp/wacom */
+void input_booster_set_level_change(int val)
+{
+	struct input_booster_data *data = g_data;
+	int stage;
+
+	if (!data) {
+		pr_err("%s: data is NULL, return", __func__);
+		return;
+	}
+
+	stage = 1 << val;
+	if (!(data->dt_data->tsp_stage & stage)) {
+		dev_err(data->dev,
+				"%s: %d is not supported(%04x != %04x).\n",
+				__func__, val, stage, data->dt_data->tsp_stage);
+		return;
+	}
+
+	data->level = (unsigned int)val;
+	dev_info(data->dev, "%s: %d\n", __func__, data->level);
+}
+
+static CLASS_ATTR(debug_level, S_IRUGO | S_IWUSR, input_booster_get_debug_level, input_booster_set_debug_level);
+static CLASS_ATTR(head, S_IRUGO | S_IWUSR, input_booster_get_head, input_booster_set_head);
+static CLASS_ATTR(tail, S_IRUGO | S_IWUSR, input_booster_get_tail, input_booster_set_tail);
+static CLASS_ATTR(level, S_IRUGO | S_IWUSR, input_booster_get_level, input_booster_set_level);
+
+static void input_booster_free_sysfs(struct input_booster_data *data)
+{
+	class_remove_file(data->booster_class, &class_attr_debug_level);
+	class_remove_file(data->booster_class, &class_attr_head);
+	class_remove_file(data->booster_class, &class_attr_tail);
+	class_remove_file(data->booster_class, &class_attr_level);
+	class_destroy(data->booster_class);
+}
+
+static int input_booster_init_sysfs(struct input_booster_data *data)
+{
+	int ret;
+
+	data->booster_class = class_create(THIS_MODULE, "input_booster");
+	if (IS_ERR(data->booster_class)) {
+		dev_err(data->dev, "%s: Failed to create class\n", __func__);
+		ret = IS_ERR(data->booster_class);
+		goto err_create_class;
+	}
+
+	ret = class_create_file(data->booster_class, &class_attr_debug_level);
+	if (ret) {
+		dev_err(data->dev, "%s: Failed to create debug_level\n", __func__);
+		goto err_create_dbg_level;
+	}
+
+	ret = class_create_file(data->booster_class, &class_attr_head);
+	if (ret) {
+		dev_err(data->dev, "%s: Failed to create head\n", __func__);
+		goto err_create_head;
+	}
+
+	ret = class_create_file(data->booster_class, &class_attr_tail);
+	if (ret) {
+		dev_err(data->dev, "%s: Failed to create tail\n", __func__);
+		goto err_create_tail;
+	}
+
+	ret = class_create_file(data->booster_class, &class_attr_level);
+	if (ret) {
+		dev_err(data->dev, "%s: Failed to create level\n", __func__);
+		goto err_create_level;
+	}
+
+	return 0;
+
+	class_remove_file(data->booster_class, &class_attr_level);
+err_create_level:
+	class_remove_file(data->booster_class, &class_attr_tail);
+err_create_tail:
+	class_remove_file(data->booster_class, &class_attr_head);
+err_create_head:
+	class_remove_file(data->booster_class, &class_attr_debug_level);
+err_create_dbg_level:
+	class_destroy(data->booster_class);
+err_create_class:
+	return ret;
+}
+
+#ifdef CONFIG_OF
+static int input_booster_parse_dt(struct device *dev,
+			struct input_booster_dt_data *dt_data)
+{
+	struct device_node *np = dev->of_node;
+	int rc;
+	u32 head[3];
+	u32 tail[3];
+
+	rc = of_property_read_u32(np, "booster,tsp_stage", &dt_data->tsp_stage);
+	if (rc < 0)
+		dev_info(dev, "%s: Unable to read booster,tsp_stage[%d]\n", __func__, rc);
+
+	rc = of_property_read_u32(np, "booster,tkey_stage", &dt_data->tkey_stage);
+	if (rc < 0)
+		dev_info(dev, "%s: Unable to read booster,tkey_stage[%d]\n", __func__, rc);
+
+	rc = of_property_read_u32(np, "booster,wacom_stage", &dt_data->wacom_stage);
+	if (rc < 0)
+		dev_info(dev, "%s: Unable to read booster,wacom_stage[%d]\n", __func__, rc);
+
+	dev_info(dev, "%s: stage tsp:0x%04x, tkey:0x%04x, wacom:0x%04x\n", __func__,
+		dt_data->tsp_stage, dt_data->tkey_stage, dt_data->wacom_stage);
+
+
+	rc = of_property_read_u32(np, "booster,level", &dt_data->level);
+	if (rc < 0)
+		dev_info(dev, "%s: Unable to read booster,level[%d]\n", __func__, rc);
+
+	rc = of_property_read_u32_array(np, "booster,head", head, 3);
+	if (rc < 0)
+		dev_info(dev, "%s: Unable to read booster,head[%d]\n", __func__, rc);
+
+	dt_data->head.time = head[0];
+	dt_data->head.cpu_freq = head[1];
+	dt_data->head.bimc_freq = head[2];
+
+	rc = of_property_read_u32_array(np, "booster,tail", tail, 3);
+	if (rc < 0)
+		dev_info(dev, "%s: Unable to read booster,tail[%d]\n", __func__, rc);
+
+	dt_data->tail.time = tail[0];
+	dt_data->tail.cpu_freq = tail[1];
+	dt_data->tail.bimc_freq = tail[2];
+
+	dev_info(dev, "%s: level: %d, header: %d %d %d, tail: %d %d %d\n", __func__, dt_data->level,
+		dt_data->head.time, dt_data->head.cpu_freq, dt_data->head.bimc_freq,
+		dt_data->tail.time, dt_data->tail.cpu_freq, dt_data->tail.bimc_freq);
+
+	return 0;
+}
+
+#else
+static int input_booster_parse_dt(struct device *dev,
+			struct input_booster_dt_data *dt_data)
+{
+	return -ENODEV;
+}
+#endif
+
+static int input_booster_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct input_booster_data *data;
+	struct input_booster_dt_data *dt_data = NULL;
+	int ret = 0;
+
+	dev_info(dev, "%s\n", __func__);
+
+	if (dev->of_node) {
+		dt_data = devm_kzalloc(dev,
+				sizeof(struct input_booster_dt_data),
+				GFP_KERNEL);
+		if (!dt_data) {
+			dev_err(dev, "%s: failed to allocate memory\n", __func__);
+			return -ENOMEM;
+		}
+		ret = input_booster_parse_dt(dev, dt_data);
+		if (ret)
+			goto err_alloc_dt_data;
+	} else {
+		dt_data = dev->platform_data;
+		dev_err(dev, "%s: failed to align dtsi\n", __func__);
+	}
+
+	if (!dt_data) {
+		dev_err(dev, "%s: dt_data is NULL\n", __func__);
+		ret = -ENODEV;
+		goto err_alloc_dt_data;
+	};
+
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (!data) {
+		dev_err(dev, "%s: Failed to alloc data\n", __func__);
+		ret = -ENOMEM;
+		goto err_alloc_data;
+	}
+
+	data->dev = dev;
+	data->dt_data = dt_data;
+	g_data = data;
+	platform_set_drvdata(pdev, data);
+
+	memcpy(&data->head, &dt_data->head, sizeof(data->head));
+	memcpy(&data->tail, &dt_data->tail, sizeof(data->tail));
+	data->level = dt_data->level;
+
+	ret = input_booster_init_sysfs(data);
+	if (ret)
+		goto err_init_sysfs;
+
+	return 0;
+
+	input_booster_free_sysfs(data);
+err_init_sysfs:
+	kfree(data);
+	g_data = NULL;
+err_alloc_data:
+	devm_kfree(dev, dt_data);
+err_alloc_dt_data:
+	return ret;
+}
+
+static int input_booster_remove(struct platform_device *pdev)
+{
+	struct input_booster_data *data = platform_get_drvdata(pdev);
+
+	input_booster_free_sysfs(data);
+	devm_kfree(data->dev, data->dt_data);
+	kfree(data);
+	g_data = NULL;
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static struct of_device_id input_booster_dt_ids[] = {
+	{ .compatible = INPUT_BOOSTER_NAME },
+	{ }
+};
+#endif
+
+static struct platform_driver input_booster_driver = {
+	.driver = {
+		.name = INPUT_BOOSTER_NAME,
+		.owner = THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table	= of_match_ptr(input_booster_dt_ids),
+#endif
+	},
+	.probe = input_booster_probe,
+	.remove = input_booster_remove,
+};
+
+static int __init input_booster_init(void)
+{
+	return platform_driver_register(&input_booster_driver);
+}
+
+static void __exit input_booster_exit(void)
+{
+	return platform_driver_unregister(&input_booster_driver);
+}
+
+module_init(input_booster_init);
+module_exit(input_booster_exit);
+
+MODULE_DESCRIPTION("Input device[Touch, Touchkey, Hardkey] booster 2.1 version");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("SAMSUNG Electronics");
+
diff --git a/drivers/input/input_booster_common.c b/drivers/input/input_booster_common.c
new file mode 100644
index 000000000000..e6ddd4b7803c
--- /dev/null
+++ b/drivers/input/input_booster_common.c
@@ -0,0 +1,379 @@
+/*
+ * input_booster.c - touch booster driver
+ *
+ * Copyright (C) 2014 Samsung Electronics
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/input/input_booster.h>
+
+static void input_booster_change_dvfs_tsp_work(struct work_struct *work)
+{
+	int retval = 0;
+	struct input_booster *booster =
+		container_of(work,
+				struct input_booster, work_dvfs_chg.work);
+
+	mutex_lock(&booster->dvfs_lock);
+
+	switch (booster->dvfs_boost_mode) {
+	case DVFS_STAGE_SINGLE:
+	case DVFS_STAGE_TRIPLE:
+	case DVFS_STAGE_PENTA:
+		retval = set_freq_limit(DVFS_TOUCH_ID, -1);
+		booster->dvfs_freq = -1;
+		break;
+	case DVFS_STAGE_DUAL:
+		retval = set_freq_limit(DVFS_TOUCH_ID,
+				MIN_TOUCH_LIMIT_SECOND);
+		booster->dvfs_freq = MIN_TOUCH_LIMIT_SECOND;
+		break;
+	case DVFS_STAGE_NINTH:
+		retval = set_freq_limit(DVFS_TOUCH_ID,
+				MIN_TOUCH_LIMIT);
+		booster->dvfs_freq = MIN_TOUCH_LIMIT;
+		break;
+	}
+
+	if (retval < 0)
+		pr_err("%s: booster change failed(%d).\n",
+				__func__, retval);
+	mutex_unlock(&booster->dvfs_lock);
+}
+
+static void input_booster_set_dvfs_tsp_lock(struct input_booster *booster, int on)
+{
+	int retval = 0;
+
+	if (booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		pr_debug("%s: DVFS stage is none(%d)\n",
+				__func__, booster->dvfs_boost_mode);
+		return;
+	}
+
+	mutex_lock(&booster->dvfs_lock);
+
+	if (on == 0) {
+		if (booster->dvfs_lock_status) {
+			switch (booster->dvfs_boost_mode) {
+			case DVFS_STAGE_SINGLE:
+			case DVFS_STAGE_DUAL:
+			case DVFS_STAGE_TRIPLE:
+			case DVFS_STAGE_PENTA:
+				schedule_delayed_work(&booster->work_dvfs_off,
+					msecs_to_jiffies(INPUT_BOOSTER_OFF_TIME_TSP));
+				break;
+			case DVFS_STAGE_NINTH:
+				schedule_delayed_work(&booster->work_dvfs_off,
+					msecs_to_jiffies(INPUT_BOOSTER_HIGH_OFF_TIME_TSP));
+				break;
+			}
+		}
+	} else if (on > 0) {
+		cancel_delayed_work(&booster->work_dvfs_off);
+
+		if ((!booster->dvfs_lock_status) || (booster->dvfs_old_stauts < on)) {
+			cancel_delayed_work(&booster->work_dvfs_chg);
+
+			switch (booster->dvfs_boost_mode) {
+			case DVFS_STAGE_SINGLE:
+			case DVFS_STAGE_DUAL:
+				if (booster->dvfs_freq != MIN_TOUCH_LIMIT) {
+					retval = set_freq_limit(DVFS_TOUCH_ID,
+							MIN_TOUCH_LIMIT);
+					booster->dvfs_freq = MIN_TOUCH_LIMIT;
+				}
+				schedule_delayed_work(&booster->work_dvfs_chg,
+					msecs_to_jiffies(INPUT_BOOSTER_CHG_TIME_TSP));
+				break;
+			case DVFS_STAGE_TRIPLE:
+				if (booster->dvfs_freq != MIN_TOUCH_LIMIT_SECOND) {
+					retval = set_freq_limit(DVFS_TOUCH_ID,
+							MIN_TOUCH_LIMIT_SECOND);
+					booster->dvfs_freq = MIN_TOUCH_LIMIT_SECOND;
+				}
+				schedule_delayed_work(&booster->work_dvfs_chg,
+					msecs_to_jiffies(INPUT_BOOSTER_CHG_TIME_TSP));
+				break;
+			case DVFS_STAGE_PENTA:
+				if (booster->dvfs_freq != MIN_TOUCH_LOW_LIMIT) {
+					retval = set_freq_limit(DVFS_TOUCH_ID,
+							MIN_TOUCH_LOW_LIMIT);
+					booster->dvfs_freq = MIN_TOUCH_LOW_LIMIT;
+				}
+				schedule_delayed_work(&booster->work_dvfs_chg,
+					msecs_to_jiffies(INPUT_BOOSTER_CHG_TIME_TSP));
+				break;
+			case DVFS_STAGE_NINTH:
+				if (booster->dvfs_freq != MIN_TOUCH_HIGH_LIMIT) {
+					retval = set_freq_limit(DVFS_TOUCH_ID,
+							MIN_TOUCH_HIGH_LIMIT);
+					booster->dvfs_freq = MIN_TOUCH_HIGH_LIMIT;
+				}
+				schedule_delayed_work(&booster->work_dvfs_chg,
+					msecs_to_jiffies(INPUT_BOOSTER_HIGH_CHG_TIME_TSP));
+				break;
+
+			}
+
+			if (retval < 0)
+				pr_err("%s: cpu first lock failed(%d)\n",
+						__func__, retval);
+
+			booster->dvfs_lock_status = true;
+		}
+
+	} else if (on < 0) {
+		if (booster->dvfs_lock_status) {
+			cancel_delayed_work(&booster->work_dvfs_off);
+			cancel_delayed_work(&booster->work_dvfs_chg);
+			schedule_work(&booster->work_dvfs_off.work);
+		}
+	}
+
+	booster->dvfs_old_stauts = on;
+	mutex_unlock(&booster->dvfs_lock);
+}
+
+static void input_booster_change_dvfs_tkey_work(struct work_struct *work)
+{
+	int retval = 0;
+	struct input_booster *booster =
+		container_of(work,
+				struct input_booster, work_dvfs_chg.work);
+
+	mutex_lock(&booster->dvfs_lock);
+
+	retval = set_freq_limit(DVFS_TOUCH_ID, booster->dvfs_freq);
+	if (retval < 0)
+		pr_info("%s: booster change failed(%d).\n",
+			__func__, retval);
+
+	booster->dvfs_lock_status = false;
+	mutex_unlock(&booster->dvfs_lock);
+}
+
+static void input_booster_set_dvfs_tkey_lock(struct input_booster *booster, int on)
+{
+	int retval = 0;
+	if (booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		pr_debug("%s: DVFS stage is none(%d)\n",
+				__func__, booster->dvfs_boost_mode);
+		return;
+	}
+
+	mutex_lock(&booster->dvfs_lock);
+	if (on == 0) {
+		cancel_delayed_work(&booster->work_dvfs_chg);
+
+		if (booster->dvfs_lock_status) {
+			retval = set_freq_limit(DVFS_TOUCH_ID, booster->dvfs_freq);
+
+			if (retval < 0)
+				pr_info("%s: cpu first lock failed(%d)\n", __func__, retval);
+			booster->dvfs_lock_status = false;
+		}
+
+		schedule_delayed_work(&booster->work_dvfs_off,
+			msecs_to_jiffies(INPUT_BOOSTER_CHG_TIME_TKEY));
+
+	} else if (on == 1) {
+		cancel_delayed_work(&booster->work_dvfs_off);
+		schedule_delayed_work(&booster->work_dvfs_chg,
+			msecs_to_jiffies(INPUT_BOOSTER_OFF_TIME_TKEY));
+
+	} else if (on == 2) {
+		if (booster->dvfs_lock_status) {
+			cancel_delayed_work(&booster->work_dvfs_off);
+			cancel_delayed_work(&booster->work_dvfs_chg);
+			schedule_work(&booster->work_dvfs_off.work);
+		}
+	}
+	mutex_unlock(&booster->dvfs_lock);
+}
+
+static void input_booster_change_dvfs_wacom_work(struct work_struct *work)
+{
+	int retval = 0;
+	struct input_booster *booster =
+		container_of(work,
+				struct input_booster, work_dvfs_chg.work);
+
+	mutex_lock(&booster->dvfs_lock);
+
+	switch (booster->dvfs_boost_mode) {
+	case DVFS_STAGE_SINGLE:
+	case DVFS_STAGE_TRIPLE:
+		retval = set_freq_limit(DVFS_TOUCH_ID, -1);
+		booster->dvfs_freq = -1;
+		break;
+	case DVFS_STAGE_DUAL:
+		retval = set_freq_limit(DVFS_TOUCH_ID,
+				MIN_TOUCH_LIMIT_SECOND);
+		booster->dvfs_freq = MIN_TOUCH_LIMIT_SECOND;
+		break;
+	}
+
+	if (retval < 0)
+		pr_info("%s: booster change failed(%d).\n",
+			__func__, retval);
+
+	mutex_unlock(&booster->dvfs_lock);
+}
+
+static void input_booster_set_dvfs_wacom_lock(struct input_booster *booster, int on)
+{
+	int retval = 0;
+	if (booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		pr_debug("%s: DVFS stage is none(%d)\n",
+				__func__, booster->dvfs_boost_mode);
+		return;
+	}
+
+	mutex_lock(&booster->dvfs_lock);
+
+	if (on == 0) {
+		if (booster->dvfs_lock_status) {
+			schedule_delayed_work(&booster->work_dvfs_off,
+				msecs_to_jiffies(INPUT_BOOSTER_OFF_TIME_WACOM));
+		}
+	} else if (on > 0) {
+		cancel_delayed_work(&booster->work_dvfs_off);
+
+		if (!booster->dvfs_lock_status || booster->dvfs_old_stauts < on) {
+			cancel_delayed_work(&booster->work_dvfs_chg);
+
+			switch (booster->dvfs_boost_mode) {
+			case DVFS_STAGE_SINGLE:
+			case DVFS_STAGE_DUAL:
+				if (booster->dvfs_freq != MIN_TOUCH_LIMIT) {
+					retval = set_freq_limit(DVFS_TOUCH_ID,
+							MIN_TOUCH_LIMIT);
+					booster->dvfs_freq = MIN_TOUCH_LIMIT;
+				}
+				schedule_delayed_work(&booster->work_dvfs_chg,
+					msecs_to_jiffies(INPUT_BOOSTER_CHG_TIME_WACOM));
+				break;
+			case DVFS_STAGE_TRIPLE:
+				if (booster->dvfs_freq != MIN_TOUCH_LIMIT_SECOND) {
+					retval = set_freq_limit(DVFS_TOUCH_ID,
+							MIN_TOUCH_LIMIT_SECOND);
+					booster->dvfs_freq = MIN_TOUCH_LIMIT_SECOND;
+				}
+				schedule_delayed_work(&booster->work_dvfs_chg,
+					msecs_to_jiffies(INPUT_BOOSTER_CHG_TIME_WACOM));
+				break;
+			}
+
+			if (retval < 0)
+				pr_info("%s: cpu first lock failed(%d)\n",
+						__func__, retval);
+			schedule_delayed_work(&booster->work_dvfs_chg,
+				msecs_to_jiffies(INPUT_BOOSTER_CHG_TIME_WACOM));
+
+			booster->dvfs_lock_status = true;
+		}
+
+	} else if (on < 0) {
+		if (booster->dvfs_lock_status) {
+			cancel_delayed_work(&booster->work_dvfs_off);
+			cancel_delayed_work(&booster->work_dvfs_chg);
+			schedule_work(&booster->work_dvfs_off.work);
+		}
+	}
+	booster->dvfs_old_stauts = on;
+
+	mutex_unlock(&booster->dvfs_lock);
+}
+
+static int input_booster_set_dvfs_off(struct input_booster *booster)
+{
+	int retval;
+
+	mutex_lock(&booster->dvfs_lock);
+
+	retval = set_freq_limit(DVFS_TOUCH_ID, -1);
+	if (retval < 0)
+		pr_err("%s: booster stop failed(%d).\n",
+					__func__, retval);
+
+	if (booster->dvfs_id == INPUT_BOOSTER_ID_TKEY) {
+		if (retval < 0)
+			booster->dvfs_lock_status = false;
+		else
+			booster->dvfs_lock_status = true;
+	} else {
+		booster->dvfs_freq = -1;
+		booster->dvfs_lock_status = false;
+	}
+
+	mutex_unlock(&booster->dvfs_lock);
+
+	return retval;
+}
+
+static void input_booster_off_dvfs_work(struct work_struct *work)
+{
+	struct input_booster *booster =
+		container_of(work,
+				struct input_booster, work_dvfs_off.work);
+
+	input_booster_set_dvfs_off(booster);
+}
+
+void input_booster_init_dvfs(struct input_booster *booster, int id)
+{
+	booster->dvfs_id = id;
+	mutex_init(&booster->dvfs_lock);
+	printk(KERN_ALERT"input_booster_init_dvfs\n");
+	switch (booster->dvfs_id) {
+	case INPUT_BOOSTER_ID_TSP:
+		booster->dvfs_set = input_booster_set_dvfs_tsp_lock;
+		INIT_DELAYED_WORK(&booster->work_dvfs_chg,
+				input_booster_change_dvfs_tsp_work);
+		booster->dvfs_stage = DVFS_TSP_STAGE;
+		break;
+	case INPUT_BOOSTER_ID_TKEY:
+		booster->dvfs_set = input_booster_set_dvfs_tkey_lock;
+		INIT_DELAYED_WORK(&booster->work_dvfs_chg,
+				input_booster_change_dvfs_tkey_work);
+		booster->dvfs_stage = DVFS_TKEY_STAGE;
+		break;
+	case INPUT_BOOSTER_ID_WACOM:
+		booster->dvfs_set = input_booster_set_dvfs_wacom_lock;
+		INIT_DELAYED_WORK(&booster->work_dvfs_chg,
+				input_booster_change_dvfs_wacom_work);
+		booster->dvfs_stage = DVFS_WACOM_STAGE;
+		break;
+	default:
+		booster->dvfs_off = NULL;
+		booster->dvfs_set = NULL;
+		pr_err("%s: Booster ID is not defined\n", __func__);
+		return;
+	}
+
+	booster->dvfs_off = input_booster_set_dvfs_off;
+	INIT_DELAYED_WORK(&booster->work_dvfs_off, input_booster_off_dvfs_work);
+
+	if(booster->dvfs_stage & DVFS_STAGE_DUAL)
+		booster->dvfs_boost_mode = DVFS_STAGE_DUAL;
+	else
+		booster->dvfs_boost_mode = DVFS_STAGE_NONE;
+
+	if (booster->dvfs_id == INPUT_BOOSTER_ID_TKEY) {
+		booster->dvfs_freq = MIN_TOUCH_LIMIT_SECOND;
+		booster->dvfs_lock_status = true;
+	} else {
+		booster->dvfs_lock_status = false;
+	}
+
+	pr_err("%s: booster stage: 0x%04x\n", __func__, booster->dvfs_stage);
+}
+
+MODULE_DESCRIPTION("Input device[Touch, Touchkey, Hardkey] booster");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/keyboard/abov_touchkey_a8.c b/drivers/input/keyboard/abov_touchkey_a8.c
index 5a657aed3e19..2939f7afbfe0 100644
--- a/drivers/input/keyboard/abov_touchkey_a8.c
+++ b/drivers/input/keyboard/abov_touchkey_a8.c
@@ -37,6 +37,9 @@
 #ifdef CONFIG_OF
 #include <linux/of_gpio.h>
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
 
 #define ABOV_TK_NAME "abov-touchkey"
 
@@ -138,6 +141,9 @@ struct abov_tk_info {
 	struct delayed_work led_twinkle_work;
 	bool led_twinkle_check;
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster *tkey_booster;
+#endif
 };
 
 struct abov_touchkey_devicetree_data {
@@ -259,6 +265,10 @@ static void release_all_fingers(struct abov_tk_info *info)
 	}
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->tkey_booster && info->tkey_booster->dvfs_set)
+		info->tkey_booster->dvfs_set(info->tkey_booster, 2);
+#endif
 }
 
 static int abov_tk_reset_for_bootmode(struct abov_tk_info *info)
@@ -391,9 +401,65 @@ static irqreturn_t abov_tk_interrupt(int irq, void *dev_id)
 #endif
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->tkey_booster && info->tkey_booster->dvfs_set)
+		info->tkey_booster->dvfs_set(info->tkey_booster, press);
+#endif
+
 	return IRQ_HANDLED;
 }
 
+#ifdef CONFIG_INPUT_BOOSTER
+static ssize_t boost_level_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct abov_tk_info *info = dev_get_drvdata(dev);
+	int val, stage;
+	struct dvfs value;
+
+	if (!info->tkey_booster) {
+		dev_err(&info->client->dev,
+			"%s: booster is NULL\n", __func__);
+		return count;
+	}
+
+	sscanf(buf, "%d", &val);
+
+	stage = 1 << val;
+
+	if (!(info->tkey_booster->dvfs_stage & stage)) {
+		dev_info(&info->client->dev,
+			"%s: wrong cmd %d\n", __func__, val);
+		return count;
+	}
+
+	info->tkey_booster->dvfs_boost_mode = stage;
+	dev_info(&info->client->dev,
+			"%s: dvfs_boost_mode = 0x%X\n",
+			__func__, info->tkey_booster->dvfs_boost_mode);
+
+	if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		if (info->tkey_booster->dvfs_set)
+			info->tkey_booster->dvfs_set(info->tkey_booster, 2);
+	} else if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_SINGLE) {
+		input_booster_get_default_setting("head", &value);
+		info->tkey_booster->dvfs_freq = value.cpu_freq;
+		dev_info(&info->client->dev,
+			"%s: boost_mode SINGLE, dvfs_freq = %d\n",
+			__func__, info->tkey_booster->dvfs_freq);
+	} else if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_DUAL) {
+		input_booster_get_default_setting("tail", &value);
+		info->tkey_booster->dvfs_freq = value.cpu_freq;
+		dev_info(&info->client->dev,
+			"%s: boost_mode DUAL, dvfs_freq = %d\n",
+			__func__, info->tkey_booster->dvfs_freq);
+	}
+
+	return count;
+}
+#endif
+
 static int touchkey_led_set(struct abov_tk_info *info, int data)
 {
 	u8 cmd;
@@ -1095,6 +1161,10 @@ static DEVICE_ATTR(touchkey_firm_update_status, S_IRUGO | S_IWUSR | S_IWGRP,
 static DEVICE_ATTR(glove_mode, S_IRUGO | S_IWUSR | S_IWGRP,
 			abov_glove_mode_show, abov_glove_mode);
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+static DEVICE_ATTR(boost_level,
+		   S_IWUSR | S_IWGRP, NULL, boost_level_store);
+#endif
 
 static struct attribute *sec_touchkey_attributes[] = {
 	&dev_attr_touchkey_threshold.attr,
@@ -1110,6 +1180,9 @@ static struct attribute *sec_touchkey_attributes[] = {
 #ifdef GLOVE_MODE
 	&dev_attr_glove_mode.attr,
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	&dev_attr_boost_level.attr,
+#endif
 	NULL,
 };
 
@@ -1466,6 +1539,15 @@ static int abov_tk_probe(struct i2c_client *client,
 		goto err_reg_input_dev;
 	}
 
+#ifdef CONFIG_INPUT_BOOSTER
+	info->tkey_booster = input_booster_allocate(INPUT_BOOSTER_ID_TKEY);
+	if (!info->tkey_booster) {
+		dev_err(&client->dev,
+			"%s [ERROR] failed to allocate input booster\n", __func__);
+		goto err_alloc_booster_failed;
+	}
+#endif
+
 	info->enabled = true;
 
 	if (!info->dtdata->irq_flag) {
@@ -1519,6 +1601,11 @@ static int abov_tk_probe(struct i2c_client *client,
 	return 0;
 
 err_req_irq:
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->tkey_booster);
+	info->tkey_booster = NULL;
+err_alloc_booster_failed:
+#endif
 	input_unregister_device(input_dev);
 err_reg_input_dev:
 	mutex_destroy(&info->lock);
@@ -1570,6 +1657,10 @@ static int abov_tk_remove(struct i2c_client *client)
 		free_irq(info->irq, info);
 	input_unregister_device(info->input_dev);
 	input_free_device(info->input_dev);
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->tkey_booster);
+	info->tkey_booster = NULL;
+#endif
 	kfree(info);
 
 	return 0;
diff --git a/drivers/input/keyboard/abov_touchkey_ft16xx.c b/drivers/input/keyboard/abov_touchkey_ft16xx.c
index 3f276f7756fe..20a30f8694af 100644
--- a/drivers/input/keyboard/abov_touchkey_ft16xx.c
+++ b/drivers/input/keyboard/abov_touchkey_ft16xx.c
@@ -37,6 +37,9 @@
 #ifdef CONFIG_OF
 #include <linux/of_gpio.h>
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
 
 #define ABOV_TK_NAME "abov-ft1604"
 
@@ -137,6 +140,9 @@ struct abov_ft1604_info {
 	struct delayed_work led_twinkle_work;
 	bool led_twinkle_check;
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster *tkey_booster;
+#endif
 };
 
 struct abov_ft1604_devicetree_data {
@@ -259,6 +265,10 @@ static void release_all_fingers(struct abov_ft1604_info *info)
 	}
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->tkey_booster && info->tkey_booster->dvfs_set)
+		info->tkey_booster->dvfs_set(info->tkey_booster, 2);
+#endif
 }
 
 static int abov_tk_reset_for_bootmode(struct abov_ft1604_info *info)
@@ -391,9 +401,65 @@ static irqreturn_t abov_tk_interrupt(int irq, void *dev_id)
 #endif
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->tkey_booster && info->tkey_booster->dvfs_set)
+		info->tkey_booster->dvfs_set(info->tkey_booster, press);
+#endif
+
 	return IRQ_HANDLED;
 }
 
+#ifdef CONFIG_INPUT_BOOSTER
+static ssize_t boost_level_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct abov_ft1604_info *info = dev_get_drvdata(dev);
+	int val, stage;
+	struct dvfs value;
+
+	if (!info->tkey_booster) {
+		dev_err(&info->client->dev,
+			"%s: booster is NULL\n", __func__);
+		return count;
+	}
+
+	sscanf(buf, "%d", &val);
+
+	stage = 1 << val;
+
+	if (!(info->tkey_booster->dvfs_stage & stage)) {
+		dev_info(&info->client->dev,
+			"%s: wrong cmd %d\n", __func__, val);
+		return count;
+	}
+
+	info->tkey_booster->dvfs_boost_mode = stage;
+	dev_info(&info->client->dev,
+			"%s: dvfs_boost_mode = 0x%X\n",
+			__func__, info->tkey_booster->dvfs_boost_mode);
+
+	if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		if (info->tkey_booster->dvfs_set)
+			info->tkey_booster->dvfs_set(info->tkey_booster, 2);
+	} else if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_SINGLE) {
+		input_booster_get_default_setting("head", &value);
+		info->tkey_booster->dvfs_freq = value.cpu_freq;
+		dev_info(&info->client->dev,
+			"%s: boost_mode SINGLE, dvfs_freq = %d\n",
+			__func__, info->tkey_booster->dvfs_freq);
+	} else if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_DUAL) {
+		input_booster_get_default_setting("tail", &value);
+		info->tkey_booster->dvfs_freq = value.cpu_freq;
+		dev_info(&info->client->dev,
+			"%s: boost_mode DUAL, dvfs_freq = %d\n",
+			__func__, info->tkey_booster->dvfs_freq);
+	}
+
+	return count;
+}
+#endif
+
 static int touchkey_led_set(struct abov_ft1604_info *info, int data)
 {
 	u8 cmd;
@@ -1122,6 +1188,10 @@ static DEVICE_ATTR(touchkey_firm_update_status, S_IRUGO | S_IWUSR | S_IWGRP,
 static DEVICE_ATTR(glove_mode, S_IRUGO | S_IWUSR | S_IWGRP,
 			abov_glove_mode_show, abov_glove_mode);
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+static DEVICE_ATTR(boost_level,
+		   S_IWUSR | S_IWGRP, NULL, boost_level_store);
+#endif
 
 static struct attribute *sec_touchkey_attributes[] = {
 	&dev_attr_touchkey_threshold.attr,
@@ -1137,6 +1207,9 @@ static struct attribute *sec_touchkey_attributes[] = {
 #ifdef GLOVE_MODE
 	&dev_attr_glove_mode.attr,
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	&dev_attr_boost_level.attr,
+#endif
 	NULL,
 };
 
@@ -1510,6 +1583,15 @@ static int abov_tk_probe(struct i2c_client *client,
 		goto err_reg_input_dev;
 	}
 
+#ifdef CONFIG_INPUT_BOOSTER
+	info->tkey_booster = input_booster_allocate(INPUT_BOOSTER_ID_TKEY);
+	if (!info->tkey_booster) {
+		dev_err(&client->dev,
+			"%s [ERROR] failed to allocate input booster\n", __func__);
+		goto err_alloc_booster_failed;
+	}
+#endif
+
 	info->enabled = true;
 
 	if (!info->dtdata->irq_flag) {
@@ -1563,6 +1645,11 @@ static int abov_tk_probe(struct i2c_client *client,
 	return 0;
 
 err_req_irq:
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->tkey_booster);
+	info->tkey_booster = NULL;
+err_alloc_booster_failed:
+#endif
 	input_unregister_device(input_dev);
 err_reg_input_dev:
 	mutex_destroy(&info->lock);
@@ -1614,6 +1701,10 @@ static int abov_tk_remove(struct i2c_client *client)
 		free_irq(info->irq, info);
 	input_unregister_device(info->input_dev);
 	input_free_device(info->input_dev);
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->tkey_booster);
+	info->tkey_booster = NULL;
+#endif
 	kfree(info);
 
 	return 0;
diff --git a/drivers/input/keyboard/abov_touchkey_ft18xx.c b/drivers/input/keyboard/abov_touchkey_ft18xx.c
index 970d84e329c4..612bfff4bf0f 100644
--- a/drivers/input/keyboard/abov_touchkey_ft18xx.c
+++ b/drivers/input/keyboard/abov_touchkey_ft18xx.c
@@ -37,6 +37,9 @@
 #ifdef CONFIG_OF
 #include <linux/of_gpio.h>
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
 
 #define ABOV_TK_NAME "abov-touchkey"
 
@@ -166,6 +169,9 @@ struct abov_tk_info {
 	struct delayed_work led_twinkle_work;
 	bool led_twinkle_check;
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster *tkey_booster;
+#endif
 };
 
 struct abov_touchkey_devicetree_data {
@@ -345,6 +351,10 @@ static void release_all_fingers(struct abov_tk_info *info)
 	}
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->tkey_booster && info->tkey_booster->dvfs_set)
+		info->tkey_booster->dvfs_set(info->tkey_booster, 2);
+#endif
 }
 
 static int abov_tk_reset_for_bootmode(struct abov_tk_info *info)
@@ -476,9 +486,65 @@ static irqreturn_t abov_tk_interrupt(int irq, void *dev_id)
 
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->tkey_booster && info->tkey_booster->dvfs_set)
+		info->tkey_booster->dvfs_set(info->tkey_booster, press);
+#endif
+
 	return IRQ_HANDLED;
 }
 
+#ifdef CONFIG_INPUT_BOOSTER
+static ssize_t boost_level_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct abov_tk_info *info = dev_get_drvdata(dev);
+	int val, stage;
+	struct dvfs value;
+
+	if (!info->tkey_booster) {
+		dev_err(&info->client->dev,
+			"%s: booster is NULL\n", __func__);
+		return count;
+	}
+
+	sscanf(buf, "%d", &val);
+
+	stage = 1 << val;
+
+	if (!(info->tkey_booster->dvfs_stage & stage)) {
+		dev_info(&info->client->dev,
+			"%s: wrong cmd %d\n", __func__, val);
+		return count;
+	}
+
+	info->tkey_booster->dvfs_boost_mode = stage;
+	dev_info(&info->client->dev,
+			"%s: dvfs_boost_mode = 0x%X\n",
+			__func__, info->tkey_booster->dvfs_boost_mode);
+
+	if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		if (info->tkey_booster->dvfs_set)
+			info->tkey_booster->dvfs_set(info->tkey_booster, 2);
+	} else if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_SINGLE) {
+		input_booster_get_default_setting("head", &value);
+		info->tkey_booster->dvfs_freq = value.cpu_freq;
+		dev_info(&info->client->dev,
+			"%s: boost_mode SINGLE, dvfs_freq = %d\n",
+			__func__, info->tkey_booster->dvfs_freq);
+	} else if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_DUAL) {
+		input_booster_get_default_setting("tail", &value);
+		info->tkey_booster->dvfs_freq = value.cpu_freq;
+		dev_info(&info->client->dev,
+			"%s: boost_mode DUAL, dvfs_freq = %d\n",
+			__func__, info->tkey_booster->dvfs_freq);
+	}
+
+	return count;
+}
+#endif
+
 static int touchkey_led_set(struct abov_tk_info *info, int data)
 {
 	u8 cmd;
@@ -1439,6 +1505,10 @@ static DEVICE_ATTR(touchkey_firm_update_status, S_IRUGO | S_IWUSR | S_IWGRP,
 static DEVICE_ATTR(glove_mode, S_IRUGO | S_IWUSR | S_IWGRP,
 			abov_glove_mode_show, abov_glove_mode);
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+static DEVICE_ATTR(boost_level,
+		   S_IWUSR | S_IWGRP, NULL, boost_level_store);
+#endif
 
 static struct attribute *sec_touchkey_attributes[] = {
 	&dev_attr_touchkey_threshold.attr,
@@ -1463,6 +1533,9 @@ static struct attribute *sec_touchkey_attributes[] = {
 #ifdef GLOVE_MODE
 	&dev_attr_glove_mode.attr,
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	&dev_attr_boost_level.attr,
+#endif
 	NULL,
 };
 
@@ -1836,6 +1909,15 @@ static int abov_tk_probe(struct i2c_client *client,
 		goto err_reg_input_dev;
 	}
 
+#ifdef CONFIG_INPUT_BOOSTER
+	info->tkey_booster = input_booster_allocate(INPUT_BOOSTER_ID_TKEY);
+	if (!info->tkey_booster) {
+		dev_err(&client->dev,
+			"%s [ERROR] failed to allocate input booster\n", __func__);
+		goto err_alloc_booster_failed;
+	}
+#endif
+
 	info->enabled = true;
 
 	if (!info->dtdata->irq_flag) {
@@ -1889,6 +1971,11 @@ static int abov_tk_probe(struct i2c_client *client,
 	return 0;
 
 err_req_irq:
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->tkey_booster);
+	info->tkey_booster = NULL;
+err_alloc_booster_failed:
+#endif
 	input_unregister_device(input_dev);
 err_reg_input_dev:
 	mutex_destroy(&info->lock);
@@ -1940,6 +2027,10 @@ static int abov_tk_remove(struct i2c_client *client)
 		free_irq(info->irq, info);
 	input_unregister_device(info->input_dev);
 	input_free_device(info->input_dev);
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->tkey_booster);
+	info->tkey_booster = NULL;
+#endif
 	kfree(info);
 
 	return 0;
diff --git a/drivers/input/keyboard/abov_touchkey_na7.c b/drivers/input/keyboard/abov_touchkey_na7.c
index f7afc441dea3..c7f412130686 100644
--- a/drivers/input/keyboard/abov_touchkey_na7.c
+++ b/drivers/input/keyboard/abov_touchkey_na7.c
@@ -37,6 +37,9 @@
 #ifdef CONFIG_OF
 #include <linux/of_gpio.h>
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
 
 #define ABOV_TK_NAME "abov-touchkey"
 
@@ -146,6 +149,9 @@ struct abov_tk_info {
 	struct delayed_work led_twinkle_work;
 	bool led_twinkle_check;
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster *tkey_booster;
+#endif
 };
 
 struct abov_touchkey_devicetree_data {
@@ -293,6 +299,10 @@ static void release_all_fingers(struct abov_tk_info *info)
 	}
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->tkey_booster && info->tkey_booster->dvfs_set)
+		info->tkey_booster->dvfs_set(info->tkey_booster, 2);
+#endif
 }
 
 static int abov_tk_reset_for_bootmode(struct abov_tk_info *info)
@@ -425,9 +435,65 @@ static irqreturn_t abov_tk_interrupt(int irq, void *dev_id)
 #endif
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->tkey_booster && info->tkey_booster->dvfs_set)
+		info->tkey_booster->dvfs_set(info->tkey_booster, press);
+#endif
+
 	return IRQ_HANDLED;
 }
 
+#ifdef CONFIG_INPUT_BOOSTER
+static ssize_t boost_level_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct abov_tk_info *info = dev_get_drvdata(dev);
+	int val, stage;
+	struct dvfs value;
+
+	if (!info->tkey_booster) {
+		dev_err(&info->client->dev,
+			"%s: booster is NULL\n", __func__);
+		return count;
+	}
+
+	sscanf(buf, "%d", &val);
+
+	stage = 1 << val;
+
+	if (!(info->tkey_booster->dvfs_stage & stage)) {
+		dev_info(&info->client->dev,
+			"%s: wrong cmd %d\n", __func__, val);
+		return count;
+	}
+
+	info->tkey_booster->dvfs_boost_mode = stage;
+	dev_info(&info->client->dev,
+			"%s: dvfs_boost_mode = 0x%X\n",
+			__func__, info->tkey_booster->dvfs_boost_mode);
+
+	if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		if (info->tkey_booster->dvfs_set)
+			info->tkey_booster->dvfs_set(info->tkey_booster, 2);
+	} else if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_SINGLE) {
+		input_booster_get_default_setting("head", &value);
+		info->tkey_booster->dvfs_freq = value.cpu_freq;
+		dev_info(&info->client->dev,
+			"%s: boost_mode SINGLE, dvfs_freq = %d\n",
+			__func__, info->tkey_booster->dvfs_freq);
+	} else if (info->tkey_booster->dvfs_boost_mode == DVFS_STAGE_DUAL) {
+		input_booster_get_default_setting("tail", &value);
+		info->tkey_booster->dvfs_freq = value.cpu_freq;
+		dev_info(&info->client->dev,
+			"%s: boost_mode DUAL, dvfs_freq = %d\n",
+			__func__, info->tkey_booster->dvfs_freq);
+	}
+
+	return count;
+}
+#endif
+
 static int touchkey_led_set(struct abov_tk_info *info, int data)
 {
 	u8 cmd;
@@ -1231,6 +1297,10 @@ static DEVICE_ATTR(touchkey_firm_update_status, S_IRUGO | S_IWUSR | S_IWGRP,
 static DEVICE_ATTR(glove_mode, S_IRUGO | S_IWUSR | S_IWGRP,
 			abov_glove_mode_show, abov_glove_mode);
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+static DEVICE_ATTR(boost_level,
+		   S_IWUSR | S_IWGRP, NULL, boost_level_store);
+#endif
 
 static struct attribute *sec_touchkey_attributes[] = {
 	&dev_attr_touchkey_threshold.attr,
@@ -1246,6 +1316,9 @@ static struct attribute *sec_touchkey_attributes[] = {
 #ifdef GLOVE_MODE
 	&dev_attr_glove_mode.attr,
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	&dev_attr_boost_level.attr,
+#endif
 	NULL,
 };
 
@@ -1610,6 +1683,15 @@ static int abov_tk_probe(struct i2c_client *client,
 		goto err_reg_input_dev;
 	}
 
+#ifdef CONFIG_INPUT_BOOSTER
+	info->tkey_booster = input_booster_allocate(INPUT_BOOSTER_ID_TKEY);
+	if (!info->tkey_booster) {
+		dev_err(&client->dev,
+			"%s [ERROR] failed to allocate input booster\n", __func__);
+		goto err_alloc_booster_failed;
+	}
+#endif
+
 	info->enabled = true;
 
 	if (!info->dtdata->irq_flag) {
@@ -1663,6 +1745,11 @@ static int abov_tk_probe(struct i2c_client *client,
 	return 0;
 
 err_req_irq:
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->tkey_booster);
+	info->tkey_booster = NULL;
+err_alloc_booster_failed:
+#endif
 	input_unregister_device(input_dev);
 err_reg_input_dev:
 	mutex_destroy(&info->lock);
@@ -1714,6 +1801,10 @@ static int abov_tk_remove(struct i2c_client *client)
 		free_irq(info->irq, info);
 	input_unregister_device(info->input_dev);
 	input_free_device(info->input_dev);
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->tkey_booster);
+	info->tkey_booster = NULL;
+#endif
 	kfree(info);
 
 	return 0;
diff --git a/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_core.c b/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_core.c
index b8a6bff23fa8..252a3c1bf8ad 100755
--- a/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_core.c
+++ b/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_core.c
@@ -4984,6 +4984,9 @@ int cyttsp5_core_suspend(struct device *dev)
 		cyttsp5_core_sleep(cd, 1);
 	}
 
+#ifdef CONFIG_INPUT_BOOSTER
+	cd->md.finger_flag = false;
+#endif
 	if (gpio_is_valid(cd->pdata->core_pdata->ta_gpio))
 		gpio_set_value(cd->pdata->core_pdata->ta_gpio, 0);
 
diff --git a/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_mt_common.c b/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_mt_common.c
index 04ea759d907e..04fe96afae81 100755
--- a/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_mt_common.c
+++ b/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_mt_common.c
@@ -182,6 +182,11 @@ static void cyttsp5_report_slot_liftoff(struct cyttsp5_mt_data *md,
 		input_mt_report_slot_state(md->input,
 			MT_TOOL_FINGER, false);
 	}
+#ifdef CONFIG_INPUT_BOOSTER
+	if(md->finger_flag)
+		input_booster_send_event(BOOSTER_DEVICE_TOUCH, BOOSTER_MODE_FORCE_OFF);
+	md->finger_flag = false;
+#endif
 }
 
 static int cyttsp5_input_register_device(struct input_dev *input,
@@ -485,6 +490,14 @@ static void cyttsp5_get_mt_touches(struct cyttsp5_mt_data *md,
 				(tch->abs[CY_TCH_E] == CY_EV_TOUCHDOWN))
 				booster_status = true;
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+			if ((tch->abs[CY_TCH_O] != CY_OBJ_HOVER) &&
+				(tch->abs[CY_TCH_E] == CY_EV_TOUCHDOWN)) {
+				if(!md->finger_flag)
+					input_booster_send_event(BOOSTER_DEVICE_TOUCH, BOOSTER_MODE_ON);
+				md->finger_flag = true;
+			}
+#endif
 			if (tch->abs[CY_TCH_E] == CY_EV_LIFTOFF)
 				goto cyttsp5_get_mt_touches_pr_tch;
 
diff --git a/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_regs.h b/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_regs.h
index 65d4a80b17fc..3b57e3202565 100755
--- a/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_regs.h
+++ b/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_regs.h
@@ -48,6 +48,10 @@
 #include <linux/workqueue.h>
 #include <linux/cyttsp5_core.h>
 
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
+
 #define TTHE_TUNER_SUPPORT				1
 #define RTD_TUNER_SUPPORT				1
 #define SAMSUNG_FACTORY_TEST				1
@@ -741,6 +745,10 @@ struct cyttsp5_mt_data {
 		unsigned char boost_level;
 		int dvfs_freq;
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+		u8 finger_flag;
+#endif
+
 	bool input_device_registered;
 	char phys[NAME_MAX];
 	int num_prv_tch;
diff --git a/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_samsung_factory.c b/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_samsung_factory.c
index 691867cf1d31..b96018b78013 100755
--- a/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_samsung_factory.c
+++ b/drivers/input/touchscreen/cyttsp5_tma445a/cyttsp5_samsung_factory.c
@@ -90,6 +90,9 @@ static void report_rate(void *device_data);
 static void glove_mode(void *device_data);
 static void clear_cover_mode(void *device_data);
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data);
+#endif
 static void not_support_cmd(void *device_data);
 
 /************************************************************************
@@ -124,6 +127,9 @@ struct factory_cmd factory_cmds[] = {
 	{FACTORY_CMD("glove_mode", glove_mode),},
 	{FACTORY_CMD("clear_cover_mode", clear_cover_mode),},
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	{FACTORY_CMD("boost_level", boost_level),},
+#endif
 	{FACTORY_CMD("not_support_cmd", not_support_cmd),},
 };
 
@@ -1326,6 +1332,27 @@ static void not_support_cmd(void *device_data)
 	return;
 }
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data)
+{
+	struct cyttsp5_samsung_factory_data *sfd =
+		(struct cyttsp5_samsung_factory_data *) device_data;
+	int level;
+	char strbuff[FACTORY_CMD_RESULT_STR_LEN];
+	set_default_result(sfd);
+
+	level = sfd->factory_cmd_param[0];
+
+	change_booster_level_for_tsp(level);
+
+	snprintf(strbuff, sizeof(strbuff), "%s", "OK");
+	set_cmd_result(sfd, strbuff, (int)strnlen(strbuff, sizeof(strbuff)));
+	sfd->factory_cmd_state = FACTORYCMD_OK;
+	dev_info(sfd->dev, "%s: %s(%d)\n", __func__,
+			strbuff, (int)strnlen(strbuff, sizeof(strbuff)));
+	return;
+}
+#endif
 static ssize_t store_cmd(struct device *dev, struct device_attribute
 		*devattr, const char *buf, size_t count)
 {
diff --git a/drivers/input/touchscreen/imagis_30xxc/ist30xxc.c b/drivers/input/touchscreen/imagis_30xxc/ist30xxc.c
index a330efdfde46..c6bc1134793f 100755
--- a/drivers/input/touchscreen/imagis_30xxc/ist30xxc.c
+++ b/drivers/input/touchscreen/imagis_30xxc/ist30xxc.c
@@ -544,6 +544,12 @@ static void clear_input_data(struct ist30xx_data *data)
 	}
 #endif
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (data->tsp_booster && data->tsp_booster->dvfs_set)
+		data->tsp_booster->dvfs_set(data->tsp_booster, -1);
+	data->touch_pressed_num = 0;
+#endif
+
 	data->t_status = 0;
 }
 
@@ -867,6 +873,11 @@ static irqreturn_t ist30xx_irq_thread(int irq, void *ptr)
 	data->t_status = t_status;
 	report_input_data(data, finger_cnt, key_cnt);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (data->tsp_booster && data->tsp_booster->dvfs_set)
+		data->tsp_booster->dvfs_set(data->tsp_booster, !!data->touch_pressed_num);
+#endif
+
 	if (data->track_enable) {
 		if (intr_debug3_addr >= 0 && intr_debug3_size > 0) {
 			tsp_noti("Intr_debug3 (addr: 0x%08x)\n", intr_debug3_addr);
@@ -1723,6 +1734,15 @@ static int ist30xx_probe(struct i2c_client *client,
 	if (ret < 0)
 		goto err_irq;
 
+#ifdef CONFIG_INPUT_BOOSTER
+	tsp_info("input Booster\n");
+	data->tsp_booster = input_booster_allocate(INPUT_BOOSTER_ID_TSP);
+	if (!data->tsp_booster) {
+		tsp_err("%s booster allocation is failed\n", __func__);
+		goto err_irq;
+	}
+#endif
+
 	ret = ist30xx_init_update_sysfs(data);
 	if (unlikely(ret))
 		goto err_sysfs;
@@ -1814,6 +1834,10 @@ err_sec_sysfs:
 err_sysfs:
 	class_destroy(ist30xx_class);
 	input_unregister_device(input_dev);
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(data->tsp_booster);
+	data->tsp_booster = NULL;
+#endif
 err_irq:
 	tsp_info("ChipID: %x\n", data->chip_id);
 	ist30xx_disable_irq(data);
@@ -1863,6 +1887,10 @@ static int ist30xx_remove(struct i2c_client *client)
 		ist30xx_free_gpio(data);
 
 	input_unregister_device(data->input_dev);
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(data->tsp_booster);
+	data->tsp_booster = NULL;
+#endif
 	kfree(data);
 
 	return 0;
@@ -1890,6 +1918,10 @@ static void ist30xx_shutdown(struct i2c_client *client)
 	ist30xx_internal_suspend(data);
 	clear_input_data(data);
 	mutex_unlock(&ist30xx_mutex);
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(data->tsp_booster);
+	data->tsp_booster = NULL;
+#endif
 }
 
 static struct i2c_device_id ist30xx_idtable[] = {
diff --git a/drivers/input/touchscreen/imagis_30xxc/ist30xxc.h b/drivers/input/touchscreen/imagis_30xxc/ist30xxc.h
index 7dbd7a962b35..afb2ec9a8804 100755
--- a/drivers/input/touchscreen/imagis_30xxc/ist30xxc.h
+++ b/drivers/input/touchscreen/imagis_30xxc/ist30xxc.h
@@ -17,6 +17,9 @@
 #define __IST30XXC_H__
 
 #include <linux/input/tsp_ta_callback.h>
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
 
 /*
  * Support F/W ver : IST30xxC v1.0.0.0
@@ -505,6 +508,9 @@ struct ist30xx_data {
 	bool gesture;
 #endif
 	int touch_pressed_num;
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster *tsp_booster;
+#endif
 	int scan_count;
 	int scan_retry;
 	int max_scan_retry;
diff --git a/drivers/input/touchscreen/imagis_30xxc_cmcs/ist30xxc.c b/drivers/input/touchscreen/imagis_30xxc_cmcs/ist30xxc.c
index 74b85f8ebcac..cb96d5f80c7c 100644
--- a/drivers/input/touchscreen/imagis_30xxc_cmcs/ist30xxc.c
+++ b/drivers/input/touchscreen/imagis_30xxc_cmcs/ist30xxc.c
@@ -563,6 +563,12 @@ static void clear_input_data(struct ist30xx_data *data)
 	}
 #endif
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (data->tsp_booster && data->tsp_booster->dvfs_set)
+		data->tsp_booster->dvfs_set(data->tsp_booster, -1);
+	data->touch_pressed_num = 0;
+#endif
+
 	data->t_status = 0;
 }
 
@@ -971,6 +977,11 @@ static irqreturn_t ist30xx_irq_thread(int irq, void *ptr)
 	data->t_status = t_status;
 	report_input_data(data, finger_cnt, key_cnt);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (data->tsp_booster && data->tsp_booster->dvfs_set)
+		data->tsp_booster->dvfs_set(data->tsp_booster, !!data->touch_pressed_num);
+#endif
+
 	if (data->track_enable) {
 		if (intr_debug3_addr >= 0 && intr_debug3_size > 0) {
 			tsp_noti("Intr_debug3 (addr: 0x%08x)\n", intr_debug3_addr);
@@ -1827,6 +1838,15 @@ static int ist30xx_probe(struct i2c_client *client,
 	if (ret < 0)
 		goto err_irq;
 
+#ifdef CONFIG_INPUT_BOOSTER
+	tsp_info("input Booster\n");
+	data->tsp_booster = input_booster_allocate(INPUT_BOOSTER_ID_TSP);
+	if (!data->tsp_booster) {
+		tsp_err("%s booster allocation is failed\n", __func__);
+		goto err_irq;
+	}
+#endif
+
 	ret = ist30xx_init_update_sysfs(data);
 	if (unlikely(ret))
 		goto err_sysfs;
@@ -1909,6 +1929,10 @@ err_sec_sysfs:
 err_sysfs:
 	class_destroy(ist30xx_class);
 	input_unregister_device(input_dev);
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(data->tsp_booster);
+	data->tsp_booster = NULL;
+#endif
 err_irq:
 	tsp_info("ChipID: %x\n", data->chip_id);
 	ist30xx_disable_irq(data);
@@ -1958,6 +1982,10 @@ static int ist30xx_remove(struct i2c_client *client)
 		ist30xx_free_gpio(data);
 
 	input_unregister_device(data->input_dev);
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(data->tsp_booster);
+	data->tsp_booster = NULL;
+#endif
 	kfree(data);
 
 	return 0;
@@ -1985,6 +2013,10 @@ static void ist30xx_shutdown(struct i2c_client *client)
 	ist30xx_internal_suspend(data);
 	clear_input_data(data);
 	mutex_unlock(&ist30xx_mutex);
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(data->tsp_booster);
+	data->tsp_booster = NULL;
+#endif
 }
 
 static struct i2c_device_id ist30xx_idtable[] = {
diff --git a/drivers/input/touchscreen/imagis_30xxc_cmcs/ist30xxc.h b/drivers/input/touchscreen/imagis_30xxc_cmcs/ist30xxc.h
index c3c00de8ef47..88e965450d0e 100644
--- a/drivers/input/touchscreen/imagis_30xxc_cmcs/ist30xxc.h
+++ b/drivers/input/touchscreen/imagis_30xxc_cmcs/ist30xxc.h
@@ -17,6 +17,9 @@
 #define __IST30XXC_H__
 
 #include <linux/input/tsp_ta_callback.h>
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
 
 /*
  * Support F/W ver : IST30xxC v1.0.0.0
@@ -512,6 +515,9 @@ struct ist30xx_data {
 	bool gesture;
 #endif
 	int touch_pressed_num;
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster *tsp_booster;
+#endif
 	int scan_count;
 	int scan_retry;
 	int max_scan_retry;
diff --git a/drivers/input/touchscreen/melfas_mms400/melfas_mms400.c b/drivers/input/touchscreen/melfas_mms400/melfas_mms400.c
index a5c04cd57440..6b99429a6f16 100755
--- a/drivers/input/touchscreen/melfas_mms400/melfas_mms400.c
+++ b/drivers/input/touchscreen/melfas_mms400/melfas_mms400.c
@@ -234,6 +234,11 @@ int mms_disable(struct mms_ts_info *info)
 
 	mutex_unlock(&info->lock);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_off(info->booster);
+#endif
+
 	dev_err(&info->client->dev, "%s [DONE]\n", __func__);
 	return 0;
 }
@@ -954,6 +959,15 @@ static int mms_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		goto err_input_register_device;
 	}
 
+#ifdef CONFIG_INPUT_BOOSTER
+	info->booster = input_booster_allocate(INPUT_BOOSTER_ID_TSP);
+	if (!info->booster) {
+		dev_err(&client->dev,
+				"%s [ERROR] failed to allocate input booster\n", __func__);
+		goto error_alloc_booster_failed;
+	}
+#endif
+
 	mms_power_control(info, 1);
 
 #if MMS_USE_AUTO_FW_UPDATE
@@ -1063,6 +1077,11 @@ err_test_dev_create:
 	free_irq(info->irq, info);
 err_request_irq:
 error_fw_update:
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->booster);
+	info->booster = NULL;
+error_alloc_booster_failed:
+#endif
 	input_unregister_device(info->input_dev);
 	info->input_dev = NULL;
 err_input_register_device:
diff --git a/drivers/input/touchscreen/melfas_mms400/melfas_mms400.h b/drivers/input/touchscreen/melfas_mms400/melfas_mms400.h
index be580bc42bfc..241a3c175021 100755
--- a/drivers/input/touchscreen/melfas_mms400/melfas_mms400.h
+++ b/drivers/input/touchscreen/melfas_mms400/melfas_mms400.h
@@ -39,6 +39,10 @@
 #include "melfas_mms400_reg.h"
 #include <linux/input/tsp_ta_callback.h>
 
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
+
 #ifdef CONFIG_OF
 #define MMS_USE_DEVICETREE		1
 #else
@@ -208,6 +212,9 @@ struct mms_ts_info {
 	struct tsp_callbacks callbacks;
 #endif
 
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster *booster;
+#endif
 #ifdef CONFIG_TOUCHSCREEN_DUMP_MODE
 	struct delayed_work ghost_check;
 	u8 tsp_dump_lock;
diff --git a/drivers/input/touchscreen/melfas_mms400/melfas_mms400_cmd.c b/drivers/input/touchscreen/melfas_mms400/melfas_mms400_cmd.c
index 4d4235cf9395..c2073e6ed241 100755
--- a/drivers/input/touchscreen/melfas_mms400/melfas_mms400_cmd.c
+++ b/drivers/input/touchscreen/melfas_mms400/melfas_mms400_cmd.c
@@ -772,6 +772,57 @@ EXIT:
 
 
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void cmd_boost_level(void *device_data)
+{
+	struct mms_ts_info *info = (struct mms_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	int stage;
+	char buf[64] = { 0 };
+
+	cmd_clear_result(info);
+
+	stage = 1 << info->cmd_param[0];
+
+	dev_err(&client->dev, "%s,%d(%x)\n", __func__, info->cmd_param[0], stage);
+
+	if (!(info->booster)) {
+		sprintf(buf, "%s", "NG");
+		info->cmd_state = CMD_STATUS_FAIL;
+		dev_err(&info->client->dev," %s, booster is null \n", __func__);
+		goto out;
+	}
+
+	if (!(info->booster->dvfs_stage & stage)) {
+		sprintf(buf, "%s", "NG");
+		info->cmd_state = CMD_STATUS_FAIL;
+		dev_err(&info->client->dev,
+				"%s: %d is not in supported stage[%x].\n",
+				__func__, info->cmd_param[0], info->booster->dvfs_stage);
+		goto out;
+	}
+
+	info->booster->dvfs_boost_mode = stage;
+	input_booster_set_level_change(info->cmd_param[0]);
+	sprintf(buf, "%s", "OK");
+	info->cmd_state = CMD_STATUS_OK;
+
+	if (info->booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		if (info->booster->dvfs_set)
+			info->booster->dvfs_set(info->booster, -1);
+	}
+
+out:
+	cmd_set_result(info, buf, strnlen(buf, sizeof(buf)));
+
+	mutex_lock(&info->lock);
+	info->cmd_busy = false;
+	mutex_unlock(&info->lock);
+
+	info->cmd_state = CMD_STATUS_WAITING;
+}
+#endif
+
 static void get_intensity_all_data(void *device_data)
 {
 	struct mms_ts_info *info = (struct mms_ts_info *)device_data;
@@ -1000,6 +1051,9 @@ static struct mms_cmd mms_commands[] = {
 	{MMS_CMD("get_cm_abs", cmd_get_cm_abs),},
 	{MMS_CMD("get_config_ver", cmd_get_config_ver),},
 	{MMS_CMD("get_threshold", cmd_get_threshold),},
+#ifdef CONFIG_INPUT_BOOSTER
+	{MMS_CMD("boost_level", cmd_boost_level),},
+#endif
 	{MMS_CMD("get_intensity_all_data", get_intensity_all_data),},
 	{MMS_CMD("get_rawdata_all_data", get_rawdata_all_data),},
 	{MMS_CMD("get_cm_delta_all_data", get_cm_delta_all_data),},
diff --git a/drivers/input/touchscreen/melfas_mms400/melfas_mms400_mod.c b/drivers/input/touchscreen/melfas_mms400/melfas_mms400_mod.c
index 16de4df5dea0..aa1b089720fa 100755
--- a/drivers/input/touchscreen/melfas_mms400/melfas_mms400_mod.c
+++ b/drivers/input/touchscreen/melfas_mms400/melfas_mms400_mod.c
@@ -83,6 +83,10 @@ void mms_clear_input(struct mms_ts_info *info)
 
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, -1);
+#endif
 }
 
 /**
@@ -221,6 +225,12 @@ void mms_input_event_handler(struct mms_ts_info *info, u8 sz, u8 *buf)
 		}
 	}
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, info->touch_count);
+#endif
+
+
 	dev_dbg(&client->dev, "%s [DONE]\n", __func__);
 	return;
 }
diff --git a/drivers/input/touchscreen/mms300.c b/drivers/input/touchscreen/mms300.c
index 8896af78fd66..4776b26dc622 100644
--- a/drivers/input/touchscreen/mms300.c
+++ b/drivers/input/touchscreen/mms300.c
@@ -57,6 +57,9 @@
 
 #include <asm/unaligned.h>
 
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
 #define TSP_GLOVE_MODE
 #define TSP_SVIEW_COVER_MODE
 #define COVER_OPEN 0
@@ -395,6 +398,11 @@ struct mms_ts_info {
 	void (*input_event)(void *data);
 	const char* fw_path;
 
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster	*booster;
+#endif
+
+
 #ifdef TSP_GESTURE_MODE
 	bool lowpower_mode;
 	int lowpower_flag;
@@ -551,6 +559,10 @@ static void direct_indicator_enable(void *device_data);
 static void set_lowpower_mode(void *device_data);
 #endif
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data);
+#endif
+
 #ifdef TSP_GLOVE_MODE
 static void glove_mode(void *device_data);
 #endif
@@ -591,6 +603,9 @@ struct tsp_cmd tsp_cmds[] = {
 	{TSP_CMD("set_lowpower_mode", set_lowpower_mode),},
 #endif
 	{TSP_CMD("not_support_cmd", not_support_cmd),},
+#ifdef CONFIG_INPUT_BOOSTER
+        {TSP_CMD("boost_level", boost_level),},
+#endif
 #ifdef TSP_GLOVE_MODE
 	 {TSP_CMD("glove_mode", glove_mode),},
 #endif
@@ -638,6 +653,10 @@ static void release_all_fingers(struct mms_ts_info *info)
 	}
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, 0);
+#endif
 }
 
 static void mms_set_noise_mode(struct mms_ts_info *info)
@@ -1111,6 +1130,11 @@ static irqreturn_t mms_ts_interrupt(int irq, void *dev_id)
 	}
 	input_sync(info->input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, touch_is_pressed);
+#endif
+
 out:
 	mutex_unlock(&info->lock);
 	return IRQ_HANDLED;
@@ -1917,6 +1941,53 @@ static void clear_cover_mode(void *device_data)
 }
 #endif
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data)
+{
+	struct mms_ts_info *info = (struct mms_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	char buff[16] = {0};
+	int stage;
+
+	dev_info(&client->dev, "%s\n", __func__);
+
+	set_default_result(info);
+
+
+	stage = 1 << info->cmd_param[0];
+	if (!(info->booster->dvfs_stage & stage)) {
+		snprintf(buff, sizeof(buff), "NG");
+		info->cmd_state = FAIL;
+		dev_err(&info->client->dev,"%s: %d is not supported(%04x != %04x).\n",__func__,
+			info->cmd_param[0], stage, info->booster->dvfs_stage);
+
+		goto boost_out;
+	}
+
+	info->booster->dvfs_boost_mode = stage;
+	snprintf(buff, sizeof(buff), "OK");
+	info->cmd_state = OK;
+
+	if (info->booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		if (info->booster && info->booster->dvfs_set)
+			info->booster->dvfs_set(info->booster, -1);
+	}
+
+	boost_out:
+
+	set_cmd_result(info, buff,
+			strnlen(buff, sizeof(buff)));
+
+	mutex_lock(&info->cmd_lock);
+	info->cmd_is_running = false;
+	mutex_unlock(&info->cmd_lock);
+
+	info->cmd_state = WAITING;
+
+	return;
+}
+#endif
+
 #ifdef MMS300_DOWNLOAD
 static int get_fw_ver(struct i2c_client *client, u8 *buf)
 {
@@ -5306,6 +5377,12 @@ static void mms_ts_input_close(struct input_dev *dev)
 	// mms_pinctrl_configure(info, false, false);
 	}
 
+#ifdef CONFIG_INPUT_BOOSTER
+	dev_info(&info->client->dev, "%s force dvfs off\n", __func__);
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, -1);
+#endif
+
 	return;
 //TEST
 //	mms_ts_suspend(&info->client->dev);
@@ -5559,6 +5636,13 @@ static int mms_ts_probe(struct i2c_client *client,
 		goto err_reg_input_dev;
 	}
 
+#ifdef CONFIG_INPUT_BOOSTER
+	info->booster = input_booster_allocate(INPUT_BOOSTER_ID_TSP);
+	if (!info->booster) {
+		dev_err(&client->dev, "%s: Error, failed to allocate input booster\n",__func__);
+		goto error_alloc_booster_failed;
+	}
+#endif
 	info->enabled = true;
 
 	client->irq = gpio_to_irq(pdata->gpio_int);
@@ -5688,6 +5772,12 @@ static int mms_ts_probe(struct i2c_client *client,
 err_req_irq:
 	input_unregister_device(input_dev);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->booster);
+	info->booster = NULL;
+error_alloc_booster_failed:
+#endif
+
 err_reg_input_dev:
 	info->power(info,0);
 #ifdef TOUCHKEY
diff --git a/drivers/input/touchscreen/mxt1188s/mxts_1188s.c b/drivers/input/touchscreen/mxt1188s/mxts_1188s.c
index a7a3bce81d72..818c9166faf5 100644
--- a/drivers/input/touchscreen/mxt1188s/mxts_1188s.c
+++ b/drivers/input/touchscreen/mxt1188s/mxts_1188s.c
@@ -997,6 +997,17 @@ static void mxt_report_input_data(struct mxt_data *data)
 			input_sync(data->input_dev);
 	}
 
+#ifdef CONFIG_INPUT_BOOSTER
+		if (count){
+			if (data->tsp_booster && data->tsp_booster->dvfs_set)
+				data->tsp_booster->dvfs_set(data->tsp_booster,count);
+		}
+		else{
+			if (data->tsp_booster && data->tsp_booster->dvfs_set)
+				data->tsp_booster->dvfs_set(data->tsp_booster,0);
+		}
+#endif
+
 	data->finger_mask = 0;
 }
 
@@ -2223,6 +2234,11 @@ static int mxt_stop(struct mxt_data *data)
 #if ENABLE_TOUCH_KEY
 	mxt_release_all_keys(data);
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+if (data->tsp_booster && data->tsp_booster->dvfs_set)
+	data->tsp_booster->dvfs_set(data->tsp_booster, -1);
+#endif
+
 	data->mxt_enabled = false;
 
 	return 0;
@@ -2881,6 +2897,15 @@ static int  mxt_probe(struct i2c_client *client,
 	data->mxt_enabled = true;
 */
 
+#ifdef CONFIG_INPUT_BOOSTER
+	printk("TSP COMMON_INPUT_BOOSTER init\n");
+	data->tsp_booster =   input_booster_allocate(INPUT_BOOSTER_ID_TSP);
+	if (!data->tsp_booster) {
+		dev_err(&client->dev, "%s: Error, failed to allocate input booster\n",__func__);
+		goto err_get_tsp_booster;
+	}
+#endif
+
 	error = mxt_touch_init(data, MXT_FIRMWARE_UPDATE_TYPE);
 	if (error) {
 		dev_err(&client->dev, "Failed to init driver\n");
@@ -2922,6 +2947,11 @@ err_touch_init:
 /*
 err_power_on:
 */
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(data->tsp_booster);
+	data->tsp_booster = NULL;
+err_get_tsp_booster:
+#endif
 	mxt_sysfs_remove(data);
 err_sysfs_init:
 	input_unregister_device(input_dev);
diff --git a/drivers/input/touchscreen/mxt1188s/mxts_sec_1188s.c b/drivers/input/touchscreen/mxt1188s/mxts_sec_1188s.c
index e551435f0a8d..0686bacacb32 100644
--- a/drivers/input/touchscreen/mxt1188s/mxts_sec_1188s.c
+++ b/drivers/input/touchscreen/mxt1188s/mxts_sec_1188s.c
@@ -1560,6 +1560,59 @@ struct tsp_cmd {
 	void			(*cmd_func)(void *device_data);
 };
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data)
+{
+	struct mxt_data *data = (struct mxt_data *)device_data;
+	struct i2c_client *client = data->client;
+	struct mxt_fac_data *fdata = data->fdata;
+	char buff[16] = {0};
+
+	int stage;
+	dev_info(&client->dev, "%s\n", __func__);
+
+	set_default_result(fdata);
+
+	stage = 1 << fdata->cmd_param[0];
+
+	if(!(data->tsp_booster)){
+		sprintf(buff, "%s", "NG");
+		fdata->cmd_state = CMD_STATUS_FAIL;
+		dev_err(&data->client->dev," %s, booster is null \n", __func__);
+		goto out;
+	}
+	if (!(data->tsp_booster->dvfs_stage & data->tsp_booster->dvfs_boost_mode)) {
+		sprintf(buff, "%s", "NG");
+		fdata->cmd_state = CMD_STATUS_FAIL;
+		dev_err(&data->client->dev,
+			"%s: %d is not in supported stage[%x].\n",
+			__func__, fdata->cmd_param[0], data->tsp_booster->dvfs_stage);
+		goto out;
+	}
+	data->tsp_booster->dvfs_boost_mode = stage;
+	dev_info(&client->dev, "%s: dvfs_boost_mode = %d(%x)\n",
+			__func__, data->tsp_booster->dvfs_boost_mode,stage);
+	input_booster_set_level_change(fdata->cmd_param[0]);
+	snprintf(buff, sizeof(buff), "OK");
+	fdata->cmd_state = CMD_STATUS_OK;
+
+	if (data->tsp_booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		if (data->tsp_booster->dvfs_set)
+			data->tsp_booster->dvfs_set(data->tsp_booster, -1);	
+	}
+out:
+	set_cmd_result(fdata, buff, strnlen(buff, sizeof(buff)));
+
+	mutex_lock(&fdata->cmd_lock);
+	fdata->cmd_is_running = false;
+	mutex_unlock(&fdata->cmd_lock);
+
+	fdata->cmd_state = CMD_STATUS_WAITING;
+
+	return;
+}
+#endif
+
 static struct tsp_cmd tsp_cmds[] = {
 	{TSP_CMD("fw_update", fw_update),},
 	{TSP_CMD("get_fw_ver_bin", get_fw_ver_bin),},
@@ -1589,6 +1642,9 @@ static struct tsp_cmd tsp_cmds[] = {
 	{TSP_CMD("set_tk_threshold", set_tk_threshold),},
 #endif
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	{TSP_CMD("boost_level", boost_level),},
+#endif
 #if TSP_PATCH
 	{TSP_CMD("patch_update", patch_update),},
 #endif
diff --git a/drivers/input/touchscreen/mxt_t/mxtt.c b/drivers/input/touchscreen/mxt_t/mxtt.c
index ebba48fa4cf1..ff70439aed68 100644
--- a/drivers/input/touchscreen/mxt_t/mxtt.c
+++ b/drivers/input/touchscreen/mxt_t/mxtt.c
@@ -776,6 +776,15 @@ static void mxt_report_input_data(struct mxt_data *data)
 #endif
 			input_sync(data->input_dev);
 	}
+#ifdef COMMON_INPUT_BOOSTER
+		if (count){
+			data->tsp_booster->dvfs_set(data->tsp_booster,count);
+		}
+		else{
+			data->tsp_booster->dvfs_set(data->tsp_booster, -1);
+		}
+#endif
+
 
 	data->finger_mask = 0;
 }
@@ -2240,6 +2249,10 @@ static int mxt_stop(struct mxt_data *data)
 #if ENABLE_TOUCH_KEY
 	mxt_release_all_keys(data);
 #endif
+#ifdef COMMON_INPUT_BOOSTER
+	if(data->tsp_booster)
+		data->tsp_booster->dvfs_set(data->tsp_booster, -1);
+#endif
 	return 0;
 
 err_power_off:
@@ -3095,6 +3108,23 @@ static int  mxt_probe(struct i2c_client *client,
 	else
 		printk("TSP interrupt registered successfully\n");
 
+#ifdef COMMON_INPUT_BOOSTER
+	printk("TSP COMMON_INPUT_BOOSTER init\n");
+
+	data->touch_pressed_num = 0;
+	data->tsp_booster = kzalloc(sizeof(struct input_booster), GFP_KERNEL);
+	if (!data->tsp_booster) {
+		dev_err(&client->dev,
+			"%s: Failed to alloc mem for tsp_booster\n", __func__);
+		error = -ENOMEM;
+		goto err_get_tsp_booster;
+	} else {
+		input_booster_init_dvfs(data->tsp_booster, INPUT_BOOSTER_ID_TSP);
+	}
+#endif
+
+
+
 #ifdef CONFIG_HAS_EARLYSUSPEND
 	data->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
 	data->early_suspend.suspend = mxt_early_suspend;
@@ -3104,6 +3134,10 @@ static int  mxt_probe(struct i2c_client *client,
 
 	return 0;
 	
+#ifdef COMMON_INPUT_BOOSTER
+	kfree(data->tsp_booster);
+err_get_tsp_booster:
+#endif
 	free_irq(client->irq,data);
 err_req_irq:
 err_touch_init:
diff --git a/drivers/input/touchscreen/mxt_t/mxtt_sec.c b/drivers/input/touchscreen/mxt_t/mxtt_sec.c
index 63348ae65289..0aa8ae6a9fa9 100644
--- a/drivers/input/touchscreen/mxt_t/mxtt_sec.c
+++ b/drivers/input/touchscreen/mxt_t/mxtt_sec.c
@@ -1565,6 +1565,33 @@ static void set_tk_threshold(void *device_data)
 #endif
 #endif
 
+#if defined(COMMON_INPUT_BOOSTER)
+static void boost_level(void *device_data)
+{
+	struct mxt_data *data = (struct mxt_data *)device_data;
+	struct i2c_client *client = data->client;
+	struct mxt_fac_data *fdata = data->fdata;
+	char buff[16] = {0};
+	set_default_result(fdata);
+
+	if (fdata->cmd_param[0] < 0 && fdata->cmd_param[0]!= DVFS_STAGE_NONE && fdata->cmd_param[0]!= DVFS_STAGE_SINGLE &&
+		fdata->cmd_param[0]!= DVFS_STAGE_DUAL && fdata->cmd_param[0]&& DVFS_STAGE_TRIPLE && fdata->cmd_param[0]!= DVFS_STAGE_PENTA &&
+		fdata->cmd_param[0]!= DVFS_STAGE_NINTH) {
+		snprintf(buff, sizeof(buff), "%s", "NG");
+		fdata->cmd_state = CMD_STATUS_FAIL;
+	} else {
+		data->tsp_booster->dvfs_boost_mode= fdata->cmd_param[0];
+		tsp_debug_dbg(false, &client->dev, "%s %d\n", __func__, fdata->cmd_param[0]);
+		snprintf(buff, sizeof(buff), "%s", "OK");
+		fdata->cmd_state = CMD_STATUS_OK;
+	}
+
+	tsp_debug_info(true, &client->dev, "%s: %s(%d)\n",
+		__func__, buff, strnlen(buff, sizeof(buff)));
+
+	return;
+}
+#endif
 /* - function realted samsung factory test */
 
 #define TSP_CMD(name, func) .cmd_name = name, .cmd_func = func
@@ -1607,6 +1634,9 @@ static struct tsp_cmd tsp_cmds[] = {
 #if TSP_PATCH
 	{TSP_CMD("patch_update", patch_update),},
 #endif
+#if defined(COMMON_INPUT_BOOSTER)
+	{TSP_CMD("boost_level", boost_level),},
+#endif
 	{TSP_CMD("get_checksum_data", get_checksum_data),},
 
 	{TSP_CMD("not_support_cmd", not_support_cmd),},
diff --git a/drivers/input/touchscreen/sec_ts/sec_ts.h b/drivers/input/touchscreen/sec_ts/sec_ts.h
index 39dd81f8d1ed..bbff70ad93e8 100644
--- a/drivers/input/touchscreen/sec_ts/sec_ts.h
+++ b/drivers/input/touchscreen/sec_ts/sec_ts.h
@@ -16,6 +16,9 @@
 #ifdef CONFIG_SEC_DEBUG_TSP_LOG
 #include <linux/sec_debug.h>
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
 #include <linux/completion.h>
 #include <linux/wakelock.h>
 #include <linux/input/sec_cmd.h>
diff --git a/drivers/input/touchscreen/zinitix_bt532/zinitix_bt532_ts.c b/drivers/input/touchscreen/zinitix_bt532/zinitix_bt532_ts.c
index f81c71aa277b..bea6d47d3b4d 100755
--- a/drivers/input/touchscreen/zinitix_bt532/zinitix_bt532_ts.c
+++ b/drivers/input/touchscreen/zinitix_bt532/zinitix_bt532_ts.c
@@ -46,6 +46,10 @@
 #include <linux/of_device.h>
 #include <linux/of_gpio.h>
 
+#ifdef CONFIG_COMMON_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
+
 #include <linux/of_irq.h>
 #include <asm/io.h>
 #include <linux/power_supply.h>
@@ -377,6 +381,9 @@ static void get_delta(void *device_data);
 static void clear_cover_mode(void *device_data);
 static void get_module_vendor(void *device_data);
 static void get_config_ver(void *device_data);
+#if defined(COMMON_INPUT_BOOSTER)
+static void boost_level(void *device_data);
+#endif
 #if defined(USE_ACTIVE_REPORT_RATE)
 static void report_rate(void *device_data);
 #endif
@@ -421,6 +428,9 @@ static struct tsp_cmd tsp_cmds[] = {
 	{TSP_CMD("get_delta", get_delta),},
 	{TSP_CMD("get_config_ver", get_config_ver),},
 	{TSP_CMD("clear_cover_mode", clear_cover_mode),},
+#if defined(COMMON_INPUT_BOOSTER)
+	{TSP_CMD("boost_level", boost_level),},
+#endif
 #if defined(USE_ACTIVE_REPORT_RATE)
 	{TSP_CMD("report_rate", report_rate),},
 #endif
@@ -634,6 +644,9 @@ struct bt532_ts_info {
 	void (*register_cb)(struct tsp_callbacks *);
 	struct tsp_callbacks callbacks;
 #endif
+#ifdef COMMON_INPUT_BOOSTER
+	struct input_booster *tsp_booster;
+#endif
 };
 /* Dummy touchkey code */
 #define KEY_DUMMY_HOME1		249
@@ -2290,6 +2303,35 @@ static inline void set_cmd_result(struct bt532_ts_info *info, char *buff, int le
 static inline void set_default_result(struct bt532_ts_info *info);
 #endif
 
+#if defined(COMMON_INPUT_BOOSTER)
+static void boost_level(void *device_data)
+{
+	struct bt532_ts_info *info = (struct bt532_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+
+	char buff[16] = {0};
+	set_default_result(info);
+
+	if (finfo->cmd_param[0] < 0 && finfo->cmd_param[0]!= DVFS_STAGE_NONE && finfo->cmd_param[0]!= DVFS_STAGE_SINGLE &&
+		finfo->cmd_param[0]!= DVFS_STAGE_DUAL && finfo->cmd_param[0]&& DVFS_STAGE_TRIPLE && finfo->cmd_param[0]!= DVFS_STAGE_PENTA &&
+		finfo->cmd_param[0]!= DVFS_STAGE_NINTH) {
+		snprintf(buff, sizeof(buff), "%s", "NG");
+		finfo->cmd_state = FAIL;
+	} else {
+		info->tsp_booster->dvfs_boost_mode= finfo->cmd_param[0];
+		dev_info(&client->dev, "%s %d\n", __func__, finfo->cmd_param[0]);
+		snprintf(buff, sizeof(buff), "%s", "OK");
+		finfo->cmd_state = OK;
+	}
+
+	dev_info(&client->dev, "%s: %s(%d)\n",
+		__func__, buff, strnlen(buff, sizeof(buff)));
+
+	return;
+}
+#endif
+
 static void clear_report_data(struct bt532_ts_info *info)
 {
 	int i;
@@ -2327,6 +2369,9 @@ static void clear_report_data(struct bt532_ts_info *info)
 		input_sync(info->input_dev);
 
 	info->finger_cnt1=0;
+#ifdef COMMON_INPUT_BOOSTER
+	info->tsp_booster->dvfs_set(info->tsp_booster,-1);
+#endif
 }
 #if 0
 static bool bt532_touch_key_force_release(struct bt532_ts_info *info)
@@ -2594,6 +2639,13 @@ static irqreturn_t bt532_touch_work(int irq, void *data)
 	input_sync(info->input_dev);
 
 out:
+#ifdef COMMON_INPUT_BOOSTER
+	if (info->finger_cnt1){
+		info->tsp_booster->dvfs_set(info->tsp_booster, info->finger_cnt1);
+	} else {
+		info->tsp_booster->dvfs_set(info->tsp_booster, -1);
+	}
+#endif
 
 	if (info->work_state == NORMAL) {
 #if ESD_TIMER_INTERVAL
@@ -5983,6 +6035,17 @@ static int bt532_ts_probe(struct i2c_client *client,
 	}
 #endif
 
+#ifdef COMMON_INPUT_BOOSTER
+	printk("TSP COMMON_INPUT_BOOSTER init\n");
+	info->tsp_booster = kzalloc(sizeof(struct input_booster), GFP_KERNEL);
+	if (!info->tsp_booster) {
+		dev_err(&client->dev,
+			"%s: Failed to alloc mem for tsp_booster\n", __func__);
+		goto err_get_tsp_booster;
+	} else {
+		input_booster_init_dvfs(info->tsp_booster, INPUT_BOOSTER_ID_TSP);
+	}
+#endif
 	/* configure irq */
 	info->irq = gpio_to_irq(pdata->gpio_int);
 	if (info->irq < 0){
@@ -6043,6 +6106,10 @@ err_kthread_create_failed:
 err_misc_register:
 	free_irq(info->irq, info);
 err_irq_of_parse:
+#ifdef COMMON_INPUT_BOOSTER
+	kfree(info->tsp_booster);
+err_get_tsp_booster:
+#endif
 err_request_irq:
 	input_unregister_device(info->input_dev);
 err_input_register_device:
diff --git a/drivers/input/touchscreen/zinitix_j1/bt432.c b/drivers/input/touchscreen/zinitix_j1/bt432.c
index ef38b5055d11..6d43bdaec12c 100755
--- a/drivers/input/touchscreen/zinitix_j1/bt432.c
+++ b/drivers/input/touchscreen/zinitix_j1/bt432.c
@@ -80,6 +80,10 @@ struct cpufreq_limit_handle *min_handle = NULL;
 static const unsigned long touch_cpufreq_lock = 1200000;
 #endif
 
+#ifdef CONFIG_COMMON_INPUT_BOOSTER
+//to enabled common touch booster. This must be included.
+#include <linux/input/input_booster.h>
+#endif
 #ifdef SUPPORTED_PALM_TOUCH
 #define TOUCH_POINT_MODE			2
 #else
@@ -679,6 +683,10 @@ struct bt432_ts_info {
 #if TOUCH_BOOSTER
 	u8							finger_cnt;
 #endif
+#ifdef COMMON_INPUT_BOOSTER	
+	u8 touch_pressed_num;
+	struct input_booster *tsp_booster;
+#endif
 };
 /* Dummy touchkey code */
 #define KEY_DUMMY_HOME1	249
@@ -2588,6 +2596,9 @@ static irqreturn_t bt432_touch_work(int irq, void *data)
 				}
 				info->finger_cnt++;
 #endif
+#ifdef COMMON_INPUT_BOOSTER		
+			info->touch_pressed_num++;			
+#endif 
 #if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
 				dev_info(&client->dev, "Finger [%02d] x = %d, y = %d,"
 								" w = %d\n", i, x, y, w);
@@ -2649,6 +2660,9 @@ static irqreturn_t bt432_touch_work(int irq, void *data)
 				dev_info(&client->dev, "cpu freq off\n");
 			}
 #endif
+#ifdef COMMON_INPUT_BOOSTER		
+			info->touch_pressed_num--;				
+#endif 
 #if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
 			dev_info(&client->dev, "Finger [%02d] up\n", i);
 #else
@@ -2666,6 +2680,14 @@ static irqreturn_t bt432_touch_work(int irq, void *data)
 	memcpy((char *)&info->reported_touch_info, (char *)&info->touch_info,
 			sizeof(struct point_info));
 	input_sync(info->input_dev);
+#ifdef COMMON_INPUT_BOOSTER	
+	if (info->touch_pressed_num){
+		info->tsp_booster->dvfs_set(info->tsp_booster,info->touch_pressed_num);
+		} else {
+		info->tsp_booster->dvfs_set(info->tsp_booster,-1);		
+	}
+	
+#endif
 out:
 	if (info->work_state == NORMAL) {
 #if ESD_TIMER_INTERVAL
@@ -2861,6 +2883,10 @@ static void bt432_ts_close(struct input_dev *dev)
 	info->work_state = EALRY_SUSPEND;
 
 	clear_report_data(info);
+#ifdef COMMON_INPUT_BOOSTER	
+	info->tsp_booster->dvfs_set(info->tsp_booster,-1);
+	info->touch_pressed_num = 0;
+#endif
 
 #if ESD_TIMER_INTERVAL
 	/*write_reg(info->client, BT432_PERIODICAL_INTERRUPT_INTERVAL, 0);*/
@@ -6185,6 +6211,18 @@ static int bt432_ts_probe(struct i2c_client *client,
 #if TOUCH_BOOSTER
 	info->finger_cnt = 0;
 #endif
+#ifdef COMMON_INPUT_BOOSTER
+	printk("TSP COMMON_INPUT_BOOSTER init\n");
+	info->touch_pressed_num = 0;
+	info->tsp_booster = kzalloc(sizeof(struct input_booster), GFP_KERNEL);
+	if (!info->tsp_booster) {
+		dev_err(&client->dev,
+			"%s: Failed to alloc mem for tsp_booster\n", __func__);
+		goto err_get_tsp_booster;
+	} else {
+		input_booster_init_dvfs(info->tsp_booster, INPUT_BOOSTER_ID_TSP);
+	}
+#endif
 	sema_init(&info->work_lock, 1);
 
 #if ESD_TIMER_INTERVAL
@@ -6263,6 +6301,10 @@ err_request_irq:
 #if ESD_TIMER_INTERVAL
 err_esd_input_unregister_device:
 #endif
+#ifdef COMMON_INPUT_BOOSTER
+err_get_tsp_booster:
+   kfree(info->tsp_booster);
+#endif
 err_input_unregister_device:
 	input_unregister_device(info->input_dev);
 err_input_register_device:
diff --git a/drivers/input/touchscreen/zinitix_zt7538/zt7538.c b/drivers/input/touchscreen/zinitix_zt7538/zt7538.c
index 24c47127bf0e..99cae7a42c7d 100644
--- a/drivers/input/touchscreen/zinitix_zt7538/zt7538.c
+++ b/drivers/input/touchscreen/zinitix_zt7538/zt7538.c
@@ -1484,6 +1484,10 @@ static void clear_report_data(struct zt7538_ts_info *info)
 	input_mt_slot(info->input_dev, 0);
 	input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 0);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, -1);
+#endif
 }
 
 static irqreturn_t zt7538_touch_work(int irq, void *data)
@@ -1693,6 +1697,10 @@ out:
 		dev_info(&client->dev, "debug_register = [0x%04x]\n", m_debug_register);
 	}
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, info->finger_cnt > 0 ? 1 : 0);
+#endif
 
 	if (info->work_state == NORMAL) {
 #if ESD_TIMER_INTERVAL
@@ -2020,6 +2028,10 @@ static int ts_upgrade_sequence(const u8 *firmware_data)
 #ifdef SEC_FACTORY_TEST
 #define TSP_CMD(name, func) .cmd_name = name, .cmd_func = func
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data);
+#endif
+
 static struct tsp_cmd tsp_cmds[] = {
 	{TSP_CMD("fw_update", fw_update),},
 	{TSP_CMD("get_fw_ver_bin", get_fw_ver_bin),},
@@ -2053,6 +2065,9 @@ static struct tsp_cmd tsp_cmds[] = {
 	{TSP_CMD("clear_cover_mode", clear_cover_mode),},
 	{TSP_CMD("clear_reference_data", clear_reference_data),},
 	{TSP_CMD("run_ref_calibration", run_ref_calibration),},
+#ifdef CONFIG_INPUT_BOOSTER
+	{TSP_CMD("boost_level", boost_level),},
+#endif
 	{TSP_CMD("hfdnd_spec_adjust", hfdnd_spec_adjust),},
 };
 
@@ -2069,6 +2084,52 @@ static inline void set_default_result(struct tsp_factory_info *finfo)
 	strncat(finfo->cmd_result, &delim, 1);
 }
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data)
+{
+	struct zt7538_ts_info *info = (struct zt7538_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+	int stage;
+
+	dev_info(&client->dev, "%s\n", __func__);
+
+	set_default_result(finfo);
+
+	stage = 1 << finfo->cmd_param[0];
+	if (!(info->booster->dvfs_stage & stage)) {
+		snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "NG");
+		finfo->cmd_state = FAIL;
+		dev_err(&info->client->dev,"%s: %d is not supported(%04x != %04x).\n",__func__,
+			finfo->cmd_param[0], stage, info->booster->dvfs_stage);
+
+		goto boost_out;
+	}
+
+	info->booster->dvfs_boost_mode = stage;
+	input_booster_set_level_change(finfo->cmd_param[0]);
+	snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "OK");
+	finfo->cmd_state = OK;
+
+	if (info->booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		if (info->booster && info->booster->dvfs_set)
+			info->booster->dvfs_set(info->booster, -1);
+	}
+
+boost_out:
+	set_cmd_result(finfo, finfo->cmd_buff,
+			strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+
+	mutex_lock(&finfo->cmd_lock);
+	finfo->cmd_is_running = false;
+	mutex_unlock(&finfo->cmd_lock);
+
+	finfo->cmd_state = WAITING;
+
+	return;
+}
+#endif
+
 static void fw_update(void *device_data)
 {
 	struct zt7538_ts_info *info = (struct zt7538_ts_info *)device_data;
@@ -4542,6 +4603,15 @@ static int zt7538_ts_probe(struct i2c_client *client, const struct i2c_device_id
 	esd_timer_start(CHECK_ESD_TIMER, info);
 #endif
 
+#ifdef CONFIG_INPUT_BOOSTER
+	info->booster = input_booster_allocate(INPUT_BOOSTER_ID_TSP);
+	if (!info->booster) {
+		dev_err(&client->dev, "%s: Error, failed to allocate input booster\n",__func__);
+		ret = -ENODEV;
+		goto error_alloc_booster_failed;
+	}
+#endif
+
 	info->irq = gpio_to_irq(pdata->gpio_int);
 	if (info->irq < 0) {
 		dev_err(&client->dev, "failed to get gpio_to_irq\n");
@@ -4601,6 +4671,11 @@ err_misc_register:
 	free_irq(info->irq, info);
 err_request_irq:
 err_gpio_irq:
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->booster);
+	info->booster = NULL;
+error_alloc_booster_failed:
+#endif
 #if ESD_TIMER_INTERVAL
 err_esd_input_unregister_device:
 #endif
diff --git a/drivers/input/touchscreen/zinitix_zt7538/zt7538.h b/drivers/input/touchscreen/zinitix_zt7538/zt7538.h
index 5b7c9bc40d87..0b12e3d6bc04 100644
--- a/drivers/input/touchscreen/zinitix_zt7538/zt7538.h
+++ b/drivers/input/touchscreen/zinitix_zt7538/zt7538.h
@@ -45,6 +45,10 @@
 #include <linux/muic/muic.h>
 #include <linux/muic/muic_notifier.h>
 
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
+
 #define ZT7548_IC_CHIP_CODE	0xE548
 #define ZT7538_IC_CHIP_CODE	0xE538
 
@@ -486,6 +490,9 @@ struct zt7538_ts_info {
 	s16					ref_scale_factor;
 	s16					ref_btn_option;
 	struct pinctrl				*pinctrl;
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster			*booster;
+#endif
 #ifdef SUPPORTED_KEY_LED
 	struct regulator			*led_ldo;
 #endif
diff --git a/drivers/input/touchscreen/zt7548_ts.c b/drivers/input/touchscreen/zt7548_ts.c
index 175f83e62794..72c3d32e3bd5 100755
--- a/drivers/input/touchscreen/zt7548_ts.c
+++ b/drivers/input/touchscreen/zt7548_ts.c
@@ -1591,6 +1591,10 @@ static void clear_report_data(struct zt7548_ts_info *info)
 	input_mt_slot(info->input_dev, 0);
 	input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 0);
 
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, -1);
+#endif
 }
 
 static irqreturn_t zt7548_touch_work(int irq, void *data)
@@ -1824,6 +1828,10 @@ static irqreturn_t zt7548_touch_work(int irq, void *data)
 	input_sync(info->input_dev);
 
 out:
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, info->finger_cnt > 0 ? 1 : 0);
+#endif
 
 	if (info->work_state == NORMAL) {
 #if ESD_TIMER_INTERVAL
@@ -2297,6 +2305,10 @@ static int ts_upgrade_sequence(const u8 *firmware_data)
 #ifdef SEC_FACTORY_TEST
 #define TSP_CMD(name, func) .cmd_name = name, .cmd_func = func
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data);
+#endif
+
 static struct tsp_cmd tsp_cmds[] = {
 	{TSP_CMD("fw_update", fw_update),},
 	{TSP_CMD("get_fw_ver_bin", get_fw_ver_bin),},
@@ -2338,6 +2350,9 @@ static struct tsp_cmd tsp_cmds[] = {
 	{TSP_CMD("get_reference", get_reference),},
 #endif
 	{TSP_CMD("run_ref_calibration", run_ref_calibration),},
+#ifdef CONFIG_INPUT_BOOSTER
+	{TSP_CMD("boost_level", boost_level),},
+#endif
 #if defined(CONFIG_TOUCHSCREEN_ZT7538_TS)
 	{TSP_CMD("hfdnd_spec_adjust", hfdnd_spec_adjust),},
 #endif
@@ -2356,6 +2371,52 @@ static inline void set_default_result(struct tsp_factory_info *finfo)
 	strncat(finfo->cmd_result, &delim, 1);
 }
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data)
+{
+	struct zt7548_ts_info *info = (struct zt7548_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	struct tsp_factory_info *finfo = info->factory_info;
+	int stage;
+
+	dev_info(&client->dev, "%s\n", __func__);
+
+	set_default_result(finfo);
+
+	stage = 1 << finfo->cmd_param[0];
+	if (!(info->booster->dvfs_stage & stage)) {
+		snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "NG");
+		finfo->cmd_state = FAIL;
+		dev_err(&info->client->dev,"%s: %d is not supported(%04x != %04x).\n",__func__,
+			finfo->cmd_param[0], stage, info->booster->dvfs_stage);
+
+		goto boost_out;
+	}
+
+	info->booster->dvfs_boost_mode = stage;
+	input_booster_set_level_change(finfo->cmd_param[0]);
+	snprintf(finfo->cmd_buff, sizeof(finfo->cmd_buff), "OK");
+	finfo->cmd_state = OK;
+
+	if (info->booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		if (info->booster && info->booster->dvfs_set)
+			info->booster->dvfs_set(info->booster, -1);
+	}
+
+boost_out:
+	set_cmd_result(finfo, finfo->cmd_buff,
+			strnlen(finfo->cmd_buff, sizeof(finfo->cmd_buff)));
+
+	mutex_lock(&finfo->cmd_lock);
+	finfo->cmd_is_running = false;
+	mutex_unlock(&finfo->cmd_lock);
+
+	finfo->cmd_state = WAITING;
+
+	return;
+}
+#endif
+
 static void fw_update(void *device_data)
 {
 	struct zt7548_ts_info *info = (struct zt7548_ts_info *)device_data;
@@ -5191,6 +5252,15 @@ static int zt7548_ts_probe(struct i2c_client *client, const struct i2c_device_id
 	esd_timer_start(CHECK_ESD_TIMER, info);
 #endif
 
+#ifdef CONFIG_INPUT_BOOSTER
+	info->booster = input_booster_allocate(INPUT_BOOSTER_ID_TSP);
+	if (!info->booster) {
+		dev_err(&client->dev, "%s: Error, failed to allocate input booster\n",__func__);
+		ret = -ENODEV;
+		goto error_alloc_booster_failed;
+	}
+#endif
+
 	info->irq = gpio_to_irq(pdata->gpio_int);
 	if (info->irq < 0) {
 		dev_err(&client->dev, "failed to get gpio_to_irq\n");
@@ -5256,6 +5326,11 @@ err_misc_register:
 	free_irq(info->irq, info);
 err_request_irq:
 err_gpio_irq:
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->booster);
+	info->booster = NULL;
+error_alloc_booster_failed:
+#endif
 #if ESD_TIMER_INTERVAL
 err_esd_input_unregister_device:
 #endif
diff --git a/drivers/input/touchscreen/zt7548_ts.h b/drivers/input/touchscreen/zt7548_ts.h
index 1fcc0c74f687..829e771ee4df 100755
--- a/drivers/input/touchscreen/zt7548_ts.h
+++ b/drivers/input/touchscreen/zt7548_ts.h
@@ -46,6 +46,10 @@
 
 #include <linux/input/tsp_ta_callback.h>
 
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
+
 #define ZT7548_IC_CHIP_CODE	0xE548
 #define ZT7538_IC_CHIP_CODE	0xE538
 
@@ -510,6 +514,9 @@ struct zt7548_ts_info {
 	s16					ref_scale_factor;
 	s16					ref_btn_option;
 	struct pinctrl				*pinctrl;
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster			*booster;
+#endif
 #ifdef SUPPORTED_KEY_LED
 	struct regulator			*led_ldo;
 #endif
diff --git a/drivers/input/touchscreen/zt7554_ts.c b/drivers/input/touchscreen/zt7554_ts.c
index 6985f407d448..fa3c32a49e79 100755
--- a/drivers/input/touchscreen/zt7554_ts.c
+++ b/drivers/input/touchscreen/zt7554_ts.c
@@ -1319,6 +1319,10 @@ static void clear_report_data(struct zt7554_ts_info *info)
 	if (reported)
 		input_sync(info->input_dev);
 	
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, -1);
+#endif
 }
 
 static irqreturn_t zt7554_touch_work(int irq, void *data)
@@ -1538,6 +1542,10 @@ static irqreturn_t zt7554_touch_work(int irq, void *data)
 	input_sync(info->input_dev);
 
 out:
+#ifdef CONFIG_INPUT_BOOSTER
+	if (info->booster && info->booster->dvfs_set)
+		info->booster->dvfs_set(info->booster, info->finger_cnt > 0 ? 1 : 0);
+#endif
 
 	if (info->work_state == NORMAL) {
 #if ESD_TIMER_INTERVAL
@@ -1880,6 +1888,10 @@ int ts_upgrade_sequence(const u8 *firmware_data)
 #ifdef SEC_FACTORY_TEST
 #define TSP_CMD(name, func) .cmd_name = name, .cmd_func = func
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data);
+#endif
+
 static struct tsp_cmd tsp_cmds[] = {
 	{TSP_CMD("fw_update", fw_update),},
 	{TSP_CMD("get_fw_ver_bin", get_fw_ver_bin),},
@@ -1903,6 +1915,9 @@ static struct tsp_cmd tsp_cmds[] = {
 	{TSP_CMD("run_delta_read", run_delta_read),},
 	{TSP_CMD("get_delta", get_delta),},
 	{TSP_CMD("run_ref_calibration", run_ref_calibration),},
+#ifdef CONFIG_INPUT_BOOSTER
+	{TSP_CMD("boost_level", boost_level),},
+#endif
 };
 
 static inline void set_cmd_result(struct zt7554_ts_info *info, char *buff, int len)
@@ -1918,6 +1933,52 @@ static inline void set_default_result(struct zt7554_ts_info *info)
 	strncat(info->factory_info->cmd_result, &delim, 1);
 }
 
+#ifdef CONFIG_INPUT_BOOSTER
+static void boost_level(void *device_data)
+{
+	struct zt7554_ts_info *info = (struct zt7554_ts_info *)device_data;
+	struct i2c_client *client = info->client;
+	char buff[16] = {0};
+	int stage;
+
+	dev_info(&client->dev, "%s\n", __func__);
+
+	set_default_result(info);
+
+	stage = 1 << info->factory_info->cmd_param[0];
+	if (!(info->booster->dvfs_stage & stage)) {
+		snprintf(buff, sizeof(buff), "NG");
+		info->factory_info->cmd_state = FAIL;
+		dev_err(&info->client->dev,"%s: %d is not supported(%04x != %04x).\n",__func__,
+			info->factory_info->cmd_param[0], stage, info->booster->dvfs_stage);
+
+		goto boost_out;
+	}
+
+	info->booster->dvfs_boost_mode = stage;
+	input_booster_set_level_change(info->factory_info->cmd_param[0]);
+	snprintf(buff, sizeof(buff), "OK");
+	info->factory_info->cmd_state = OK;
+
+	if (info->booster->dvfs_boost_mode == DVFS_STAGE_NONE) {
+		if (info->booster && info->booster->dvfs_set)
+			info->booster->dvfs_set(info->booster, -1);
+	}
+
+boost_out:
+	set_cmd_result(info, buff,
+			strnlen(buff, sizeof(buff)));
+
+	mutex_lock(&info->factory_info->cmd_lock);
+	info->factory_info->cmd_is_running = false;
+	mutex_unlock(&info->factory_info->cmd_lock);
+
+	info->factory_info->cmd_state = WAITING;
+
+	return;
+}
+#endif
+
 static void fw_update(void *device_data)
 {
 	struct zt7554_ts_info *info = (struct zt7554_ts_info *)device_data;
@@ -3638,6 +3699,14 @@ static int zt7554_ts_probe(struct i2c_client *client, const struct i2c_device_id
 	esd_timer_start(CHECK_ESD_TIMER, info);
 #endif
 
+#ifdef CONFIG_INPUT_BOOSTER
+	info->booster = input_booster_allocate(INPUT_BOOSTER_ID_TSP);
+	if (!info->booster) {
+		dev_err(&client->dev, "%s: Error, failed to allocate input booster\n",__func__);
+		goto error_alloc_booster_failed;
+	}
+#endif
+
 	info->irq = gpio_to_irq(pdata->gpio_int);
 	if (info->irq < 0) {
 		dev_err(&client->dev, "failed to get gpio_to_irq\n");
@@ -3701,6 +3770,11 @@ err_misc_register:
 #endif
 err_request_irq:
 err_gpio_irq:
+#ifdef CONFIG_INPUT_BOOSTER
+	input_booster_free(info->booster);
+	info->booster = NULL;
+error_alloc_booster_failed:
+#endif
 #if ESD_TIMER_INTERVAL
 err_esd_input_unregister_device:
 #endif
diff --git a/drivers/input/touchscreen/zt7554_ts.h b/drivers/input/touchscreen/zt7554_ts.h
index 82c130a56022..f2a468212863 100755
--- a/drivers/input/touchscreen/zt7554_ts.h
+++ b/drivers/input/touchscreen/zt7554_ts.h
@@ -43,6 +43,10 @@
 #include <linux/async.h>
 #include <linux/input/tsp_ta_callback.h>
 
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
+
 #define TOUCH_BOOSTER 0	// blocked SPRD booster, use QC CONFIG_COMMON_INPUT_BOOSTER
 
 #if TOUCH_BOOSTER
@@ -462,6 +466,9 @@ struct zt7554_ts_info {
 	s16					vdiff_min_val;
 	u8					finger_cnt;
 	struct pinctrl 			*pinctrl;
+#ifdef CONFIG_INPUT_BOOSTER
+	struct input_booster	*booster;
+#endif
 #ifdef SUPPORTED_KEY_LED
 	struct regulator	*led_ldo;
 #endif
diff --git a/include/linux/i2c/mxts_1188s.h b/include/linux/i2c/mxts_1188s.h
index 0832dffaa1d9..a3f2934aa5e6 100644
--- a/include/linux/i2c/mxts_1188s.h
+++ b/include/linux/i2c/mxts_1188s.h
@@ -20,6 +20,9 @@
 #include <linux/earlysuspend.h>
 #endif
 #include <linux/input/tsp_ta_callback.h>
+#ifdef CONFIG_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#endif
 #if defined(CONFIG_TOUCHSCREEN_ATMEL_MXT224S)
 #define MXT_DEV_NAME	"Atmel MXT224S"
 #elif defined(CONFIG_TOUCHSCREEN_ATMEL_MXT540S)
@@ -596,6 +599,9 @@ struct mxt_data {
 	int tkey_dvfs_boost_mode;
 	int tkey_dvfs_freq;
 #endif
+#ifdef CONFIG_INPUT_BOOSTER
+        struct input_booster *tsp_booster;
+#endif
 #if TSP_USE_ATMELDBG
 	struct atmel_dbg atmeldbg;
 #endif
diff --git a/include/linux/i2c/mxtt.h b/include/linux/i2c/mxtt.h
index 0dacb9a74c6b..1deb321bb69a 100644
--- a/include/linux/i2c/mxtt.h
+++ b/include/linux/i2c/mxtt.h
@@ -33,6 +33,11 @@
 #endif
 #include <asm/system_info.h>
 
+#ifdef CONFIG_COMMON_INPUT_BOOSTER
+//to enabled common touch booster. This must be included.
+#include <linux/input/input_booster.h>
+#endif
+
 #include <linux/input/tsp_ta_callback.h>
 
 #ifdef CONFIG_SEC_DEBUG_TSP_LOG
@@ -740,6 +745,10 @@ struct mxt_data {
 #if TSP_PATCH
 	struct mxt_patch patch;
 #endif
+#ifdef COMMON_INPUT_BOOSTER
+	u8 touch_pressed_num;
+        struct input_booster *tsp_booster;
+#endif
 
 #if TSP_CHANGE_CONFIG_FOR_INPUT
 	bool is_inputmethod;
diff --git a/include/linux/input/input.h b/include/linux/input/input.h
new file mode 100644
index 000000000000..ef5908ff9cec
--- /dev/null
+++ b/include/linux/input/input.h
@@ -0,0 +1,620 @@
+#if !defined(CONFIG_INPUT_BOOSTER) // Input Booster +
+#ifndef _INPUT_BOOSTER_H_
+#define _INPUT_BOOSTER_H_
+
+#include <linux/pm_qos.h>
+#include <linux/of.h>
+#include <linux/cpufreq.h>
+
+#ifdef CONFIG_SCHED_HMP
+#define USE_HMP_BOOST
+#endif
+
+#undef pr_debug
+#define pr_debug   if(debug_flag) printk
+
+#define MAX_MULTI_TOUCH_EVENTS		3
+#define MAX_EVENTS			MAX_MULTI_TOUCH_EVENTS * 10
+
+#define HEADGAGE "******"
+#define TAILGAGE "****  "
+
+#if defined(CONFIG_ARCH_EXYNOS) //______________________________________________________________________________
+#define set_qos(req, pm_qos_class, value) { \
+	if (value) { \
+		if (pm_qos_request_active(req)) {\
+			pr_debug("[Input Booster2] %s      pm_qos_update_request : %d\n", glGage, value); \
+			pm_qos_update_request(req, value); \
+		} else { \
+			pr_debug("[Input Booster2] %s      pm_qos_add_request : %d\n", glGage, value); \
+			pm_qos_add_request(req, pm_qos_class, value); \
+		} \
+	} else { \
+		pr_debug("[Input Booster2] %s      remove_qos\n", glGage); \
+		remove_qos(req); \
+	}\
+}
+
+#define remove_qos(req) { \
+	if (pm_qos_request_active(req)) \
+		pm_qos_remove_request(req); \
+}
+
+#ifdef USE_HMP_BOOST
+#define set_hmp(enable)	 { \
+	if(enable != current_hmp_boost) { \
+		pr_debug("[Input Booster2] ******      set_hmp : %d ( %s )\n", enable, __FUNCTION__); \
+		if (set_hmp_boost(enable) < 0) {\
+			pr_debug("[Input Booster2] ******            !!! fail to HMP !!!\n"); \
+		} \
+		current_hmp_boost = enable; \
+	} \
+}
+#else
+#define set_hmp(enable)
+#endif
+
+#define SET_BOOSTER  { \
+	set_hmp(_this->param[_this->index].hmp_boost); \
+	set_qos(&_this->cpu_qos, /*PM_QOS_CPU_FREQ_MIN*/PM_QOS_CLUSTER1_FREQ_MIN, _this->param[_this->index].cpu_freq);  \
+	set_qos(&_this->kfc_qos, /*PM_QOS_KFC_FREQ_MIN*/PM_QOS_CLUSTER0_FREQ_MIN, _this->param[_this->index].kfc_freq);  \
+	set_qos(&_this->mif_qos, PM_QOS_BUS_THROUGHPUT, _this->param[_this->index].mif_freq);  \
+	set_qos(&_this->int_qos, PM_QOS_DEVICE_THROUGHPUT, _this->param[_this->index].int_freq);  \
+}
+#define REMOVE_BOOSTER  { \
+	set_hmp(0);  \
+	remove_qos(&_this->cpu_qos);  \
+	remove_qos(&_this->kfc_qos);  \
+	remove_qos(&_this->mif_qos);  \
+	remove_qos(&_this->int_qos);  \
+}
+#define PROPERTY_BOOSTER(_device_param_, _dt_param_, _time_)  { \
+	_device_param_.cpu_freq = _dt_param_.cpu_freq; \
+	_device_param_.kfc_freq = _dt_param_.kfc_freq; \
+	_device_param_.mif_freq = _dt_param_.mif_freq; \
+	_device_param_.int_freq = _dt_param_.int_freq; \
+	_device_param_.time = _dt_param_._time_; \
+	_device_param_.hmp_boost = _dt_param_.hmp_boost; \
+}
+#define SYSFS_DEFINE(_A_, _B_) \
+	_A_ cpu_freq _B_ ; \
+	_A_ kfc_freq _B_ ; \
+	_A_ mif_freq _B_ ; \
+	_A_ int_freq _B_ ; \
+	_A_ hmp_boost _B_ ; \
+	_A_ head_time _B_ ; \
+	_A_ tail_time _B_ ; \
+	_A_ phase_time _B_ ; 
+#define SYSFS_COPY_TO_FROM(_A_, _B_) { \
+	_A_ cpu_freq = (*cpu_freq == (unsigned int)(-1)) ? _B_ cpu_freq : *cpu_freq; \
+	_A_ kfc_freq = (*kfc_freq == (unsigned int)(-1)) ? _B_ kfc_freq : *kfc_freq; \
+	_A_ mif_freq = (*mif_freq == (unsigned int)(-1)) ? _B_ mif_freq : *mif_freq; \
+	_A_ int_freq = (*int_freq == (unsigned int)(-1)) ? _B_ int_freq : *int_freq; \
+	_A_ hmp_boost = (*hmp_boost == (unsigned int)(-1)) ? _B_ hmp_boost : *hmp_boost; \
+	_A_ head_time = (*head_time == (unsigned int)(-1)) ? _B_ head_time : *head_time; \
+	_A_ tail_time = (*tail_time == (unsigned int)(-1)) ? _B_ tail_time : *tail_time; \
+	_A_ phase_time = (*phase_time == (unsigned int)(-1)) ? _B_ phase_time : *phase_time; \
+}
+#define SYSFS_COPY_FROM(_A_) { \
+	cpu_freq = _A_ cpu_freq; \
+	kfc_freq = _A_ kfc_freq; \
+	mif_freq = _A_ mif_freq; \
+	int_freq = _A_ int_freq; \
+	hmp_boost = _A_ hmp_boost; \
+	head_time = _A_ head_time; \
+	tail_time = _A_ tail_time; \
+	phase_time = _A_ phase_time; \
+}
+#define DTSI_TO { \
+	err |= of_property_read_u32_index(cnp, "input_booster,cpu_freqs", i, &dt_infor->param_tables[i].cpu_freq); \
+	err |= of_property_read_u32_index(cnp, "input_booster,kfc_freqs", i, &dt_infor->param_tables[i].kfc_freq); \
+	err |= of_property_read_u32_index(cnp, "input_booster,mif_freqs", i, &dt_infor->param_tables[i].mif_freq); \
+	err |= of_property_read_u32_index(cnp, "input_booster,int_freqs", i, &dt_infor->param_tables[i].int_freq); \
+	err |= of_property_read_u32_index(cnp, "input_booster,hmp_boost", i, &temp); dt_infor->param_tables[i].hmp_boost = (u8)temp; \
+	err |= of_property_read_u32_index(cnp, "input_booster,head_times", i, &temp); dt_infor->param_tables[i].head_time = (u16)temp; \
+	err |= of_property_read_u32_index(cnp, "input_booster,tail_times", i, &temp); dt_infor->param_tables[i].tail_time = (u16)temp; \
+	err |= of_property_read_u32_index(cnp, "input_booster,phase_times", i, &temp); dt_infor->param_tables[i].phase_time = (u16)temp; \
+}
+
+#elif defined(CONFIG_ARCH_MSM) //______________________________________________________________________________
+#ifdef CONFIG_DEBUG_BUS_VOTER
+#define SET_BOOSTER  { \
+	pr_debug("[Input Booster2] %s      set_freq_limit : %d, msm_bus_floor_vote : %d\n", glGage, _this->param[_this->index].cpu_freq, _this->param[_this->index].bimc_freq); \
+	set_freq_limit(DVFS_TOUCH_ID, _this->param[_this->index].cpu_freq);  \
+	msm_bus_floor_vote("bimc", _this->param[_this->index].bimc_freq * 1000);  \
+}
+#define REMOVE_BOOSTER  { \
+	pr_debug("[Input Booster2] %s      set_freq_limit : %d, msm_bus_floor_vote : %d\n", glGage, -1, 0); \
+	set_freq_limit(DVFS_TOUCH_ID, -1);  \
+	msm_bus_floor_vote("bimc", 0);  \
+}
+#else
+#define SET_BOOSTER  { \
+	pr_debug("[Input Booster2] %s      set_freq_limit : %d\n", glGage, _this->param[_this->index].cpu_freq); \
+	set_freq_limit(DVFS_TOUCH_ID, _this->param[_this->index].cpu_freq);  \
+}
+#define REMOVE_BOOSTER  { \
+	pr_debug("[Input Booster2] %s      set_freq_limit : %d\n", glGage, -1); \
+	set_freq_limit(DVFS_TOUCH_ID, -1);  \
+}
+#endif
+#define PROPERTY_BOOSTER(_device_param_, _dt_param_, _time_)  { \
+	_device_param_.cpu_freq = _dt_param_.cpu_freq; \
+	_device_param_.bimc_freq = _dt_param_.bimc_freq; \
+	_device_param_.time = _dt_param_._time_; \
+}
+#define SYSFS_DEFINE(_A_, _B_) \
+	_A_ cpu_freq _B_ ; \
+	_A_ bimc_freq _B_ ; \
+	_A_ head_time _B_ ; \
+	_A_ tail_time _B_ ; 
+#define SYSFS_COPY_TO_FROM(_A_, _B_) { \
+	_A_ cpu_freq = (*cpu_freq == (unsigned int)(-1)) ? _B_ cpu_freq : *cpu_freq; \
+	_A_ bimc_freq = (*bimc_freq == (unsigned int)(-1)) ? _B_ bimc_freq : *bimc_freq; \
+	_A_ head_time = (*head_time == (unsigned int)(-1)) ? _B_ head_time : *head_time; \
+	_A_ tail_time = (*tail_time == (unsigned int)(-1)) ? _B_ tail_time : *tail_time; \
+}
+#define SYSFS_COPY_FROM(_A_) { \
+	cpu_freq = _A_ cpu_freq; \
+	bimc_freq = _A_ bimc_freq; \
+	head_time = _A_ head_time; \
+	tail_time = _A_ tail_time; \
+}
+#define DTSI_TO { \
+	err |= of_property_read_u32_index(cnp, "input_booster,cpu_freqs", i, &dt_infor->param_tables[i].cpu_freq); \
+	err |= of_property_read_u32_index(cnp, "input_booster,bimc_freqs", i, &dt_infor->param_tables[i].bimc_freq); \
+	err |= of_property_read_u32_index(cnp, "input_booster,head_times", i, &temp); dt_infor->param_tables[i].head_time = (u16)temp; \
+	err |= of_property_read_u32_index(cnp, "input_booster,tail_times", i, &temp); dt_infor->param_tables[i].tail_time = (u16)temp; \
+}
+#define DVFS_TOUCH_ID	0
+int set_freq_limit(unsigned long id, unsigned int freq)
+{
+	pr_err("%s is not yet implemented\n", __func__);
+	return 0;
+}
+#endif //______________________________________________________________________________
+#define GET_BOOSTER_PARAM(_GENDER_, _HEAD_PARAM_, _TAIL_PARAM_) { \
+	int levels[][3] = { \
+		{1, 2, 0}, \
+		{2, 2, 3}, \
+		{3, 1, 1}, \
+		{4, 1, 2}}; \
+	int j, k; \
+	for(j = 0;j < (int)(sizeof(levels)/(3*sizeof(int)));j++) {\
+		if((_GENDER_->pDT->nlevels > 2 && levels[j][0] == _GENDER_->level) || (_GENDER_->pDT->nlevels == 1 && j == 2) || (_GENDER_->pDT->nlevels == 2 && j == 3)) { \
+			if(levels[j][1] > 0) { \
+				for(k = 0;k < _GENDER_->pDT->nlevels;k++) { \
+					if(levels[j][1] == _GENDER_->pDT->param_tables[k].ilevels) { \
+						_HEAD_PARAM_ = (_GENDER_->pDT->param_tables[k].head_time > 0) ? &_GENDER_->pDT->param_tables[k] : NULL; \
+						break; \
+					} \
+				} \
+			} \
+			if(levels[j][2] > 0) { \
+				for(k = 0;k < dt_gender->pDT->nlevels;k++) { \
+					if(levels[j][2] == dt_gender->pDT->param_tables[k].ilevels) { \
+						_TAIL_PARAM_ = &_GENDER_->pDT->param_tables[k]; \
+						break; \
+					} \
+				} \
+			} \
+			break; \
+		} \
+	} \
+}
+#define CHANGE_BOOSTER { \
+	struct t_input_booster_device_tree_param *head_param = NULL, *tail_param = NULL; \
+	GET_BOOSTER_PARAM(dt_gender, head_param, tail_param) \
+	memset(dt_gender->pBooster->param, 0x00, sizeof(struct t_input_booster_param)*2); \
+	if(head_param != NULL) { \
+		PROPERTY_BOOSTER(dt_gender->pBooster->param[0], (*head_param), head_time) \
+	} \
+	if(tail_param != NULL) { \
+		PROPERTY_BOOSTER(dt_gender->pBooster->param[1], (*tail_param), tail_time) \
+	} \
+}
+
+#define INIT_BOOSTER(_DEVICE_) { \
+	_DEVICE_##_booster.input_booster_state = input_booster_idle_state; \
+	INIT_DELAYED_WORK(&_DEVICE_##_booster.input_booster_timeout_work[0], TIMEOUT_FUNC(_DEVICE_)); \
+	INIT_DELAYED_WORK(&_DEVICE_##_booster.input_booster_timeout_work[1], TIMEOUT_FUNC(_DEVICE_)); \
+	INIT_WORK(&_DEVICE_##_booster.input_booster_set_booster_work, SET_BOOSTER_FUNC(_DEVICE_)); \
+	mutex_init(&_DEVICE_##_booster.lock); \
+	_DEVICE_##_booster.change_on_release = 0; \
+	_DEVICE_##_booster.multi_events = 0; \
+	{ \
+		int i; \
+		for(i=0;i<ndevice_in_dt;i++) { \
+			if(device_tree_infor[i].type == _DEVICE_##_booster_dt.type) { \
+				struct t_input_booster_device_tree_gender *dt_gender = &_DEVICE_##_booster_dt; \
+				dt_gender->pDT = &device_tree_infor[i]; \
+				dt_gender->pBooster = &_DEVICE_##_booster; \
+				CHANGE_BOOSTER \
+				break; \
+			} \
+		} \
+	} \
+}
+
+#define TIMEOUT_FUNC(_DEVICE_) input_booster_##_DEVICE_##_timeout_work_func
+
+#define DECLARE_TIMEOUT_FUNC(_DEVICE_) \
+static void input_booster_##_DEVICE_##_timeout_work_func(struct work_struct *work)  \
+{ \
+	struct t_input_booster *_this = &_DEVICE_##_booster; \
+	int param_max = sizeof(_this->param)/sizeof(struct t_input_booster_param), temp_index = -1;  \
+	mutex_lock(&_this->lock); \
+	pr_debug("[Input Booster] %s           Timeout : changed  index : %d (%s)\n", HEADGAGE, _this->index , __FUNCTION__); \
+	if(_this->index >= 2 && delayed_work_pending(&_this->input_booster_timeout_work[_this->index-2])) { \
+		mutex_unlock(&_this->lock); \
+		return; \
+	}\
+	if(_this->index == param_max && delayed_work_pending(&_this->input_booster_timeout_work[_this->index-1])) { \
+		temp_index = _this->index; \
+		_this->index = (_this->index) ? _this->index-1 : 0; \
+	} \
+	pr_debug("[Input Booster] %s           Timeout : changed  index : %d (%s)\n", HEADGAGE, _this->index , __FUNCTION__); \
+	if(_this->index < param_max) { \
+		pr_debug("[Input Booster] %s           Timeout : changed  index : %d, time : %d (%s)\n", HEADGAGE, _this->index, _this->param[_this->index].time, __FUNCTION__); \
+		pr_debug("[Input Booster] %s           cpu : %d (%s)\n", TAILGAGE, _this->param[_this->index].cpu_freq, __FUNCTION__); \
+		if(_this->param[(_this->index) ? _this->index-1 : 0].time > 0) { \
+			SET_BOOSTER; \
+			if(_this->change_on_release) { \
+				schedule_delayed_work(&_this->input_booster_timeout_work[_this->index], msecs_to_jiffies(_this->param[_this->index].time)); \
+				_this->index++; \
+				CHANGE_STATE_TO(idle); \
+			}\
+		}\
+		_this->index = (temp_index >= 0) ? temp_index : _this->index; \
+	} else { \
+		pr_debug("[Input Booster] Timeout : completed   param_max : %d (%s)\n", param_max, __FUNCTION__); \
+		pr_debug("[Input Booster]\n"); \
+		REMOVE_BOOSTER; \
+		_this->index = 0; \
+		_this->multi_events = (_this->multi_events > 0) ? 0 : _this->multi_events; \
+		CHANGE_STATE_TO(idle); \
+	} \
+	mutex_unlock(&_this->lock); \
+}
+
+#define SET_BOOSTER_FUNC(_DEVICE_) input_booster_##_DEVICE_##_set_booster_work_func
+
+#define DECLARE_SET_BOOSTER_FUNC(_DEVICE_) \
+static void input_booster_##_DEVICE_##_set_booster_work_func(struct work_struct *work)  \
+{ \
+	struct t_input_booster *_this = (struct t_input_booster *)(&_DEVICE_##_booster); \
+	mutex_lock(&_this->lock); \
+	_this->input_booster_state(_this, _this->event_type); \
+	mutex_unlock(&_this->lock); \
+}
+
+#define DECLARE_STATE_FUNC(_STATE_) void input_booster_##_STATE_##_state(void *__this, int input_booster_event)
+
+#define CHANGE_STATE_TO(_STATE_) _this->input_booster_state = input_booster_##_STATE_##_state;
+
+#define RUN_BOOSTER(_DEVICE_, _EVENT_) { \
+	if(_DEVICE_##_booster_dt.level > 0) { \
+		_DEVICE_##_booster.event_type = _EVENT_; \
+		(_EVENT_ == BOOSTER_ON)  ? _DEVICE_##_booster.multi_events++ : _DEVICE_##_booster.multi_events--; \
+		schedule_work(&_DEVICE_##_booster.input_booster_set_booster_work); \
+	} \
+}
+
+//+++++++++++++++++++++++++++++++++++++++++++++++  STRUCT & VARIABLE FOR SYSFS  +++++++++++++++++++++++++++++++++++++++++++++++//
+#define SYSFS_CLASS(_ATTR_, _ARGU_, _COUNT_) \
+	static ssize_t input_booster_sysfs_class_show_##_ATTR_(struct class *dev, struct class_attribute *attr, char *buf) { \
+		struct t_input_booster_device_tree_gender *dt_gender = &touch_booster_dt; \
+		ssize_t ret; int level; \
+		unsigned int debug_level = 0; \
+		SYSFS_DEFINE(unsigned int, = 0) \
+		struct t_input_booster_device_tree_param *head_param = NULL, *tail_param = NULL; \
+		GET_BOOSTER_PARAM(dt_gender, head_param, tail_param) \
+		debug_level = debug_flag; \
+		level = dt_gender->level; \
+		if(strcmp(#_ATTR_,"head") == 0 && head_param != NULL) { \
+			SYSFS_COPY_FROM( head_param-> ) \
+		} \
+		if(strcmp(#_ATTR_,"tail") == 0 && tail_param != NULL) { \
+			SYSFS_COPY_FROM( tail_param-> ) \
+		} \
+		ret = sprintf _ARGU_; \
+		pr_debug("[Input Booster8] %s buf : %s\n", __FUNCTION__, buf); \
+		return ret; \
+	} \
+	static ssize_t input_booster_sysfs_class_store_##_ATTR_(struct class *dev, struct class_attribute *attr, const char *buf, size_t count) { \
+		struct t_input_booster_device_tree_gender *dt_gender = &touch_booster_dt; \
+		int level[1] = {-1}, len; \
+		unsigned int debug_level[1] = {-1}; \
+		SYSFS_DEFINE(unsigned int, [1] = {-1}) \
+		struct t_input_booster_device_tree_param *head_param = NULL, *tail_param = NULL; \
+		GET_BOOSTER_PARAM(dt_gender, head_param, tail_param) \
+		len = sscanf _ARGU_; \
+		pr_debug("[Input Booster8] %s buf : %s\n", __FUNCTION__, buf); \
+		if (sscanf _ARGU_ != _COUNT_) { \
+ 			return count; \
+	 	} \
+		debug_flag = (*debug_level == (unsigned int)(-1)) ? debug_flag : *debug_level; \
+		dt_gender->level = (*level == (unsigned int)(-1)) ? dt_gender->level : *level; \
+		if(*head_time != (unsigned int)(-1) && head_param != NULL) { \
+			SYSFS_COPY_TO_FROM(head_param->,head_param->) \
+		} \
+		if(*tail_time != (unsigned int)(-1) && tail_param != NULL) { \
+			SYSFS_COPY_TO_FROM(tail_param->,tail_param->) \
+		} \
+		CHANGE_BOOSTER \
+		return count; \
+	} \
+	static CLASS_ATTR(_ATTR_, S_IRUGO | S_IWUSR, input_booster_sysfs_class_show_##_ATTR_, input_booster_sysfs_class_store_##_ATTR_);
+#define SYSFS_DEVICE(_ATTR_, _ARGU_, _COUNT_) \
+	static ssize_t input_booster_sysfs_device_show_##_ATTR_(struct device *dev, struct device_attribute *attr, char *buf) { \
+		struct t_input_booster_device_tree_gender *dt_gender = dev_get_drvdata(dev); \
+		ssize_t ret = 0; \
+		int level, Arg_count = _COUNT_; \
+		SYSFS_DEFINE(unsigned int, = 0) \
+		struct t_input_booster_device_tree_param *head_param = NULL, *tail_param = NULL; \
+		if(dt_gender == NULL) { \
+			return  ret; \
+		} \
+		GET_BOOSTER_PARAM(dt_gender, head_param, tail_param) \
+		if(Arg_count == 1) { \
+			level = dt_gender->level; \
+			ret = sprintf _ARGU_; \
+			pr_debug("[Input Booster8] %s buf : %s\n", __FUNCTION__, buf); \
+		} else { \
+			if(head_param != NULL) { \
+				level = head_param->ilevels; \
+				SYSFS_COPY_FROM( head_param-> ) \
+				ret = sprintf _ARGU_; \
+				buf = buf + ret - 1; \
+			} \
+			*buf = '|'; \
+			*(buf+1) = '\n';\
+			if(tail_param != NULL) { \
+				buf = buf + 1; \
+				level = tail_param->ilevels; \
+				SYSFS_COPY_FROM( tail_param-> ) \
+				ret += sprintf _ARGU_; \
+			} \
+			pr_debug("[Input Booster8] %s buf : %s\n", __FUNCTION__, buf); \
+		} \
+		return  ret; \
+	} \
+	static ssize_t input_booster_sysfs_device_store_##_ATTR_(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) { \
+		struct t_input_booster_device_tree_gender *dt_gender = dev_get_drvdata(dev); \
+		struct t_input_booster_device_tree_infor *dt_infor = (dt_gender) ? dt_gender->pDT : NULL; \
+		int level[1] = {-1}, len; \
+		SYSFS_DEFINE(unsigned int, [1] = {-1}) \
+		len = sscanf _ARGU_; \
+		pr_debug("[Input Booster8] %s buf : %s\n", __FUNCTION__, buf); \
+		if(dt_infor == NULL) { \
+			return  count; \
+		} \
+		if (len != _COUNT_) { \
+			pr_debug("### Keep this format : [level cpu_freq kfc_freq mif_freq int_freq hmp_boost] (Ex: 1 1600000 0 1500000 667000 333000 1###\n"); \
+			pr_debug("### Keep this format : [level head_time tail_time phase_time] (Ex: 1 130 500 50 ###\n"); \
+			pr_debug("### Keep this format : [type value] (Ex: 2 1 ###\n"); \
+			return count; \
+		} \
+		if(level[0] >= 0) { \
+			int Arg_count = _COUNT_; \
+			if(Arg_count == 1) { \
+				dt_gender->level = level[0]; \
+			} else { \
+				int k; \
+				for(k = 0;k < dt_infor->nlevels;k++) { \
+					if(level[0] == dt_infor->param_tables[k].ilevels) { \
+						SYSFS_COPY_TO_FROM(dt_infor->param_tables[k]., dt_infor->param_tables[k].) \
+						pr_debug("[Input Booster8] %s time : %d %d\n", __FUNCTION__, dt_infor->param_tables[*level].head_time, dt_infor->param_tables[k].tail_time); \
+					} \
+				} \
+			} \
+			CHANGE_BOOSTER \
+		} \
+		return count; \
+	} \
+	static DEVICE_ATTR(_ATTR_, S_IRUGO | S_IWUSR, input_booster_sysfs_device_show_##_ATTR_, input_booster_sysfs_device_store_##_ATTR_);
+#define INIT_SYSFS_CLASS(_CLASS_) { \
+		int ret = class_create_file(sysfs_class, &class_attr_##_CLASS_); \
+		if (ret) { \
+			pr_debug("[Input Booster] Failed to create class\n"); \
+			class_destroy(sysfs_class); \
+			return; \
+		} \
+	}
+#define INIT_SYSFS_DEVICE(_DEVICE_) { \
+		struct device   *sysfs_dev; int ret = 0;\
+		sysfs_dev = device_create(sysfs_class, NULL, 0, &_DEVICE_##_booster_dt, #_DEVICE_); \
+		if (IS_ERR(sysfs_dev)) { \
+			ret = IS_ERR(sysfs_dev); \
+			pr_debug("[Input Booster] Failed to create %s sysfs device[%d]\n", #_DEVICE_, ret); \
+			return; \
+		} \
+		ret = sysfs_create_group(&sysfs_dev->kobj, &dvfs_attr_group); \
+		if (ret) { \
+			pr_debug("[Input Booster] Failed to create %s sysfs group\n", #_DEVICE_); \
+			return; \
+		} \
+	}
+//-----------------------------------------------  STRUCT & VARIABLE FOR SYSFS  -----------------------------------------------//
+
+enum booster_mode_on_off {
+	BOOSTER_OFF = 0,
+	BOOSTER_ON,
+};
+
+
+struct input_value input_events[MAX_EVENTS+1];
+
+struct t_input_booster_param {
+#if defined(CONFIG_ARCH_EXYNOS) //______________________________________________________________________________
+	u32 cpu_freq;
+	u32 kfc_freq;
+	u32 mif_freq;
+	u32 int_freq;
+
+	u16 time;
+
+	u8 hmp_boost;
+	u8 dummy;
+#elif defined(CONFIG_ARCH_MSM) //______________________________________________________________________________
+	u32 cpu_freq;
+	u32 bimc_freq;
+
+	u16 time;
+#endif //______________________________________________________________________________
+};
+
+struct t_input_booster {
+	struct mutex lock;
+	struct t_input_booster_param param[2];
+
+#if defined(CONFIG_ARCH_EXYNOS) //______________________________________________________________________________
+	struct pm_qos_request	cpu_qos;
+	struct pm_qos_request	kfc_qos;
+	struct pm_qos_request	mif_qos;
+	struct pm_qos_request	int_qos;
+#endif //______________________________________________________________________________
+
+	struct delayed_work     input_booster_timeout_work[2];
+	struct work_struct      input_booster_set_booster_work;
+
+	int index;
+	int multi_events;
+	int event_type;
+	int change_on_release;
+
+	void (*input_booster_state)(void *__this, int input_booster_event);
+};
+
+//+++++++++++++++++++++++++++++++++++++++++++++++  STRUCT & VARIABLE FOR DEVICE TREE  +++++++++++++++++++++++++++++++++++++++++++++++//
+struct t_input_booster_device_tree_param {
+	u8      ilevels;
+
+#if defined(CONFIG_ARCH_EXYNOS) //______________________________________________________________________________
+	u8      hmp_boost;
+
+	u16     head_time;
+	u16     tail_time;
+	u16     phase_time;
+
+	u32     cpu_freq;
+	u32     kfc_freq;
+	u32     mif_freq;
+	u32     int_freq;
+#elif defined(CONFIG_ARCH_MSM) //______________________________________________________________________________
+	u16 	head_time;
+	u16 	tail_time;
+
+	u32 	cpu_freq;
+	u32 	bimc_freq;
+#endif //______________________________________________________________________________
+};
+
+struct t_input_booster_device_tree_infor {
+	const char     *label;
+	int     type;
+	int     nlevels;
+
+	struct t_input_booster_device_tree_param      *param_tables;
+};
+
+struct t_input_booster_device_tree_gender {
+	int type;
+	int level;
+	struct t_input_booster	*pBooster;
+	struct t_input_booster_device_tree_infor *pDT;
+};
+
+//______________________________________________________________________________	<<< in DTSI file >>>
+//______________________________________________________________________________	input_booster,type = <4>;	/* BOOSTER_DEVICE_KEYBOARD */
+//______________________________________________________________________________
+struct t_input_booster_device_tree_gender	touch_booster_dt = {2,2,};		// type : 2,  level : 2
+struct t_input_booster_device_tree_gender	multitouch_booster_dt = {3,1,};		// type : 3,  level : 1
+struct t_input_booster_device_tree_gender	key_booster_dt = {0,1,};		// type : 0,  level : 1
+struct t_input_booster_device_tree_gender	touchkey_booster_dt = {1,1,};		// type : 1,  level : 1
+struct t_input_booster_device_tree_gender	keyboard_booster_dt = {4,1,};		// type : 4,  level : 1
+struct t_input_booster_device_tree_gender	mouse_booster_dt = {5,1,};		// type : 5,  level : 1
+struct t_input_booster_device_tree_gender	mouse_wheel_booster_dt = {6,1,};	// type : 6,  level : 1
+struct t_input_booster_device_tree_gender	pen_booster_dt = {7,1,};		// type : 7,  level : 1
+struct t_input_booster_device_tree_gender	hover_booster_dt = {7,1,};		// type : 7,  level : 1
+struct t_input_booster_device_tree_infor	*device_tree_infor = NULL;
+
+int ndevice_in_dt;
+//----------------------------------------------  STRUCT & VARIABLE FOR DEVICE TREE  ----------------------------------------------//
+
+//+++++++++++++++++++++++++++++++++++++++++++++++  STRUCT & VARIABLE FOR SYSFS  +++++++++++++++++++++++++++++++++++++++++++++++//
+unsigned int debug_flag = 0;
+
+#if defined(CONFIG_ARCH_EXYNOS) //______________________________________________________________________________
+SYSFS_CLASS(debug_level, (buf, "%u\n", debug_level), 1)
+SYSFS_CLASS(head, (buf, "%d %u %u %u %u %u\n", head_time, cpu_freq, kfc_freq, mif_freq, int_freq, hmp_boost), 6)
+SYSFS_CLASS(tail, (buf, "%d %u %u %u %u %u\n", tail_time, cpu_freq, kfc_freq, mif_freq, int_freq, hmp_boost), 6)
+SYSFS_CLASS(level, (buf, "%d\n", level), 1)
+SYSFS_DEVICE(level, (buf, "%d\n", level), 1)
+SYSFS_DEVICE(freq, (buf, "%d %u %u %u %u %u\n", level, cpu_freq, kfc_freq, mif_freq, int_freq, hmp_boost), 6)
+SYSFS_DEVICE(time, (buf, "%d %u %u %u\n", level, head_time, tail_time, phase_time), 4)
+#elif defined(CONFIG_ARCH_MSM) //______________________________________________________________________________
+SYSFS_CLASS(debug_level, (buf, "%u\n", debug_level), 1)
+SYSFS_CLASS(head, (buf, "%u %u %u\n", head_time, cpu_freq, bimc_freq), 3)
+SYSFS_CLASS(tail, (buf, "%u %u %u\n", tail_time, cpu_freq, bimc_freq), 3)
+SYSFS_CLASS(level, (buf, "%d\n", level), 1)
+SYSFS_DEVICE(level, (buf, "%d\n", level), 1)
+SYSFS_DEVICE(freq, (buf, "%d %u %u\n", level, cpu_freq, bimc_freq), 3)
+SYSFS_DEVICE(time, (buf, "%d %u %u\n", level, head_time, tail_time), 3)
+#endif //______________________________________________________________________________
+static ssize_t input_booster_sysfs_device_store_control(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) { 
+	struct t_input_booster_device_tree_gender *dt_gender = dev_get_drvdata(dev);
+	struct t_input_booster *dt_booster = (dt_gender) ? dt_gender->pBooster : NULL;
+	int value;
+	unsigned int type;
+
+	if(dt_booster == NULL) {
+		return count;
+	}
+	if(sscanf(buf, "%u %d",&type, &value) != 2) {
+		pr_debug("### Keep this format : [type value] (Ex: 2 1 ###\n");
+		return count;
+	}
+	dt_booster->event_type = value;
+	schedule_work(&dt_booster->input_booster_set_booster_work);
+
+	return count;
+}
+static DEVICE_ATTR(control, S_IRUGO | S_IWUSR, NULL, input_booster_sysfs_device_store_control);
+
+static struct attribute *dvfs_attributes[] = {
+	&dev_attr_level.attr,
+	&dev_attr_freq.attr,
+	&dev_attr_time.attr,
+	&dev_attr_control.attr,
+	NULL,
+};
+
+static struct attribute_group dvfs_attr_group = {
+	.attrs = dvfs_attributes,
+};
+
+//----------------------------------------------  STRUCT & VARIABLE FOR SYSFS  ----------------------------------------------//
+
+int TouchIDs[MAX_MULTI_TOUCH_EVENTS];
+char *glGage = HEADGAGE;
+bool current_hmp_boost = 0;
+
+struct t_input_booster	touch_booster;
+struct t_input_booster	multitouch_booster;
+struct t_input_booster	key_booster;
+struct t_input_booster	touchkey_booster;
+struct t_input_booster	keyboard_booster;
+struct t_input_booster	mouse_booster;
+struct t_input_booster	mouse_wheel_booster;
+struct t_input_booster	pen_booster;
+struct t_input_booster	hover_booster;
+
+int input_count = 0, key_back = 0, key_home = 0, key_recent = 0;
+
+void input_booster_idle_state(void *__this, int input_booster_event);
+void input_booster_press_state(void *__this, int input_booster_event);
+void input_booster(struct input_dev *dev);
+void input_booster_init(void);
+#endif
+#endif // Input Booster -
diff --git a/include/linux/input/input_booster.h b/include/linux/input/input_booster.h
new file mode 100644
index 000000000000..565ab55e4282
--- /dev/null
+++ b/include/linux/input/input_booster.h
@@ -0,0 +1,145 @@
+#ifndef _INPUT_BOOSTER_H_
+#define _INPUT_BOOSTER_H_
+#include <linux/cpufreq.h>
+
+#ifdef CONFIG_COMMON_INPUT_BOOSTER
+/* This is only for GT5 models.
+ * CONFIG_COMMON_INPUT_BOOSTER featured codes will be removed later */
+enum input_booster_id {
+	INPUT_BOOSTER_ID_TSP = 0,
+	INPUT_BOOSTER_ID_TKEY,
+	INPUT_BOOSTER_ID_WACOM,
+};
+#define DVFS_STAGE_NONE		0	// 0000 0000 0000 0001
+#define DVFS_STAGE_SINGLE	1	// 0000 0000 0000 0010
+#define DVFS_STAGE_DUAL		2	// 0000 0000 0000 0100
+#define DVFS_STAGE_TRIPLE	 3	// 0000 0000 0000 1000
+#define DVFS_STAGE_PENTA	 5	// 0000 0000 0010 0000
+#define DVFS_STAGE_NINTH	 9	// 0000 0010 0000 0000
+
+#define DVFS_TSP_STAGE		(DVFS_STAGE_NONE | DVFS_STAGE_SINGLE |\
+				DVFS_STAGE_DUAL)
+#define DVFS_TKEY_STAGE		(DVFS_STAGE_NONE | DVFS_STAGE_SINGLE |\
+				DVFS_STAGE_DUAL)
+#define DVFS_WACOM_STAGE		(DVFS_STAGE_NONE | DVFS_STAGE_SINGLE |\
+				DVFS_STAGE_DUAL)
+
+#ifndef DVFS_TSP_STAGE
+#define DVFS_TSP_STAGE		0
+#endif
+#ifndef DVFS_TKEY_STAGE
+#define DVFS_TKEY_STAGE	0
+#endif
+#ifndef DVFS_WACOM_STAGE
+#define DVFS_WACOM_STAGE	0
+#endif
+
+//#if DVFS_TSP_STAGE
+#define COMMON_INPUT_BOOSTER 1
+//#endif
+/* TSP */
+#define INPUT_BOOSTER_OFF_TIME_TSP		500
+#define INPUT_BOOSTER_CHG_TIME_TSP		130
+#define INPUT_BOOSTER_HIGH_OFF_TIME_TSP		1000
+#define INPUT_BOOSTER_HIGH_CHG_TIME_TSP		500
+
+/* Touchkey */
+#define INPUT_BOOSTER_OFF_TIME_TKEY		500
+#define INPUT_BOOSTER_CHG_TIME_TKEY		500
+
+/* Wacom */
+#define INPUT_BOOSTER_OFF_TIME_WACOM		500
+#define INPUT_BOOSTER_CHG_TIME_WACOM		130
+
+struct input_booster {
+	struct delayed_work	work_dvfs_off;
+	struct delayed_work	work_dvfs_chg;
+	struct mutex		dvfs_lock;
+	bool dvfs_lock_status;
+	int dvfs_old_stauts;
+	int dvfs_boost_mode;
+	int dvfs_freq;
+	int dvfs_id;
+	int dvfs_stage;
+	int (*dvfs_off)(struct input_booster *);
+	void (*dvfs_set)(struct input_booster *, int);
+};
+void input_booster_init_dvfs(struct input_booster *booster, int id);
+
+#else	/* CONFIG_INPUT_BOOSTER */
+
+#include <linux/device.h>
+
+#define INPUT_BOOSTER_NAME	"input_booster"
+
+enum input_booster_id {
+	INPUT_BOOSTER_ID_TSP = 0,
+	INPUT_BOOSTER_ID_TKEY,
+	INPUT_BOOSTER_ID_WACOM,
+};
+
+#define DVFS_STAGE_NONE		1 << 0	// 0000 0000 0000 0001
+#define DVFS_STAGE_SINGLE	1 << 1	// 0000 0000 0000 0010
+#define DVFS_STAGE_DUAL		1 << 2	// 0000 0000 0000 0100
+#define DVFS_STAGE_TRIPLE	1 << 3	// 0000 0000 0000 1000
+#define DVFS_STAGE_PENTA	1 << 5	// 0000 0000 0010 0000
+#define DVFS_STAGE_NINTH	1 << 9	// 0000 0010 0000 0000
+
+/* Touchkey */
+#define INPUT_BOOSTER_OFF_TIME_TKEY		500
+#define INPUT_BOOSTER_CHG_TIME_TKEY		500
+
+struct input_booster {
+	struct delayed_work	work_dvfs_off;
+	struct delayed_work	work_dvfs_chg;
+	struct mutex		dvfs_lock;
+
+	bool dvfs_lock_status;
+	int dvfs_old_stauts;
+	int dvfs_boost_mode;
+	int dvfs_freq;
+	int bimc_freq;
+	int dvfs_id;
+	int dvfs_stage;
+
+	int (*dvfs_off)(struct input_booster *);
+	void (*dvfs_set)(struct input_booster *, int);
+};
+
+struct dvfs {
+	int time;
+	s32 cpu_freq;
+	s32 bimc_freq;
+};
+
+struct input_booster_dt_data {
+	int tsp_stage;
+	int tkey_stage;
+	int wacom_stage;
+	int level;
+	struct dvfs head;
+	struct dvfs tail;
+};
+
+struct input_booster_data {
+	struct device *dev;
+	struct input_booster_dt_data *dt_data;
+	struct class *booster_class;
+	int dbg_level;
+	int level;
+	struct dvfs head;
+	struct dvfs tail;
+};
+
+struct input_booster *input_booster_allocate(int id);
+void input_booster_free(struct input_booster *booster);
+void input_booster_get_default_setting(const char *flag, struct dvfs *value);
+void input_booster_set_level_change(int val);
+
+#ifdef CONFIG_DEBUG_BUS_VOTER
+extern int msm_bus_floor_vote(const char *name, u64 floor_hz);
+#endif
+
+#endif	/* CONFIG_INPUT_BOOSTER */
+
+#endif /* _INPUT_BOOSTER_H_ */
diff --git a/include/linux/wacom_i2c.h b/include/linux/wacom_i2c.h
index 5ded4f9f0444..faa39f58e246 100755
--- a/include/linux/wacom_i2c.h
+++ b/include/linux/wacom_i2c.h
@@ -20,6 +20,11 @@
 #endif
 #include <linux/pinctrl/consumer.h>
 
+#ifdef CONFIG_COMMON_INPUT_BOOSTER
+#include <linux/input/input_booster.h>
+#define WACOM_BOOSTER
+#endif
+
 /* WACOM NOISE from LCD OSC.
  * read Vsync frequency value at wacom firmware.
  */
